# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Any, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._maps_mobility_client_enums import *


class AgencyDetails(msrest.serialization.Model):
    """Details of the agency. Returned if specified in the request.

    :param agency_id: The Id of the relevant transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_key: The agency’s GTFS Id.
    :type agency_key: str
    :param agency_name: Name of the relevant transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param transit_type: Supported public transit type. One of Tram, Subway, Rail, Bus, Ferry,
     CableCar, Gondola, Funicular.
    :type transit_type: ~azure.maps.mobility.models.TransitTypeResult
    """

    _attribute_map = {
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_key': {'key': 'agencyKey', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'TransitTypeResult'},
    }

    def __init__(
        self,
        *,
        agency_id: Optional[str] = None,
        agency_key: Optional[str] = None,
        agency_name: Optional[str] = None,
        transit_type: Optional["TransitTypeResult"] = None,
        **kwargs
    ):
        super(AgencyDetails, self).__init__(**kwargs)
        self.agency_id = agency_id
        self.agency_key = agency_key
        self.agency_name = agency_name
        self.transit_type = transit_type


class AlertDescription(msrest.serialization.Model):
    """AlertDescription.

    :param data: Description of the alert.
    :type data: str
    :param format: Format of the alert description.
    :type format: str
    :param source_url: Source URL.
    :type source_url: str
    """

    _attribute_map = {
        'data': {'key': 'data', 'type': 'str'},
        'format': {'key': 'format', 'type': 'str'},
        'source_url': {'key': 'sourceUrl', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        data: Optional[str] = None,
        format: Optional[str] = None,
        source_url: Optional[str] = None,
        **kwargs
    ):
        super(AlertDescription, self).__init__(**kwargs)
        self.data = data
        self.format = format
        self.source_url = source_url


class AlertDetail(msrest.serialization.Model):
    """A list of alert details.

    :param agency_id: The Id of the relevant transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: Name of the relevant transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param title: The title of the alert.
    :type title: str
    :param description: A short description of the alert.
    :type description: ~azure.maps.mobility.models.AlertDescription
    :param active_from: The start time of the alert in the local time in ISO format
     (2019-04-05T14:24:18-04:00).
    :type active_from: ~datetime.datetime
    :param active_to: The estimated end time of the alert in the local time in ISO format
     (2019-04-05T14:24:18-04:00).
    :type active_to: ~datetime.datetime
    :param effect: Service Alert effect - one of SA_NO_SERVICE, SA_REDUCED_SERVICE,
     SA_SIGNIFICANT_DELAYS, SA_DETOUR, SA_ADDITIONAL_SERVICE, SA_MODIFIED_SERVICE, SA_OTHER_EFFECT,
     SA_STOP_MOVED, SA_GOOD_SERVICE, SA_SLEEPING, SA_OTHER_EFFECT.
    :type effect: str
    """

    _attribute_map = {
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'description': {'key': 'description', 'type': 'AlertDescription'},
        'active_from': {'key': 'activeFrom', 'type': 'iso-8601'},
        'active_to': {'key': 'activeTo', 'type': 'iso-8601'},
        'effect': {'key': 'effect', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional["AlertDescription"] = None,
        active_from: Optional[datetime.datetime] = None,
        active_to: Optional[datetime.datetime] = None,
        effect: Optional[str] = None,
        **kwargs
    ):
        super(AlertDetail, self).__init__(**kwargs)
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.title = title
        self.description = description
        self.active_from = active_from
        self.active_to = active_to
        self.effect = effect


class AlertInformation(msrest.serialization.Model):
    """Basic information associated with the active alert. Returned if specified in the request and there is an active alert in the metro area.

    :param alert_summary: Text summarizing the alert.
    :type alert_summary: str
    :param publication_date: The date and time in ISO 8601 format, e.g. 2019-04-05T14:24:18-04:00.
    :type publication_date: ~datetime.datetime
    :param category: The category of the alert. One of None, Regular, Info, Modified, Critical.
    :type category: str
    :param alert_level: The level at which the respective alert extents to. One of Metro, Agency,
     Line, Stop.
    :type alert_level: str
    :param details: A list of alert details.
    :type details: ~azure.maps.mobility.models.AlertDetail
    """

    _attribute_map = {
        'alert_summary': {'key': 'alertSummary', 'type': 'str'},
        'publication_date': {'key': 'publicationDate', 'type': 'iso-8601'},
        'category': {'key': 'category', 'type': 'str'},
        'alert_level': {'key': 'alertLevel', 'type': 'str'},
        'details': {'key': 'details', 'type': 'AlertDetail'},
    }

    def __init__(
        self,
        *,
        alert_summary: Optional[str] = None,
        publication_date: Optional[datetime.datetime] = None,
        category: Optional[str] = None,
        alert_level: Optional[str] = None,
        details: Optional["AlertDetail"] = None,
        **kwargs
    ):
        super(AlertInformation, self).__init__(**kwargs)
        self.alert_summary = alert_summary
        self.publication_date = publication_date
        self.category = category
        self.alert_level = alert_level
        self.details = details


class CoordinatesPair(msrest.serialization.Model):
    """A location represented as a latitude and longitude.

    :param latitude: Latitude property.
    :type latitude: float
    :param longitude: Longitude property.
    :type longitude: float
    """

    _attribute_map = {
        'latitude': {'key': 'latitude', 'type': 'float'},
        'longitude': {'key': 'longitude', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        latitude: Optional[float] = None,
        longitude: Optional[float] = None,
        **kwargs
    ):
        super(CoordinatesPair, self).__init__(**kwargs)
        self.latitude = latitude
        self.longitude = longitude


class ErrorAdditionalInfo(msrest.serialization.Model):
    """The resource management error additional info.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    _validation = {
        'type': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'info': {'key': 'info', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorAdditionalInfo, self).__init__(**kwargs)
        self.type = None
        self.info = None


class ErrorDetail(msrest.serialization.Model):
    """The error detail.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.maps.mobility.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.maps.mobility.models.ErrorAdditionalInfo]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
        'details': {'readonly': True},
        'additional_info': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
        'additional_info': {'key': 'additionalInfo', 'type': '[ErrorAdditionalInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorDetail, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None
        self.details = None
        self.additional_info = None


class ErrorResponse(msrest.serialization.Model):
    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).

    :param error: The error object.
    :type error: ~azure.maps.mobility.models.ErrorDetail
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        error: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class FareDetail(msrest.serialization.Model):
    """Detailed fare information for the leg.

    :param price: The price of the ticket when purchased for the individual leg, not for the
     entire route at once.
    :type price: ~azure.maps.mobility.models.FarePrice
    :param usage: Supported values are:
    
    
     * pay – user is expected to pay for this ticket in order to consume the current leg
     * transfer – user can use a ticket purchased in a previous leg in order to consume the current
     leg. In general, when transfer is specified, the number of transfers is counted, and has a
     limit.
     * continue – user can use a ticket purchased in a previous leg in order to consume the current
     leg. In general, when continue is specified, the number of transfers isn’t incremented for this
     leg.
     * upgrade – user is expected to upgrade a ticket purchased in a previous leg in order to
     consume the current leg.
    :type usage: str
    """

    _attribute_map = {
        'price': {'key': 'price', 'type': 'FarePrice'},
        'usage': {'key': 'usage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        price: Optional["FarePrice"] = None,
        usage: Optional[str] = None,
        **kwargs
    ):
        super(FareDetail, self).__init__(**kwargs)
        self.price = price
        self.usage = usage


class FarePrice(msrest.serialization.Model):
    """FarePrice.

    :param amount: Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
    :type amount: int
    :param currency_code: Currency code, for example for US dollars “USD”.
    :type currency_code: str
    """

    _attribute_map = {
        'amount': {'key': 'amount', 'type': 'int'},
        'currency_code': {'key': 'currencyCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        amount: Optional[int] = None,
        currency_code: Optional[str] = None,
        **kwargs
    ):
        super(FarePrice, self).__init__(**kwargs)
        self.amount = amount
        self.currency_code = currency_code


class FareTicket(msrest.serialization.Model):
    """The price of a ticket that the user is expected to purchase throughout this itinerary.

    :param amount: Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
    :type amount: int
    :param currency_code: Currency code, for example for US dollars “USD”.
    :type currency_code: str
    """

    _attribute_map = {
        'amount': {'key': 'amount', 'type': 'int'},
        'currency_code': {'key': 'currencyCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        amount: Optional[int] = None,
        currency_code: Optional[str] = None,
        **kwargs
    ):
        super(FareTicket, self).__init__(**kwargs)
        self.amount = amount
        self.currency_code = currency_code


class GeoJsonFeatureData(msrest.serialization.Model):
    """GeoJsonFeatureData.

    All required parameters must be populated in order to send to Azure.

    :param geometry: Required. A valid ``GeoJSON`` geometry object. The type must be one of the
     seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon,
     MultiPolygon and GeometryCollection. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.
    :type geometry: ~azure.maps.mobility.models.GeoJsonGeometry
    :param properties: Properties can contain any additional metadata about the ``Feature``. Value
     can be any JSON object or a JSON null value.
    :type properties: any
    :param id: Identifier for the feature.
    :type id: str
    :param feature_type: The type of the feature. The value depends on the data model the current
     feature is part of. Some data models may have an empty value.
    :type feature_type: str
    """

    _validation = {
        'geometry': {'required': True},
    }

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'GeoJsonGeometry'},
        'properties': {'key': 'properties', 'type': 'object'},
        'id': {'key': 'id', 'type': 'str'},
        'feature_type': {'key': 'featureType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometry: "GeoJsonGeometry",
        properties: Optional[Any] = None,
        id: Optional[str] = None,
        feature_type: Optional[str] = None,
        **kwargs
    ):
        super(GeoJsonFeatureData, self).__init__(**kwargs)
        self.geometry = geometry
        self.properties = properties
        self.id = id
        self.feature_type = feature_type


class GeoJsonObject(msrest.serialization.Model):
    """A valid ``GeoJSON`` object. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: GeoJsonFeature, GeoJsonFeatureCollection, GeoJsonGeometry.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Feature': 'GeoJsonFeature', 'FeatureCollection': 'GeoJsonFeatureCollection', 'GeoJsonGeometry': 'GeoJsonGeometry'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoJsonObject, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class GeoJsonFeature(GeoJsonObject, GeoJsonFeatureData):
    """A valid ``GeoJSON Feature`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.2>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param geometry: Required. A valid ``GeoJSON`` geometry object. The type must be one of the
     seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon,
     MultiPolygon and GeometryCollection. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.
    :type geometry: ~azure.maps.mobility.models.GeoJsonGeometry
    :param properties: Properties can contain any additional metadata about the ``Feature``. Value
     can be any JSON object or a JSON null value.
    :type properties: any
    :param id: Identifier for the feature.
    :type id: str
    :param feature_type: The type of the feature. The value depends on the data model the current
     feature is part of. Some data models may have an empty value.
    :type feature_type: str
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'geometry': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'GeoJsonGeometry'},
        'properties': {'key': 'properties', 'type': 'object'},
        'id': {'key': 'id', 'type': 'str'},
        'feature_type': {'key': 'featureType', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometry: "GeoJsonGeometry",
        properties: Optional[Any] = None,
        id: Optional[str] = None,
        feature_type: Optional[str] = None,
        **kwargs
    ):
        super(GeoJsonFeature, self).__init__(geometry=geometry, properties=properties, id=id, feature_type=feature_type, **kwargs)
        self.geometry = geometry
        self.properties = properties
        self.id = id
        self.feature_type = feature_type
        self.type = 'Feature'  # type: str
        self.type = 'Feature'  # type: str


class GeoJsonFeatureCollectionData(msrest.serialization.Model):
    """GeoJsonFeatureCollectionData.

    All required parameters must be populated in order to send to Azure.

    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.mobility.models.GeoJsonFeature]
    """

    _validation = {
        'features': {'required': True},
    }

    _attribute_map = {
        'features': {'key': 'features', 'type': '[GeoJsonFeature]'},
    }

    def __init__(
        self,
        *,
        features: List["GeoJsonFeature"],
        **kwargs
    ):
        super(GeoJsonFeatureCollectionData, self).__init__(**kwargs)
        self.features = features


class GeoJsonFeatureCollection(GeoJsonObject, GeoJsonFeatureCollectionData):
    """A valid ``GeoJSON FeatureCollection`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.mobility.models.GeoJsonFeature]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'features': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'features': {'key': 'features', 'type': '[GeoJsonFeature]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        features: List["GeoJsonFeature"],
        **kwargs
    ):
        super(GeoJsonFeatureCollection, self).__init__(features=features, **kwargs)
        self.features = features
        self.type = 'FeatureCollection'  # type: str
        self.type = 'FeatureCollection'  # type: str


class GeoJsonGeometry(GeoJsonObject):
    """A valid ``GeoJSON`` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: GeoJsonGeometryCollection, GeoJsonLineString, GeoJsonMultiLineString, GeoJsonMultiPoint, GeoJsonMultiPolygon, GeoJsonPoint, GeoJsonPolygon.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'GeometryCollection': 'GeoJsonGeometryCollection', 'LineString': 'GeoJsonLineString', 'MultiLineString': 'GeoJsonMultiLineString', 'MultiPoint': 'GeoJsonMultiPoint', 'MultiPolygon': 'GeoJsonMultiPolygon', 'Point': 'GeoJsonPoint', 'Polygon': 'GeoJsonPolygon'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoJsonGeometry, self).__init__(**kwargs)
        self.type = 'GeoJsonGeometry'  # type: str


class GeoJsonGeometryCollectionData(msrest.serialization.Model):
    """GeoJsonGeometryCollectionData.

    All required parameters must be populated in order to send to Azure.

    :param geometries: Required. Contains a list of valid ``GeoJSON`` geometry objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type geometries: list[~azure.maps.mobility.models.GeoJsonGeometry]
    """

    _validation = {
        'geometries': {'required': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeoJsonGeometry]'},
    }

    def __init__(
        self,
        *,
        geometries: List["GeoJsonGeometry"],
        **kwargs
    ):
        super(GeoJsonGeometryCollectionData, self).__init__(**kwargs)
        self.geometries = geometries


class GeoJsonGeometryCollection(GeoJsonGeometry, GeoJsonGeometryCollectionData):
    """A valid ``GeoJSON GeometryCollection`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.8>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param geometries: Required. Contains a list of valid ``GeoJSON`` geometry objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type geometries: list[~azure.maps.mobility.models.GeoJsonGeometry]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'geometries': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeoJsonGeometry]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometries: List["GeoJsonGeometry"],
        **kwargs
    ):
        super(GeoJsonGeometryCollection, self).__init__(geometries=geometries, **kwargs)
        self.geometries = geometries
        self.type = 'GeometryCollection'  # type: str
        self.type = 'GeometryCollection'  # type: str


class GeoJsonLineStringData(msrest.serialization.Model):
    """GeoJsonLineStringData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson LineString`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonLineStringData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonLineString(GeoJsonGeometry, GeoJsonLineStringData):
    """A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson LineString`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonLineString, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'LineString'  # type: str
        self.type = 'LineString'  # type: str


class GeoJsonMultiLineStringData(msrest.serialization.Model):
    """GeoJsonMultiLineStringData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiLineString`` geometry.
    :type coordinates: list[list[list[float]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonMultiLineStringData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiLineString(GeoJsonGeometry, GeoJsonMultiLineStringData):
    """A valid ``GeoJSON MultiLineString`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.5>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiLineString`` geometry.
    :type coordinates: list[list[list[float]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonMultiLineString, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiLineString'  # type: str
        self.type = 'MultiLineString'  # type: str


class GeoJsonMultiPointData(msrest.serialization.Model):
    """Data contained by a ``GeoJson MultiPoint``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonMultiPointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiPoint(GeoJsonGeometry, GeoJsonMultiPointData):
    """A valid ``GeoJSON MultiPoint`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.3>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonMultiPoint, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPoint'  # type: str
        self.type = 'MultiPoint'  # type: str


class GeoJsonMultiPolygonData(msrest.serialization.Model):
    """GeoJsonMultiPolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON Polygon`` objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(GeoJsonMultiPolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiPolygon(GeoJsonGeometry, GeoJsonMultiPolygonData):
    """A valid ``GeoJSON MultiPolygon`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.7>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON Polygon`` objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(GeoJsonMultiPolygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPolygon'  # type: str
        self.type = 'MultiPolygon'  # type: str


class GeoJsonPointData(msrest.serialization.Model):
    """Data contained by a ``GeoJson Point``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A ``Position`` is an array of numbers with two or more elements.
     The first two elements are *longitude* and *latitude*\ , precisely in that order.
     *Altitude/Elevation* is an optional third element. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(GeoJsonPointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonPoint(GeoJsonGeometry, GeoJsonPointData):
    """A valid ``GeoJSON Point`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.2>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A ``Position`` is an array of numbers with two or more elements.
     The first two elements are *longitude* and *latitude*\ , precisely in that order.
     *Altitude/Elevation* is an optional third element. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(GeoJsonPoint, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Point'  # type: str
        self.type = 'Point'  # type: str


class GeoJsonPolygonData(msrest.serialization.Model):
    """GeoJsonPolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonPolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonPolygon(GeoJsonGeometry, GeoJsonPolygonData):
    """A valid ``GeoJSON Polygon`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.6>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.mobility.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonPolygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Polygon'  # type: str
        self.type = 'Polygon'  # type: str


class ItineraryFare(msrest.serialization.Model):
    """Itinerary level transit fare information.

    :param price: The total price for all tickets a user is expected to purchase in order to
     complete this itinerary.
    :type price: ~azure.maps.mobility.models.FarePrice
    :param tickets: An array describing the individual prices of each of the tickets that the user
     is expected to purchase throughout this itinerary. The list isn’t ordered.
    :type tickets: list[~azure.maps.mobility.models.FareTicket]
    """

    _attribute_map = {
        'price': {'key': 'price', 'type': 'FarePrice'},
        'tickets': {'key': 'tickets', 'type': '[FareTicket]'},
    }

    def __init__(
        self,
        *,
        price: Optional["FarePrice"] = None,
        tickets: Optional[List["FareTicket"]] = None,
        **kwargs
    ):
        super(ItineraryFare, self).__init__(**kwargs)
        self.price = price
        self.tickets = tickets


class ItineraryLeg(msrest.serialization.Model):
    """ItineraryLeg.

    :param leg_type: The travel mode of the leg. Possible values include: "Walk", "Bicycle",
     "Tram", "Subway", "Rail", "Bus", "Ferry", "Cable", "Gondola", "Funicular", "PathWayWalk",
     "Wait", "WaitOnVehicle".
    :type leg_type: str or ~azure.maps.mobility.models.LegType
    :param leg_start_time: Start time for the leg.
    :type leg_start_time: str
    :param leg_end_time: End time for the leg.
    :type leg_end_time: str
    :param steps: In case of walk or bike leg, the directions.
    :type steps: list[~azure.maps.mobility.models.ItineraryStep]
    :param origin: The walk/bike leg’s origin.
    :type origin: ~azure.maps.mobility.models.LegPoint
    :param destination: The walk/bike leg’s destination.
    :type destination: ~azure.maps.mobility.models.LegPoint
    :param geometry: A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.
    :type geometry: ~azure.maps.mobility.models.GeoJsonLineString
    :param line_group: In case of a public transit leg, the line group serving this leg.
    :type line_group: ~azure.maps.mobility.models.ItineraryLineGroup
    :param line: In case of a public transit leg, the line serving this leg.
    :type line: ~azure.maps.mobility.models.ItineraryLine
    :param stops: List of stops comprising the line’s route within the leg (e.g. the stops the leg
     passes through).
    :type stops: list[~azure.maps.mobility.models.LegStop]
    :param departures: Relevant for Public Transit and Wait legs only.
    :type departures: list[~azure.maps.mobility.models.LineArrival]
    :param leg_fare: Leg level public transit fare information. Returned only if fare information
     is available for the entire itinerary.
    :type leg_fare: ~azure.maps.mobility.models.LegFare
    :param wait_on_vehicle: Indicates whether it’s necessary to wait for the next leg on the same
     vehicle (i.e. the bus will only change its line number).
    :type wait_on_vehicle: str
    """

    _attribute_map = {
        'leg_type': {'key': 'legType', 'type': 'str'},
        'leg_start_time': {'key': 'legStartTime', 'type': 'str'},
        'leg_end_time': {'key': 'legEndTime', 'type': 'str'},
        'steps': {'key': 'steps', 'type': '[ItineraryStep]'},
        'origin': {'key': 'origin', 'type': 'LegPoint'},
        'destination': {'key': 'destination', 'type': 'LegPoint'},
        'geometry': {'key': 'geometry', 'type': 'GeoJsonLineString'},
        'line_group': {'key': 'lineGroup', 'type': 'ItineraryLineGroup'},
        'line': {'key': 'line', 'type': 'ItineraryLine'},
        'stops': {'key': 'stops', 'type': '[LegStop]'},
        'departures': {'key': 'departures', 'type': '[LineArrival]'},
        'leg_fare': {'key': 'legFare', 'type': 'LegFare'},
        'wait_on_vehicle': {'key': 'waitOnVehicle', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        leg_type: Optional[Union[str, "LegType"]] = None,
        leg_start_time: Optional[str] = None,
        leg_end_time: Optional[str] = None,
        steps: Optional[List["ItineraryStep"]] = None,
        origin: Optional["LegPoint"] = None,
        destination: Optional["LegPoint"] = None,
        geometry: Optional["GeoJsonLineString"] = None,
        line_group: Optional["ItineraryLineGroup"] = None,
        line: Optional["ItineraryLine"] = None,
        stops: Optional[List["LegStop"]] = None,
        departures: Optional[List["LineArrival"]] = None,
        leg_fare: Optional["LegFare"] = None,
        wait_on_vehicle: Optional[str] = None,
        **kwargs
    ):
        super(ItineraryLeg, self).__init__(**kwargs)
        self.leg_type = leg_type
        self.leg_start_time = leg_start_time
        self.leg_end_time = leg_end_time
        self.steps = steps
        self.origin = origin
        self.destination = destination
        self.geometry = geometry
        self.line_group = line_group
        self.line = line
        self.stops = stops
        self.departures = departures
        self.leg_fare = leg_fare
        self.wait_on_vehicle = wait_on_vehicle


class ItineraryLine(msrest.serialization.Model):
    """A stop line.

    :param line_id: Line Id.
    :type line_id: str
    :param line_group_id: Line group Id. Typically contains 2 lines having the same agency and
     line, one going from A to B, and the other from B to A.
    :type line_group_id: str
    :param direction: Line direction. Possible values 'forward' or 'backward'.
    :type direction: str
    :param agency_id: The Id of the transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: The name of the transit agency, for example, 'NJ Transit'.
    :type agency_name: str
    :param line_number: The transit line number.
    :type line_number: str
    :param origin: The line’s origin, will be present according to metro settings.
    :type origin: str
    :param line_destination: The line’s user displayable destination.
    :type line_destination: str
    :param most_frequent_pattern_id: Most common pattern for the line.
    :type most_frequent_pattern_id: str
    :param transit_type: The public transit type of the line. Possible values include: "Bus",
     "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram", "Subway".
    :type transit_type: str or ~azure.maps.mobility.models.TransitType
    """

    _attribute_map = {
        'line_id': {'key': 'lineId', 'type': 'str'},
        'line_group_id': {'key': 'lineGroupId', 'type': 'str'},
        'direction': {'key': 'direction', 'type': 'str'},
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'line_number': {'key': 'lineNumber', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'line_destination': {'key': 'lineDestination', 'type': 'str'},
        'most_frequent_pattern_id': {'key': 'mostFrequentPatternId', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_id: Optional[str] = None,
        line_group_id: Optional[str] = None,
        direction: Optional[str] = None,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        line_number: Optional[str] = None,
        origin: Optional[str] = None,
        line_destination: Optional[str] = None,
        most_frequent_pattern_id: Optional[str] = None,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        **kwargs
    ):
        super(ItineraryLine, self).__init__(**kwargs)
        self.line_id = line_id
        self.line_group_id = line_group_id
        self.direction = direction
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.line_number = line_number
        self.origin = origin
        self.line_destination = line_destination
        self.most_frequent_pattern_id = most_frequent_pattern_id
        self.transit_type = transit_type


class ItineraryLineGroup(msrest.serialization.Model):
    """A line group.

    :param line_group_id: Line group Id. Typically contains 2 lines having the same agency and
     line, one going from A to B, and the other from B to A.
    :type line_group_id: str
    :param agency_id: The Id of the transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: The name of the transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param line_number: The transit line number.
    :type line_number: str
    :param caption1: A descriptive string. In case caption2 is null, should be used alone as a
     subtitle to the line number (i.e. Circular). In case caption2 has a value present, should be
     used in conjunction with it (i.e. Rome ↔ Napoli).
    :type caption1: str
    :param caption2: A descriptive string.
    :type caption2: str
    :param color: HEX color for the line.
    :type color: str
    :param transit_type: The public transit type of the line. Possible values include: "Bus",
     "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram", "Subway".
    :type transit_type: str or ~azure.maps.mobility.models.TransitType
    """

    _attribute_map = {
        'line_group_id': {'key': 'lineGroupId', 'type': 'str'},
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'line_number': {'key': 'lineNumber', 'type': 'str'},
        'caption1': {'key': 'caption1', 'type': 'str'},
        'caption2': {'key': 'caption2', 'type': 'str'},
        'color': {'key': 'color', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_group_id: Optional[str] = None,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        line_number: Optional[str] = None,
        caption1: Optional[str] = None,
        caption2: Optional[str] = None,
        color: Optional[str] = None,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        **kwargs
    ):
        super(ItineraryLineGroup, self).__init__(**kwargs)
        self.line_group_id = line_group_id
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.line_number = line_number
        self.caption1 = caption1
        self.caption2 = caption2
        self.color = color
        self.transit_type = transit_type


class ItineraryPattern(msrest.serialization.Model):
    """Stop-shape-segments of the trip pattern, which are an ordered list of the stops and the shapes connecting them.

    :param pattern_id: Pattern Id, for example, '3267995'.
    :type pattern_id: str
    :param line_id: Line Id.
    :type line_id: str
    :param stop_ids: Stops the line goes through.
    :type stop_ids: list[str]
    :param geometry: Stop sequence and shape per a line in GeoJSON format.
    :type geometry: ~azure.maps.mobility.models.GeoJsonLineString
    """

    _attribute_map = {
        'pattern_id': {'key': 'patternId', 'type': 'str'},
        'line_id': {'key': 'lineId', 'type': 'str'},
        'stop_ids': {'key': 'stopIds', 'type': '[str]'},
        'geometry': {'key': 'geometry', 'type': 'GeoJsonLineString'},
    }

    def __init__(
        self,
        *,
        pattern_id: Optional[str] = None,
        line_id: Optional[str] = None,
        stop_ids: Optional[List[str]] = None,
        geometry: Optional["GeoJsonLineString"] = None,
        **kwargs
    ):
        super(ItineraryPattern, self).__init__(**kwargs)
        self.pattern_id = pattern_id
        self.line_id = line_id
        self.stop_ids = stop_ids
        self.geometry = geometry


class ItineraryResult(msrest.serialization.Model):
    """ItineraryResult.

    :param itinerary_id: A unique identifier of the returned itinerary.
    :type itinerary_id: str
    :param departure_time: The date and time of departure from the origin point in ISO 8601 format,
     e.g. 1996-12-19T16:39:57-08:00.
    :type departure_time: ~datetime.datetime
    :param arrival_time: The date and time of arrival at the destination point in ISO 8601 format,
     e.g. 1996-12-19T19:39:57-08:00.
    :type arrival_time: ~datetime.datetime
    :param travel_time_in_seconds: Estimated travel time in seconds.
    :type travel_time_in_seconds: int
    :param number_of_legs: Number of legs.
    :type number_of_legs: int
    :param legs: An array summarizing the legs of this itinerary.
    :type legs: list[~azure.maps.mobility.models.RouteItineraryLeg]
    :param itinerary_fare: Itinerary level transit fare information. Returned only if fare
     information is available for the entire itinerary. `Get Metro Area Info API
     <https://aka.ms/AzureMapsMobilityMetroAreaInfo>`_ can be requested to confirm if fare
     information is available in the metro area.
    :type itinerary_fare: ~azure.maps.mobility.models.ItineraryFare
    """

    _attribute_map = {
        'itinerary_id': {'key': 'itineraryId', 'type': 'str'},
        'departure_time': {'key': 'departureTime', 'type': 'iso-8601'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'iso-8601'},
        'travel_time_in_seconds': {'key': 'travelTimeInSeconds', 'type': 'int'},
        'number_of_legs': {'key': 'numberOfLegs', 'type': 'int'},
        'legs': {'key': 'legs', 'type': '[RouteItineraryLeg]'},
        'itinerary_fare': {'key': 'itineraryFare', 'type': 'ItineraryFare'},
    }

    def __init__(
        self,
        *,
        itinerary_id: Optional[str] = None,
        departure_time: Optional[datetime.datetime] = None,
        arrival_time: Optional[datetime.datetime] = None,
        travel_time_in_seconds: Optional[int] = None,
        number_of_legs: Optional[int] = None,
        legs: Optional[List["RouteItineraryLeg"]] = None,
        itinerary_fare: Optional["ItineraryFare"] = None,
        **kwargs
    ):
        super(ItineraryResult, self).__init__(**kwargs)
        self.itinerary_id = itinerary_id
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.travel_time_in_seconds = travel_time_in_seconds
        self.number_of_legs = number_of_legs
        self.legs = legs
        self.itinerary_fare = itinerary_fare


class ItineraryStep(msrest.serialization.Model):
    """ItineraryStep.

    :param direction: The walking direction associated with this step.
    :type direction: ~azure.maps.mobility.models.WalkingDirection
    :param street_name: The name of the street in which this step takes place.
    :type street_name: str
    """

    _attribute_map = {
        'direction': {'key': 'direction', 'type': 'WalkingDirection'},
        'street_name': {'key': 'streetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        direction: Optional["WalkingDirection"] = None,
        street_name: Optional[str] = None,
        **kwargs
    ):
        super(ItineraryStep, self).__init__(**kwargs)
        self.direction = direction
        self.street_name = street_name


class LegFare(msrest.serialization.Model):
    """Leg level public transit fare information. Returned only if fare information is available for the entire itinerary level and supported by the local transit agency.

    :param fares: Details of the fare.
    :type fares: list[~azure.maps.mobility.models.FareDetail]
    """

    _attribute_map = {
        'fares': {'key': 'fares', 'type': '[FareDetail]'},
    }

    def __init__(
        self,
        *,
        fares: Optional[List["FareDetail"]] = None,
        **kwargs
    ):
        super(LegFare, self).__init__(**kwargs)
        self.fares = fares


class LegPoint(msrest.serialization.Model):
    """LegPoint.

    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.mobility.models.CoordinatesPair
    """

    _attribute_map = {
        'position': {'key': 'position', 'type': 'CoordinatesPair'},
    }

    def __init__(
        self,
        *,
        position: Optional["CoordinatesPair"] = None,
        **kwargs
    ):
        super(LegPoint, self).__init__(**kwargs)
        self.position = position


class LegStop(msrest.serialization.Model):
    """The stop's basic info.

    :param stop_id: The unique Azure Maps identifier for the respective public transit stop. When
     referring to public transit stops over time, it is recommended to use ``stopId`` since it will
     not change, as long as the physical stop exists.
    :type stop_id: str
    :param stop_key: The GTFS stop Id. GTFS stop Ids are provided by the transit authority and
     subject to change.
    :type stop_key: str
    :param stop_name: The name of the stop.
    :type stop_name: str
    :param stop_code: The stop code displayed at the physical stop. Returned if available.
    :type stop_code: str
    :param position: The Stop's location, latitude and longitude.
    :type position: ~azure.maps.mobility.models.CoordinatesPair
    :param main_transit_type: The transit type of most lines stopping at this stop. One of Tram,
     Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular.
    :type main_transit_type: str
    :param main_agency_id: The Id of the transit agency of most lines stopping at this stop. For
     example '5872'.
    :type main_agency_id: str
    :param main_agency_name: The name of the agency of most lines stopping at this stop, for
     example, 'Metro Transit'.
    :type main_agency_name: str
    """

    _attribute_map = {
        'stop_id': {'key': 'stopId', 'type': 'str'},
        'stop_key': {'key': 'stopKey', 'type': 'str'},
        'stop_name': {'key': 'stopName', 'type': 'str'},
        'stop_code': {'key': 'stopCode', 'type': 'str'},
        'position': {'key': 'position', 'type': 'CoordinatesPair'},
        'main_transit_type': {'key': 'mainTransitType', 'type': 'str'},
        'main_agency_id': {'key': 'mainAgencyId', 'type': 'str'},
        'main_agency_name': {'key': 'mainAgencyName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        stop_id: Optional[str] = None,
        stop_key: Optional[str] = None,
        stop_name: Optional[str] = None,
        stop_code: Optional[str] = None,
        position: Optional["CoordinatesPair"] = None,
        main_transit_type: Optional[str] = None,
        main_agency_id: Optional[str] = None,
        main_agency_name: Optional[str] = None,
        **kwargs
    ):
        super(LegStop, self).__init__(**kwargs)
        self.stop_id = stop_id
        self.stop_key = stop_key
        self.stop_name = stop_name
        self.stop_code = stop_code
        self.position = position
        self.main_transit_type = main_transit_type
        self.main_agency_id = main_agency_id
        self.main_agency_name = main_agency_name


class LineArrival(msrest.serialization.Model):
    """LineArrival.

    :param line_id: Line Id.
    :type line_id: str
    :param stop_id: The unique Azure Maps identifier for the respective public transit stop. When
     referring to public transit stops over time, it is recommended to use ``stopId`` since it will
     not change, as long as the physical stop exists.
    :type stop_id: str
    :param schedule_time: The date and time of departure from the stop in ISO 8601 format, e.g.
     1996-12-19T19:39:57-08:00.
    :type schedule_time: ~datetime.datetime
    :param schedule_type: Whether the result is based on real-time or static data. Possible values
     include: "scheduledTime", "realTime".
    :type schedule_type: str or ~azure.maps.mobility.models.ScheduleType
    """

    _attribute_map = {
        'line_id': {'key': 'lineId', 'type': 'str'},
        'stop_id': {'key': 'stopId', 'type': 'str'},
        'schedule_time': {'key': 'scheduleTime', 'type': 'iso-8601'},
        'schedule_type': {'key': 'scheduleType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_id: Optional[str] = None,
        stop_id: Optional[str] = None,
        schedule_time: Optional[datetime.datetime] = None,
        schedule_type: Optional[Union[str, "ScheduleType"]] = None,
        **kwargs
    ):
        super(LineArrival, self).__init__(**kwargs)
        self.line_id = line_id
        self.stop_id = stop_id
        self.schedule_time = schedule_time
        self.schedule_type = schedule_type


class MetroAreaInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Metro Area Info call.

    :param metro_name: The name of the metro area.
    :type metro_name: str
    :param is_fares_supported: Indicates if public transit fares information is available in the
     metro area. Fare information is available through `Get Transit Route API
     <https://aka.ms/AzureMapsMobilityTransitRoute>`_ and `Get Transit Itinerary APIs
     <https://aka.ms/AzureMapsMobilityTransitItinerary>`_.
    :type is_fares_supported: str
    :param transit_types: Supported transit types in the metro area. Returned if specified in the
     request.
    :type transit_types: list[~azure.maps.mobility.models.TransitTypeResult]
    :param agencies: A list of all public transit agencies operating in the given metro area.
    :type agencies: list[~azure.maps.mobility.models.AgencyDetails]
    :param alerts: A list of all public transit alerts within the given metro area.
    :type alerts: list[~azure.maps.mobility.models.AlertInformation]
    """

    _attribute_map = {
        'metro_name': {'key': 'metroName', 'type': 'str'},
        'is_fares_supported': {'key': 'isFaresSupported', 'type': 'str'},
        'transit_types': {'key': 'transitTypes', 'type': '[TransitTypeResult]'},
        'agencies': {'key': 'agencies', 'type': '[AgencyDetails]'},
        'alerts': {'key': 'alerts', 'type': '[AlertInformation]'},
    }

    def __init__(
        self,
        *,
        metro_name: Optional[str] = None,
        is_fares_supported: Optional[str] = None,
        transit_types: Optional[List["TransitTypeResult"]] = None,
        agencies: Optional[List["AgencyDetails"]] = None,
        alerts: Optional[List["AlertInformation"]] = None,
        **kwargs
    ):
        super(MetroAreaInfoResponse, self).__init__(**kwargs)
        self.metro_name = metro_name
        self.is_fares_supported = is_fares_supported
        self.transit_types = transit_types
        self.agencies = agencies
        self.alerts = alerts


class MetroAreaResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Metro Area call.

    :param results: All resulting metro area details.
    :type results: list[~azure.maps.mobility.models.MetroAreaResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[MetroAreaResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["MetroAreaResult"]] = None,
        **kwargs
    ):
        super(MetroAreaResponse, self).__init__(**kwargs)
        self.results = results


class MetroAreaResult(msrest.serialization.Model):
    """Details of the metro area.

    :param metro_id: The metro area's Id for use with other API calls.
    :type metro_id: int
    :param metro_name: The main display name of the metro.
    :type metro_name: str
    :param geometry: A valid ``GeoJSON Polygon`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.6>`_ for details.
    :type geometry: ~azure.maps.mobility.models.GeoJsonPolygon
    :param viewport: The viewport that covers the result represented by the top-left and
     bottom-right coordinates of the  viewport.
    :type viewport: ~azure.maps.mobility.models.ResultViewport
    """

    _attribute_map = {
        'metro_id': {'key': 'metroId', 'type': 'int'},
        'metro_name': {'key': 'metroName', 'type': 'str'},
        'geometry': {'key': 'geometry', 'type': 'GeoJsonPolygon'},
        'viewport': {'key': 'viewport', 'type': 'ResultViewport'},
    }

    def __init__(
        self,
        *,
        metro_id: Optional[int] = None,
        metro_name: Optional[str] = None,
        geometry: Optional["GeoJsonPolygon"] = None,
        viewport: Optional["ResultViewport"] = None,
        **kwargs
    ):
        super(MetroAreaResult, self).__init__(**kwargs)
        self.metro_id = metro_id
        self.metro_name = metro_name
        self.geometry = geometry
        self.viewport = viewport


class NearbyTransitResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Nearby Transit call.

    :param results: All resulting nearby transit details.
    :type results: list[~azure.maps.mobility.models.TransitObjectResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[TransitObjectResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["TransitObjectResult"]] = None,
        **kwargs
    ):
        super(NearbyTransitResponse, self).__init__(**kwargs)
        self.results = results


class RealTimeArrivalResult(msrest.serialization.Model):
    """Contains real-time arrival related details.

    :param arrival_minutes: The estimated time of arrival in minutes.
    :type arrival_minutes: int
    :param schedule_type: Whether the result is based on real-time or static data. Possible values
     include: "scheduledTime", "realTime".
    :type schedule_type: str or ~azure.maps.mobility.models.ScheduleType
    :param pattern_id: The pattern Id.
    :type pattern_id: str
    :param line: The public transit type of the line.
    :type line: ~azure.maps.mobility.models.ItineraryLine
    :param stop: Object for the given stop.
    :type stop: ~azure.maps.mobility.models.LegStop
    """

    _attribute_map = {
        'arrival_minutes': {'key': 'arrivalMinutes', 'type': 'int'},
        'schedule_type': {'key': 'scheduleType', 'type': 'str'},
        'pattern_id': {'key': 'patternId', 'type': 'str'},
        'line': {'key': 'line', 'type': 'ItineraryLine'},
        'stop': {'key': 'stop', 'type': 'LegStop'},
    }

    def __init__(
        self,
        *,
        arrival_minutes: Optional[int] = None,
        schedule_type: Optional[Union[str, "ScheduleType"]] = None,
        pattern_id: Optional[str] = None,
        line: Optional["ItineraryLine"] = None,
        stop: Optional["LegStop"] = None,
        **kwargs
    ):
        super(RealTimeArrivalResult, self).__init__(**kwargs)
        self.arrival_minutes = arrival_minutes
        self.schedule_type = schedule_type
        self.pattern_id = pattern_id
        self.line = line
        self.stop = stop


class RealTimeArrivalsResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Real Time Arrival Info call.

    :param results: Results array. Contains results related details.
    :type results: list[~azure.maps.mobility.models.RealTimeArrivalResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[RealTimeArrivalResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["RealTimeArrivalResult"]] = None,
        **kwargs
    ):
        super(RealTimeArrivalsResponse, self).__init__(**kwargs)
        self.results = results


class ResultViewport(msrest.serialization.Model):
    """The viewport that covers the result represented by the top-left and bottom-right coordinates of the  viewport.

    :param top_left_point: A location represented as a latitude and longitude.
    :type top_left_point: ~azure.maps.mobility.models.CoordinatesPair
    :param btm_right_point: A location represented as a latitude and longitude.
    :type btm_right_point: ~azure.maps.mobility.models.CoordinatesPair
    """

    _attribute_map = {
        'top_left_point': {'key': 'topLeftPoint', 'type': 'CoordinatesPair'},
        'btm_right_point': {'key': 'btmRightPoint', 'type': 'CoordinatesPair'},
    }

    def __init__(
        self,
        *,
        top_left_point: Optional["CoordinatesPair"] = None,
        btm_right_point: Optional["CoordinatesPair"] = None,
        **kwargs
    ):
        super(ResultViewport, self).__init__(**kwargs)
        self.top_left_point = top_left_point
        self.btm_right_point = btm_right_point


class RouteItineraryLeg(msrest.serialization.Model):
    """RouteItineraryLeg.

    :param leg_type: The travel mode of the leg. Possible values include: "Walk", "Bicycle",
     "Tram", "Subway", "Rail", "Bus", "Ferry", "Cable", "Gondola", "Funicular", "PathWayWalk",
     "Wait", "WaitOnVehicle".
    :type leg_type: str or ~azure.maps.mobility.models.LegType
    :param leg_fare: Leg level public transit fare information. Returned only if fare information
     is available for the entire itinerary.
    :type leg_fare: ~azure.maps.mobility.models.LegFare
    :param leg_start_time: Start time for the leg in ISO 8601 format, e.g.
     1996-12-19T19:39:57-08:00.
    :type leg_start_time: str
    :param leg_end_time: End time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
    :type leg_end_time: str
    :param caption: For Public Transit legs the caption of the line serving the leg, for example,
     line number.
    :type caption: str
    :param length_in_meters: The total distance of the leg in meters.
    :type length_in_meters: int
    """

    _attribute_map = {
        'leg_type': {'key': 'legType', 'type': 'str'},
        'leg_fare': {'key': 'legFare', 'type': 'LegFare'},
        'leg_start_time': {'key': 'legStartTime', 'type': 'str'},
        'leg_end_time': {'key': 'legEndTime', 'type': 'str'},
        'caption': {'key': 'caption', 'type': 'str'},
        'length_in_meters': {'key': 'lengthInMeters', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        leg_type: Optional[Union[str, "LegType"]] = None,
        leg_fare: Optional["LegFare"] = None,
        leg_start_time: Optional[str] = None,
        leg_end_time: Optional[str] = None,
        caption: Optional[str] = None,
        length_in_meters: Optional[int] = None,
        **kwargs
    ):
        super(RouteItineraryLeg, self).__init__(**kwargs)
        self.leg_type = leg_type
        self.leg_fare = leg_fare
        self.leg_start_time = leg_start_time
        self.leg_end_time = leg_end_time
        self.caption = caption
        self.length_in_meters = length_in_meters


class TransitItineraryResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Itinerary call.

    :param departure_time: The date and time of departure from the origin point in ISO 8601 format,
     e.g. 1996-12-19T16:39:57-08:00.
    :type departure_time: str
    :param arrival_time: The date and time of arrival at the destination point in ISO 8601 format,
     e.g. 1996-12-19T19:39:57-08:00.
    :type arrival_time: str
    :param legs: An array summarizing the legs of this itinerary.
    :type legs: list[~azure.maps.mobility.models.ItineraryLeg]
    :param itinerary_fare: Itinerary level transit fare information. Returned only if fare
     information is available for the entire itinerary. `Get Metro Area Info API
     <https://aka.ms/AzureMapsMobilityMetroAreaInfo>`_ can be requested to confirm if fare
     information is available in the metro area.
    :type itinerary_fare: ~azure.maps.mobility.models.ItineraryFare
    """

    _attribute_map = {
        'departure_time': {'key': 'departureTime', 'type': 'str'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'str'},
        'legs': {'key': 'legs', 'type': '[ItineraryLeg]'},
        'itinerary_fare': {'key': 'itineraryFare', 'type': 'ItineraryFare'},
    }

    def __init__(
        self,
        *,
        departure_time: Optional[str] = None,
        arrival_time: Optional[str] = None,
        legs: Optional[List["ItineraryLeg"]] = None,
        itinerary_fare: Optional["ItineraryFare"] = None,
        **kwargs
    ):
        super(TransitItineraryResponse, self).__init__(**kwargs)
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.legs = legs
        self.itinerary_fare = itinerary_fare


class TransitLineInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Transit Line Info call.

    :param line_group: Groups together all lines that are logically part of the same group.
     Typically contains 2 lines having the same agency and line, one going from A to B, and the
     other from B to A.
    :type line_group: ~azure.maps.mobility.models.ItineraryLineGroup
    :param lines: The line group’s basic info and list of the lines.
    :type lines: list[~azure.maps.mobility.models.ItineraryLine]
    :param stops: List of stops the line group goes through.
    :type stops: list[~azure.maps.mobility.models.LegStop]
    :param patterns: List of patterns this group is comprised of. A pattern consists of a stop
     sequence and shape per a line in GeoJSON format.
    :type patterns: list[~azure.maps.mobility.models.ItineraryPattern]
    :param schedule: Line schedule for the current 24h. May be null in case no schedule exists for
     the current time.
    :type schedule: ~azure.maps.mobility.models.LineArrival
    """

    _attribute_map = {
        'line_group': {'key': 'lineGroup', 'type': 'ItineraryLineGroup'},
        'lines': {'key': 'lines', 'type': '[ItineraryLine]'},
        'stops': {'key': 'stops', 'type': '[LegStop]'},
        'patterns': {'key': 'patterns', 'type': '[ItineraryPattern]'},
        'schedule': {'key': 'schedule', 'type': 'LineArrival'},
    }

    def __init__(
        self,
        *,
        line_group: Optional["ItineraryLineGroup"] = None,
        lines: Optional[List["ItineraryLine"]] = None,
        stops: Optional[List["LegStop"]] = None,
        patterns: Optional[List["ItineraryPattern"]] = None,
        schedule: Optional["LineArrival"] = None,
        **kwargs
    ):
        super(TransitLineInfoResponse, self).__init__(**kwargs)
        self.line_group = line_group
        self.lines = lines
        self.stops = stops
        self.patterns = patterns
        self.schedule = schedule


class TransitObjectResult(msrest.serialization.Model):
    """TransitObjectResult.

    :param id: The unique identifier (stopID) for the returned public transit stop. When referring
     to public transit stops over time, it is recommended to use ``stopId`` since it will not
     change, as long as the physical stop exists.
    :type id: str
    :param type: The type of object found as a result of the query.
    :type type: str
    :param object_details: The object specific details.
    :type object_details: any
    :param position: The transit object's position.
    :type position: ~azure.maps.mobility.models.CoordinatesPair
    :param viewport: The viewport that covers the result represented by the top-left and
     bottom-right coordinates of the  viewport.
    :type viewport: ~azure.maps.mobility.models.ResultViewport
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'object_details': {'key': 'objectDetails', 'type': 'object'},
        'position': {'key': 'position', 'type': 'CoordinatesPair'},
        'viewport': {'key': 'viewport', 'type': 'ResultViewport'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        type: Optional[str] = None,
        object_details: Optional[Any] = None,
        position: Optional["CoordinatesPair"] = None,
        viewport: Optional["ResultViewport"] = None,
        **kwargs
    ):
        super(TransitObjectResult, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.object_details = object_details
        self.position = position
        self.viewport = viewport


class TransitRouteResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Stop Info call.

    :param results: All resulting transit stops details.
    :type results: list[~azure.maps.mobility.models.ItineraryResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[ItineraryResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["ItineraryResult"]] = None,
        **kwargs
    ):
        super(TransitRouteResponse, self).__init__(**kwargs)
        self.results = results


class TransitStopInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Stop Info call.

    :param stop: The stop's basic info.
    :type stop: ~azure.maps.mobility.models.LegStop
    :param lines: A list of stop lines.
    :type lines: list[~azure.maps.mobility.models.ItineraryLine]
    :param line_groups: A list of line groups.
    :type line_groups: list[~azure.maps.mobility.models.ItineraryLineGroup]
    :param alerts: A list of stop alerts.
    :type alerts: list[~azure.maps.mobility.models.AlertInformation]
    """

    _attribute_map = {
        'stop': {'key': 'stop', 'type': 'LegStop'},
        'lines': {'key': 'lines', 'type': '[ItineraryLine]'},
        'line_groups': {'key': 'lineGroups', 'type': '[ItineraryLineGroup]'},
        'alerts': {'key': 'alerts', 'type': '[AlertInformation]'},
    }

    def __init__(
        self,
        *,
        stop: Optional["LegStop"] = None,
        lines: Optional[List["ItineraryLine"]] = None,
        line_groups: Optional[List["ItineraryLineGroup"]] = None,
        alerts: Optional[List["AlertInformation"]] = None,
        **kwargs
    ):
        super(TransitStopInfoResponse, self).__init__(**kwargs)
        self.stop = stop
        self.lines = lines
        self.line_groups = line_groups
        self.alerts = alerts


class TransitTypeResult(msrest.serialization.Model):
    """TransitTypeResult.

    :param transit_type: Supported public transit type. Returned if specified in the request.
     Possible values include: "Bus", "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram",
     "Subway".
    :type transit_type: str or ~azure.maps.mobility.models.TransitType
    :param caption_override: For metro areas in which local name is different than the GTFS
     supported transit type, original name is returned.
    :type caption_override: str
    """

    _attribute_map = {
        'transit_type': {'key': 'transitType', 'type': 'str'},
        'caption_override': {'key': 'captionOverride', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        caption_override: Optional[str] = None,
        **kwargs
    ):
        super(TransitTypeResult, self).__init__(**kwargs)
        self.transit_type = transit_type
        self.caption_override = caption_override


class WalkingDirection(msrest.serialization.Model):
    """The walking directions guidance.

    :param relative_direction: The relative walking direction associated with applicable step.
     Possible values include: "depart", "hardLeft", "left", "slightlyLeft", "continue",
     "slightlyRight", "right", "hardRight", "circleClockwise", "circleCounterclockwise", "elevator",
     "uturnLeft", "uturnRight".
    :type relative_direction: str or ~azure.maps.mobility.models.RelativeDirection
    :param absolute_direction: The absolute walking direction associated with this step. Possible
     values include: "north", "northeast", "east", "southeast", "south", "southwest", "west",
     "northwest".
    :type absolute_direction: str or ~azure.maps.mobility.models.AbsoluteDirection
    """

    _attribute_map = {
        'relative_direction': {'key': 'relativeDirection', 'type': 'str'},
        'absolute_direction': {'key': 'absoluteDirection', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        relative_direction: Optional[Union[str, "RelativeDirection"]] = None,
        absolute_direction: Optional[Union[str, "AbsoluteDirection"]] = None,
        **kwargs
    ):
        super(WalkingDirection, self).__init__(**kwargs)
        self.relative_direction = relative_direction
        self.absolute_direction = absolute_direction
