# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._maps_client_enums import *


class Agency(msrest.serialization.Model):
    """Details of the agency. Returned if specified in the request.

    :param agency_id: The Id of the relevant transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_key: The agency’s GTFS Id.
    :type agency_key: str
    :param agency_name: Name of the relevant transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param transit_type: Supported public transit type. One of Tram, Subway, Rail, Bus, Ferry,
     CableCar, Gondola, Funicular.
    :type transit_type: ~azure.maps.service.models.TransitTypeResult
    """

    _attribute_map = {
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_key': {'key': 'agencyKey', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'TransitTypeResult'},
    }

    def __init__(
        self,
        *,
        agency_id: Optional[str] = None,
        agency_key: Optional[str] = None,
        agency_name: Optional[str] = None,
        transit_type: Optional["TransitTypeResult"] = None,
        **kwargs
    ):
        super(Agency, self).__init__(**kwargs)
        self.agency_id = agency_id
        self.agency_key = agency_key
        self.agency_name = agency_name
        self.transit_type = transit_type


class AirAndPollen(msrest.serialization.Model):
    """AirAndPollen.

    :param name: Name of the pollen or pollutant. For example, grass, mold, weed, air quality, tree
     and UV index.
    :type name: str
    :param value: Value of the given type above. Values associated with mold, grass, weed and tree
     are in units of parts per cubic meter. Both air quality and UV are indices, so they are
     unitless.
    :type value: int
    :param category: Category of the air quality or pollution type. For example, low, high, good,
     moderate, unhealthy, hazardous.
    :type category: str
    :param category_value: Value associated with the air quality or pollution category. These
     values range from 1 to 6. 1 implying good conditions, 6 implying hazardous conditions.
    :type category_value: int
    :param type: Only exists for air quality. Examples include ozone and particle pollution.
    :type type: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'int'},
        'category': {'key': 'category', 'type': 'str'},
        'category_value': {'key': 'categoryValue', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[int] = None,
        category: Optional[str] = None,
        category_value: Optional[int] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(AirAndPollen, self).__init__(**kwargs)
        self.name = name
        self.value = value
        self.category = category
        self.category_value = category_value
        self.type = type


class AirQuality(msrest.serialization.Model):
    """Information about the air quality in a specific location at a specific time.

    :param date_time: Date and time of the current observation displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type date_time: str
    :param index: Air quality rating on a scale set by local regulating bodies. Scales can vary
     widely based on location. See `Wikipedia <https://en.wikipedia.org/wiki/Air_quality_index>`_
     for more information.
    :type index: float
    :param global_index: Internationally normalized air quality rating on a scale from 0 to 300 and
     up, with higher numbers representing worse air quality.
    :type global_index: float
    :param dominant_pollutant: The pollutant with the highest concentration.
    :type dominant_pollutant: str
    :param category: One-word description of the air quality in the requested language. For
     example, "Excellent".
    :type category: str
    :param category_color: A unique color corresponding to the category of this air quality result.
    :type category_color: str
    :param description: A textual explanation of this air quality result in the requested language.
    :type description: str
    :param pollutants: Information about individual pollutants.
    :type pollutants: list[~azure.maps.service.models.Pollutant]
    """

    _attribute_map = {
        'date_time': {'key': 'dateTime', 'type': 'str'},
        'index': {'key': 'index', 'type': 'float'},
        'global_index': {'key': 'globalIndex', 'type': 'float'},
        'dominant_pollutant': {'key': 'dominantPollutant', 'type': 'str'},
        'category': {'key': 'category', 'type': 'str'},
        'category_color': {'key': 'categoryColor', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'pollutants': {'key': 'pollutants', 'type': '[Pollutant]'},
    }

    def __init__(
        self,
        *,
        date_time: Optional[str] = None,
        index: Optional[float] = None,
        global_index: Optional[float] = None,
        dominant_pollutant: Optional[str] = None,
        category: Optional[str] = None,
        category_color: Optional[str] = None,
        description: Optional[str] = None,
        pollutants: Optional[List["Pollutant"]] = None,
        **kwargs
    ):
        super(AirQuality, self).__init__(**kwargs)
        self.date_time = date_time
        self.index = index
        self.global_index = global_index
        self.dominant_pollutant = dominant_pollutant
        self.category = category
        self.category_color = category_color
        self.description = description
        self.pollutants = pollutants


class Alert(msrest.serialization.Model):
    """Basic information associated with the active alert. Returned if specified in the request and there is an active alert in the metro area.

    :param alert_summary: Text summarizing the alert.
    :type alert_summary: str
    :param publication_date: The date and time in ISO 8601 format, e.g. 2019-04-05T14:24:18-04:00.
    :type publication_date: ~datetime.datetime
    :param category: The category of the alert. One of None, Regular, Info, Modified, Critical.
    :type category: str
    :param alert_level: The level at which the respective alert extents to. One of Metro, Agency,
     Line, Stop.
    :type alert_level: str
    :param details: A list of alert details.
    :type details: ~azure.maps.service.models.AlertDetail
    """

    _attribute_map = {
        'alert_summary': {'key': 'alertSummary', 'type': 'str'},
        'publication_date': {'key': 'publicationDate', 'type': 'iso-8601'},
        'category': {'key': 'category', 'type': 'str'},
        'alert_level': {'key': 'alertLevel', 'type': 'str'},
        'details': {'key': 'details', 'type': 'AlertDetail'},
    }

    def __init__(
        self,
        *,
        alert_summary: Optional[str] = None,
        publication_date: Optional[datetime.datetime] = None,
        category: Optional[str] = None,
        alert_level: Optional[str] = None,
        details: Optional["AlertDetail"] = None,
        **kwargs
    ):
        super(Alert, self).__init__(**kwargs)
        self.alert_summary = alert_summary
        self.publication_date = publication_date
        self.category = category
        self.alert_level = alert_level
        self.details = details


class AlertArea(msrest.serialization.Model):
    """Information about a severe weather alert issued within an affected area(s). If multiple alerts are active for the same location, the alerts will be returned in order of ``priority`` within the API response, with the highest priority alert being returned at the top of the response.

    :param name: The name of an area which is affected by the alert. The location that was
     requested falls under the alert area.
    :type name: str
    :param summary: Text summarizing the alert in the returned area.
    :type summary: str
    :param start_time: The start date and time of the alert in ISO 8601 format, for example,
     2019-10-27T19:39:57-08:00. If the alert crosses multiple time zones the returned time in the
     response is the local time to the requested coordinate location.
    :type start_time: str
    :param end_time: The end date and time of the alert in ISO 8601 format, for example,
     2019-10-27T19:39:57-08:00. If the alert crosses multiple time zones the returned time in the
     response is the local time to the requested coordinate location.
    :type end_time: str
    :param latest_status: The latest status of the alert in the current area.
    :type latest_status: ~azure.maps.service.models.LatestStatus
    :param alert_details: Full details associated with the alert. Returned if ``details``\ =True.
     This field is always returned in the language(s) of choice by the issuing provider and Azure
     Maps only returns what is created by the provider. Please note, some countries/regions may
     offer their native language and English. Language parameter won’t apply to this field.
    :type alert_details: str
    :param alert_details_language_code: Language of the ``alertDetails``. This field  helps to
     point out that the language of the ``alertDetails`` may differ from the requested language
     parameter. Returned if ``details``\ =True. Language code has been derived from the ISO 639-1
     Alpha-2 codes.
    :type alert_details_language_code: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'summary': {'key': 'summary', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'str'},
        'end_time': {'key': 'endTime', 'type': 'str'},
        'latest_status': {'key': 'latestStatus', 'type': 'LatestStatus'},
        'alert_details': {'key': 'alertDetails', 'type': 'str'},
        'alert_details_language_code': {'key': 'alertDetailsLanguageCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        summary: Optional[str] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        latest_status: Optional["LatestStatus"] = None,
        alert_details: Optional[str] = None,
        alert_details_language_code: Optional[str] = None,
        **kwargs
    ):
        super(AlertArea, self).__init__(**kwargs)
        self.name = name
        self.summary = summary
        self.start_time = start_time
        self.end_time = end_time
        self.latest_status = latest_status
        self.alert_details = alert_details
        self.alert_details_language_code = alert_details_language_code


class AlertDescription(msrest.serialization.Model):
    """AlertDescription.

    :param data: Description of the alert.
    :type data: str
    :param format: Format of the alert description.
    :type format: str
    :param source_url: Source URL.
    :type source_url: str
    """

    _attribute_map = {
        'data': {'key': 'data', 'type': 'str'},
        'format': {'key': 'format', 'type': 'str'},
        'source_url': {'key': 'sourceUrl', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        data: Optional[str] = None,
        format: Optional[str] = None,
        source_url: Optional[str] = None,
        **kwargs
    ):
        super(AlertDescription, self).__init__(**kwargs)
        self.data = data
        self.format = format
        self.source_url = source_url


class AlertDetail(msrest.serialization.Model):
    """A list of alert details.

    :param agency_id: The Id of the relevant transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: Name of the relevant transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param title: The title of the alert.
    :type title: str
    :param description: A short description of the alert.
    :type description: ~azure.maps.service.models.AlertDescription
    :param active_from: The start time of the alert in the local time in ISO format
     (2019-04-05T14:24:18-04:00).
    :type active_from: ~datetime.datetime
    :param active_to: The estimated end time of the alert in the local time in ISO format
     (2019-04-05T14:24:18-04:00).
    :type active_to: ~datetime.datetime
    :param effect: Service Alert effect - one of SA_NO_SERVICE, SA_REDUCED_SERVICE,
     SA_SIGNIFICANT_DELAYS, SA_DETOUR, SA_ADDITIONAL_SERVICE, SA_MODIFIED_SERVICE, SA_OTHER_EFFECT,
     SA_STOP_MOVED, SA_GOOD_SERVICE, SA_SLEEPING, SA_OTHER_EFFECT.
    :type effect: str
    """

    _attribute_map = {
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'description': {'key': 'description', 'type': 'AlertDescription'},
        'active_from': {'key': 'activeFrom', 'type': 'iso-8601'},
        'active_to': {'key': 'activeTo', 'type': 'iso-8601'},
        'effect': {'key': 'effect', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional["AlertDescription"] = None,
        active_from: Optional[datetime.datetime] = None,
        active_to: Optional[datetime.datetime] = None,
        effect: Optional[str] = None,
        **kwargs
    ):
        super(AlertDetail, self).__init__(**kwargs)
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.title = title
        self.description = description
        self.active_from = active_from
        self.active_to = active_to
        self.effect = effect


class AliasCreateResponse(msrest.serialization.Model):
    """The response model for the Alias Create API for the case when the alias was successfully created.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar alias_id: An alias id ``aliasId`` for the created alias.
    :vartype alias_id: str
    """

    _validation = {
        'alias_id': {'readonly': True},
    }

    _attribute_map = {
        'alias_id': {'key': 'aliasId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasCreateResponse, self).__init__(**kwargs)
        self.alias_id = None


class AliasListItem(msrest.serialization.Model):
    """Detailed information for the alias.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar created_timestamp: The created timestamp for the alias.
    :vartype created_timestamp: str
    :ivar alias_id: The id for the alias.
    :vartype alias_id: str
    :ivar resource_id: The id for the resource that this alias references (could be null if the
     alias has not been assigned).
    :vartype resource_id: str
    :ivar last_updated_timestamp: The timestamp of the last time the alias was assigned.
    :vartype last_updated_timestamp: str
    """

    _validation = {
        'created_timestamp': {'readonly': True},
        'alias_id': {'readonly': True},
        'resource_id': {'readonly': True},
        'last_updated_timestamp': {'readonly': True},
    }

    _attribute_map = {
        'created_timestamp': {'key': 'createdTimestamp', 'type': 'str'},
        'alias_id': {'key': 'aliasId', 'type': 'str'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'last_updated_timestamp': {'key': 'lastUpdatedTimestamp', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasListItem, self).__init__(**kwargs)
        self.created_timestamp = None
        self.alias_id = None
        self.resource_id = None
        self.last_updated_timestamp = None


class AliasListResponse(msrest.serialization.Model):
    """The response model for the List API. Returns a list of all the previously created aliases.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar aliases: A list of all the previously created aliases.
    :vartype aliases: list[~azure.maps.service.models.AliasListItem]
    """

    _validation = {
        'aliases': {'readonly': True},
    }

    _attribute_map = {
        'aliases': {'key': 'aliases', 'type': '[AliasListItem]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasListResponse, self).__init__(**kwargs)
        self.aliases = None


class BatchRequestBody(msrest.serialization.Model):
    """This type represents the request body for the Batch service.

    :param batch_items: The list of queries/requests to process.
    :type batch_items: list[~azure.maps.service.models.BatchRequestBodyBatchItemsItem]
    """

    _attribute_map = {
        'batch_items': {'key': 'batchItems', 'type': '[BatchRequestBodyBatchItemsItem]'},
    }

    def __init__(
        self,
        *,
        batch_items: Optional[List["BatchRequestBodyBatchItemsItem"]] = None,
        **kwargs
    ):
        super(BatchRequestBody, self).__init__(**kwargs)
        self.batch_items = batch_items


class BatchRequestBodyBatchItemsItem(msrest.serialization.Model):
    """Batch Query object.

    :param query: Partial query string.
    :type query: str
    """

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        query: Optional[str] = None,
        **kwargs
    ):
        super(BatchRequestBodyBatchItemsItem, self).__init__(**kwargs)
        self.query = query


class BatchResponse(msrest.serialization.Model):
    """This object is returned from a successful Batch service call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary for the batch request.
    :vartype summary: ~azure.maps.service.models.BatchResponseSummary
    :ivar batch_items: Array containing the batch results.
    :vartype batch_items: list[object]
    """

    _validation = {
        'summary': {'readonly': True},
        'batch_items': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'BatchResponseSummary'},
        'batch_items': {'key': 'batchItems', 'type': '[object]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BatchResponse, self).__init__(**kwargs)
        self.summary = None
        self.batch_items = None


class BatchResponseSummary(msrest.serialization.Model):
    """Summary for the batch request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar successful_requests: Number of successful requests in the batch.
    :vartype successful_requests: int
    :ivar total_requests: Total number of requests in the batch.
    :vartype total_requests: int
    """

    _validation = {
        'successful_requests': {'readonly': True},
        'total_requests': {'readonly': True},
    }

    _attribute_map = {
        'successful_requests': {'key': 'successfulRequests', 'type': 'int'},
        'total_requests': {'key': 'totalRequests', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BatchResponseSummary, self).__init__(**kwargs)
        self.successful_requests = None
        self.total_requests = None


class BooleanRuleObject(msrest.serialization.Model):
    """the boolean rule.

    :param true: The color when value is true.
    :type true: str
    :param false: The color when value is false.
    :type false: str
    """

    _attribute_map = {
        'true': {'key': 'true', 'type': 'str'},
        'false': {'key': 'false', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        true: Optional[str] = None,
        false: Optional[str] = None,
        **kwargs
    ):
        super(BooleanRuleObject, self).__init__(**kwargs)
        self.true = true
        self.false = false


class StyleRuleBase(msrest.serialization.Model):
    """contains common properties for numeric, string and boolean style rules.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BooleanTypeStyleRule, NumberTypeStyleRule, StringTypeStyleRule.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "number", "boolean", "string".
    :type type: str or ~azure.maps.service.models.StyleRuleBaseType
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'BooleanTypeStyleRule': 'BooleanTypeStyleRule', 'NumberTypeStyleRule': 'NumberTypeStyleRule', 'StringTypeStyleRule': 'StringTypeStyleRule'}
    }

    def __init__(
        self,
        *,
        key_name: str,
        **kwargs
    ):
        super(StyleRuleBase, self).__init__(**kwargs)
        self.key_name = key_name
        self.type = None  # type: Optional[str]


class BooleanTypeStyleRule(StyleRuleBase):
    """the boolean type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "number", "boolean", "string".
    :type type: str or ~azure.maps.service.models.StyleRuleBaseType
    :param rules: Boolean style rules.
    :type rules: list[~azure.maps.service.models.BooleanRuleObject]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[BooleanRuleObject]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: Optional[List["BooleanRuleObject"]] = None,
        **kwargs
    ):
        super(BooleanTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'BooleanTypeStyleRule'  # type: str
        self.rules = rules


class BoundingBoxResponse(msrest.serialization.Model):
    """This object is returned from a successful Spatial BoundingBox call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary of the call.
    :vartype summary: ~azure.maps.service.models.BoundingBoxResponseSummary
    :ivar result: The bounding box of the input feature collection.
    :vartype result: ~azure.maps.service.models.BoundingBoxResponseResult
    """

    _validation = {
        'summary': {'readonly': True},
        'result': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'BoundingBoxResponseSummary'},
        'result': {'key': 'result', 'type': 'BoundingBoxResponseResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BoundingBoxResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = None


class BoundingBoxResponseResult(msrest.serialization.Model):
    """The bounding box of the input feature collection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar feature: The resulting feature with bounding box geometry.
    :vartype feature: object
    """

    _validation = {
        'feature': {'readonly': True},
    }

    _attribute_map = {
        'feature': {'key': 'feature', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BoundingBoxResponseResult, self).__init__(**kwargs)
        self.feature = None


class BoundingBoxResponseSummary(msrest.serialization.Model):
    """Summary of the call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: The udid for the user data if one exists.
    :vartype udid: str
    :ivar information: The information about what happened during the call.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BoundingBoxResponseSummary, self).__init__(**kwargs)
        self.udid = None
        self.information = None


class BoundingBoxResult(msrest.serialization.Model):
    """The response from a successful Get Data for Bounding Box API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar data: The response from the Get Data for Bounding Box API. The results will be ordered
     starting with the southwest corner, and then proceed west to east and south to north.
    :vartype data: list[~azure.maps.service.models.PointElevationResult]
    """

    _validation = {
        'data': {'readonly': True},
    }

    _attribute_map = {
        'data': {'key': 'data', 'type': '[PointElevationResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BoundingBoxResult, self).__init__(**kwargs)
        self.data = None


class BufferRequestBody(msrest.serialization.Model):
    """An object with a FeatureCollection and a list of distances.  All the feature's properties should contain ``geometryId``\ , which is used for identifying the geometry and is case-sensitive.

    :param geometries: A valid ``GeoJSON FeatureCollection`` object type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.
    :type geometries: ~azure.maps.service.models.GeoJSONFeatureCollection
    :param distances: List of the distances to compute the buffer for, one-to-one per Feature in
     the collection, or one for all Features in the collection.
    :type distances: list[float]
    """

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': 'GeoJSONFeatureCollection'},
        'distances': {'key': 'distances', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        geometries: Optional["GeoJSONFeatureCollection"] = None,
        distances: Optional[List[float]] = None,
        **kwargs
    ):
        super(BufferRequestBody, self).__init__(**kwargs)
        self.geometries = geometries
        self.distances = distances


class BufferResponse(msrest.serialization.Model):
    """This object is returned from a successful Spatial Buffer call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary of the call.
    :vartype summary: ~azure.maps.service.models.BufferResponseSummary
    :param result: The FeatureCollection of buffers for the input.
    :type result: ~azure.maps.service.models.GeoJSONFeatureCollection
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'BufferResponseSummary'},
        'result': {'key': 'result', 'type': 'GeoJSONFeatureCollection'},
    }

    def __init__(
        self,
        *,
        result: Optional["GeoJSONFeatureCollection"] = None,
        **kwargs
    ):
        super(BufferResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class BufferResponseSummary(msrest.serialization.Model):
    """Summary of the call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: The udid for the user data if one exists.
    :vartype udid: str
    :ivar information: The information about what happened during the call.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BufferResponseSummary, self).__init__(**kwargs)
        self.udid = None
        self.information = None


class ClosestPointResultEntry(msrest.serialization.Model):
    """Closest Point Result Entry Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar distance_in_meters: The distance in meters from the source point to the closest point.
    :vartype distance_in_meters: float
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.SpatialCoordinate
    :ivar geometry_id: The unique id identifies a geometry.
    :vartype geometry_id: str
    """

    _validation = {
        'distance_in_meters': {'readonly': True},
        'geometry_id': {'readonly': True},
    }

    _attribute_map = {
        'distance_in_meters': {'key': 'distanceInMeters', 'type': 'float'},
        'position': {'key': 'position', 'type': 'SpatialCoordinate'},
        'geometry_id': {'key': 'geometryId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        position: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(ClosestPointResultEntry, self).__init__(**kwargs)
        self.distance_in_meters = None
        self.position = position
        self.geometry_id = None


class CollectionDefinition(msrest.serialization.Model):
    """collection of GeoJSON features.

    All required parameters must be populated in order to send to Azure.

    :param description: describes the collection.
    :type description: str
    :param id_prefix: Required. prefix of the collection used.
    :type id_prefix: str
    :param name: Required. identifier of the collection used, for example, in URIs.
    :type name: str
    :param title: title of collection.
    :type title: str
    :param geometry_type: Required. type of geometry returned. Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type geometry_type: str or ~azure.maps.service.models.GeometryType
    :param feature_types: Required. type of features returned.
    :type feature_types: list[str]
    :param properties: attributes of the collection used.
    :type properties: list[~azure.maps.service.models.DefinitionProperties]
    :param links:
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'id_prefix': {'required': True},
        'name': {'required': True},
        'geometry_type': {'required': True},
        'feature_types': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'id_prefix': {'key': 'idPrefix', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'geometry_type': {'key': 'geometryType', 'type': 'str'},
        'feature_types': {'key': 'featureTypes', 'type': '[str]'},
        'properties': {'key': 'properties', 'type': '[DefinitionProperties]'},
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        id_prefix: str,
        name: str,
        geometry_type: Union[str, "GeometryType"],
        feature_types: List[str],
        description: Optional[str] = None,
        title: Optional[str] = None,
        properties: Optional[List["DefinitionProperties"]] = None,
        links: Optional[List["Link"]] = None,
        **kwargs
    ):
        super(CollectionDefinition, self).__init__(**kwargs)
        self.description = description
        self.id_prefix = id_prefix
        self.name = name
        self.title = title
        self.geometry_type = geometry_type
        self.feature_types = feature_types
        self.properties = properties
        self.links = links


class CollectionInfo(msrest.serialization.Model):
    """CollectionInfo.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. identifier of the collection used, for example, in URIs.
    :type name: str
    :param title: human readable title of the collection.
    :type title: str
    :param description: a description of the features in the collection.
    :type description: str
    :param links: Required.
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'name': {'required': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        name: str,
        links: List["Link"],
        title: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(CollectionInfo, self).__init__(**kwargs)
        self.name = name
        self.title = title
        self.description = description
        self.links = links


class Color(msrest.serialization.Model):
    """Color.

    :param red: Red component of the RGB value.
    :type red: int
    :param green: Green component of the RGB value.
    :type green: int
    :param blue: Blue component of the RGB value.
    :type blue: int
    :param hex: Hexadecimal color value.
    :type hex: str
    """

    _attribute_map = {
        'red': {'key': 'red', 'type': 'int'},
        'green': {'key': 'green', 'type': 'int'},
        'blue': {'key': 'blue', 'type': 'int'},
        'hex': {'key': 'hex', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        red: Optional[int] = None,
        green: Optional[int] = None,
        blue: Optional[int] = None,
        hex: Optional[str] = None,
        **kwargs
    ):
        super(Color, self).__init__(**kwargs)
        self.red = red
        self.green = green
        self.blue = blue
        self.hex = hex


class Concentration(msrest.serialization.Model):
    """An object containing the number of pollutant particles per volume of air.

    :param value: The numerical value indicating the concentration of the corresponding pollutant.
    :type value: float
    :param unit: Type of unit for the concentration of the pollutant.
    :type unit: str
    :param unit_type: Numeric ID value associated with the type of unit being displayed. Can be
     used for unit translation. Please refer to `Weather Service Concepts
     <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type unit_type: int
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
        'unit': {'key': 'unit', 'type': 'str'},
        'unit_type': {'key': 'unitType', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        value: Optional[float] = None,
        unit: Optional[str] = None,
        unit_type: Optional[int] = None,
        **kwargs
    ):
        super(Concentration, self).__init__(**kwargs)
        self.value = value
        self.unit = unit
        self.unit_type = unit_type


class Content(msrest.serialization.Model):
    """Content.

    All required parameters must be populated in order to send to Azure.

    :param links: Required.
    :type links: list[~azure.maps.service.models.Link]
    :param collections: Required.
    :type collections: list[~azure.maps.service.models.CollectionInfo]
    """

    _validation = {
        'links': {'required': True},
        'collections': {'required': True},
    }

    _attribute_map = {
        'links': {'key': 'links', 'type': '[Link]'},
        'collections': {'key': 'collections', 'type': '[CollectionInfo]'},
    }

    def __init__(
        self,
        *,
        links: List["Link"],
        collections: List["CollectionInfo"],
        **kwargs
    ):
        super(Content, self).__init__(**kwargs)
        self.links = links
        self.collections = collections


class ConversionListDetailInfo(msrest.serialization.Model):
    """Detail information for the conversion requests.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversion_id: A unique id that represents the artifact of a *successfully* completed
     conversion process.
    :vartype conversion_id: str
    :ivar udid: The unique id of the content provided to create this conversion.
    :vartype udid: str
    :ivar created: The date and time of this conversion.
    :vartype created: str
    :ivar description: User provided description of the content being converted.
    :vartype description: str
    :ivar feature_counts: A summary of feature counts in this conversion.
    :vartype feature_counts: object
    """

    _validation = {
        'conversion_id': {'readonly': True},
        'udid': {'readonly': True},
        'created': {'readonly': True},
        'description': {'readonly': True},
        'feature_counts': {'readonly': True},
    }

    _attribute_map = {
        'conversion_id': {'key': 'conversionId', 'type': 'str'},
        'udid': {'key': 'udid', 'type': 'str'},
        'created': {'key': 'created', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'feature_counts': {'key': 'featureCounts', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ConversionListDetailInfo, self).__init__(**kwargs)
        self.conversion_id = None
        self.udid = None
        self.created = None
        self.description = None
        self.feature_counts = None


class ConversionListResponse(msrest.serialization.Model):
    """The response model for the Conversion List API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversions: A list of all the previously submitted conversion requests.
    :vartype conversions: list[~azure.maps.service.models.ConversionListDetailInfo]
    """

    _validation = {
        'conversions': {'readonly': True},
    }

    _attribute_map = {
        'conversions': {'key': 'conversions', 'type': '[ConversionListDetailInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ConversionListResponse, self).__init__(**kwargs)
        self.conversions = None


class Coordinate(msrest.serialization.Model):
    """A location represented as a latitude and longitude.

    :param latitude: Latitude property.
    :type latitude: float
    :param longitude: Longitude property.
    :type longitude: float
    """

    _attribute_map = {
        'latitude': {'key': 'latitude', 'type': 'float'},
        'longitude': {'key': 'longitude', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        latitude: Optional[float] = None,
        longitude: Optional[float] = None,
        **kwargs
    ):
        super(Coordinate, self).__init__(**kwargs)
        self.latitude = latitude
        self.longitude = longitude


class CoordinateAbbreviated(msrest.serialization.Model):
    """A location represented as a latitude and longitude.

    :param lat: Latitude property.
    :type lat: float
    :param lon: Longitude property.
    :type lon: float
    """

    _attribute_map = {
        'lat': {'key': 'lat', 'type': 'float'},
        'lon': {'key': 'lon', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        **kwargs
    ):
        super(CoordinateAbbreviated, self).__init__(**kwargs)
        self.lat = lat
        self.lon = lon


class CopyrightBoundingResult(msrest.serialization.Model):
    """This object is returned from a successful Copyright Bounding call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar general_copyrights: General Copyrights array.
    :vartype general_copyrights: list[str]
    :ivar regions: Regions array.
    :vartype regions: list[~azure.maps.service.models.Region]
    """

    _validation = {
        'format_version': {'readonly': True},
        'general_copyrights': {'readonly': True},
        'regions': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'general_copyrights': {'key': 'generalCopyrights', 'type': '[str]'},
        'regions': {'key': 'regions', 'type': '[Region]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CopyrightBoundingResult, self).__init__(**kwargs)
        self.format_version = None
        self.general_copyrights = None
        self.regions = None


class CopyrightCaptionResult(msrest.serialization.Model):
    """This object is returned from a successful Copyright Caption call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar copyrights_caption: Copyrights Caption property.
    :vartype copyrights_caption: str
    """

    _validation = {
        'format_version': {'readonly': True},
        'copyrights_caption': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'copyrights_caption': {'key': 'copyrightsCaption', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CopyrightCaptionResult, self).__init__(**kwargs)
        self.format_version = None
        self.copyrights_caption = None


class CopyrightTileResult(msrest.serialization.Model):
    """This object is returned from a successful Copyright Tile call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar general_copyrights: General Copyrights array.
    :vartype general_copyrights: list[str]
    :ivar regions: Regions array.
    :vartype regions: list[~azure.maps.service.models.Region]
    """

    _validation = {
        'format_version': {'readonly': True},
        'general_copyrights': {'readonly': True},
        'regions': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'general_copyrights': {'key': 'generalCopyrights', 'type': '[str]'},
        'regions': {'key': 'regions', 'type': '[Region]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CopyrightTileResult, self).__init__(**kwargs)
        self.format_version = None
        self.general_copyrights = None
        self.regions = None


class CopyrightWorldResult(msrest.serialization.Model):
    """This object is returned from a successful Copyright World call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar general_copyrights: General Copyrights array.
    :vartype general_copyrights: list[str]
    :ivar regions: Regions array.
    :vartype regions: list[~azure.maps.service.models.Region]
    """

    _validation = {
        'format_version': {'readonly': True},
        'general_copyrights': {'readonly': True},
        'regions': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'general_copyrights': {'key': 'generalCopyrights', 'type': '[str]'},
        'regions': {'key': 'regions', 'type': '[Region]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CopyrightWorldResult, self).__init__(**kwargs)
        self.format_version = None
        self.general_copyrights = None
        self.regions = None


class Country(msrest.serialization.Model):
    """A country record.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: Country Name.
    :vartype name: str
    :ivar code: ISO-3166 2-letter country code for the country.
    :vartype code: str
    """

    _validation = {
        'name': {'readonly': True},
        'code': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'code': {'key': 'Code', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Country, self).__init__(**kwargs)
        self.name = None
        self.code = None


class CountryRegion(msrest.serialization.Model):
    """The object containing the country/region information.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar iso_code: The IP Address's 2-character code `(ISO 3166-1)
     <https://www.iso.org/iso-3166-country-codes.html>`_ of the country or region as assigned by
     IANA and regional internet authorities. Please note, IP address in ranges reserved for special
     purpose will return Null for country/region.
    :vartype iso_code: str
    """

    _validation = {
        'iso_code': {'readonly': True},
    }

    _attribute_map = {
        'iso_code': {'key': 'isoCode', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CountryRegion, self).__init__(**kwargs)
        self.iso_code = None


class CurrentAirQualityResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Current Air Quality call.

    :param results: A list of all air quality results for the queried location.
    :type results: list[~azure.maps.service.models.AirQuality]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[AirQuality]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["AirQuality"]] = None,
        **kwargs
    ):
        super(CurrentAirQualityResponse, self).__init__(**kwargs)
        self.results = results


class CurrentConditions(msrest.serialization.Model):
    """CurrentConditions.

    :param date_time: Date and time of the current observation displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type date_time: str
    :param phrase: Phrase description of the current weather condition.  Displayed in specified
     language.
    :type phrase: str
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param has_precipitation: Indicates the presence or absence of precipitation. True indicates
     the presence of precipitation, false indicates the absence of precipitation.
    :type has_precipitation: bool
    :param is_day_time: Indicates the time of the day. True indicates 'day',', false indicates
     'night.
    :type is_day_time: bool
    :param temperature: Temperature being returned.
    :type temperature: ~azure.maps.service.models.WeatherUnit
    :param real_feel_temperature: RealFeel™ Temperature being returned.
    :type real_feel_temperature: ~azure.maps.service.models.WeatherUnit
    :param real_feel_temperature_shade: RealFeel™ Temperature being returned. Describes what the
     temperature really feels like in the shade.
    :type real_feel_temperature_shade: ~azure.maps.service.models.WeatherUnit
    :param relative_humidity: Relative humidity is the amount of water vapor present in air
     expressed as a percentage of the amount needed for saturation at the same temperature.
    :type relative_humidity: int
    :param dew_point: The dewpoint temperature in specified unit. The dewpoint temperature is the
     temperature that the air must be cooled to in order to reach saturation.
    :type dew_point: ~azure.maps.service.models.WeatherUnit
    :param wind: Wind details being returned including speed and direction.
    :type wind: ~azure.maps.service.models.Wind
    :param wind_gust: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    :type wind_gust: ~azure.maps.service.models.Wind
    :param uv_index: Measure of the strength of the ultraviolet radiation from the sun. Supported
     values are:
    
    
     * ``0-2`` - Low danger from the sun's UV rays or the average person.
     * ``3-5`` - Moderate risk of harm from unprotected sun exposure.
     * ``6-7`` - High risk of harm from unprotected sun exposure.
     * ``8-10`` - Very high risk of harm from unprotected sun exposure.
     * ``11+`` - Extreme risk of harm from unprotected sun exposure.
    :type uv_index: int
    :param uv_index_phrase: Phrase associated with the ``uvIndex``.
    :type uv_index_phrase: str
    :param visibility: Visibility in specified unit. A measure of the distance at which an object
     or light can be clearly discerned.
    :type visibility: ~azure.maps.service.models.WeatherUnit
    :param obstructions_to_visibility: Cause of limited visibility.
    :type obstructions_to_visibility: str
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    :param ceiling: Cloud ceiling in specified unit. The ceiling is a measurement of the height of
     the base of the lowest clouds.
    :type ceiling: ~azure.maps.service.models.WeatherUnit
    :param pressure: Atmospheric pressure in specified unit.
    :type pressure: ~azure.maps.service.models.WeatherUnit
    :param pressure_tendency: Atmospheric pressure change.
    :type pressure_tendency: ~azure.maps.service.models.PressureTendency
    :param past24_hour_temperature_departure: Departure from the temperature observed 24 hours ago
     in specified unit.
    :type past24_hour_temperature_departure: ~azure.maps.service.models.WeatherUnit
    :param apparent_temperature: Perceived outdoor temperature caused by the combination of air
     temperature, relative humidity, and wind speed in specified unit.
    :type apparent_temperature: ~azure.maps.service.models.WeatherUnit
    :param wind_chill_temperature: Perceived air temperature on exposed skin due to wind.
    :type wind_chill_temperature: ~azure.maps.service.models.WeatherUnit
    :param wet_bulb_temperature: The temperature to which air may be cooled by evaporating water
     into it at constant pressure until it reaches saturation.
    :type wet_bulb_temperature: ~azure.maps.service.models.WeatherUnit
    :param precipitation_summary: Summary of precipitation amounts over the past 24 hours.
    :type precipitation_summary: ~azure.maps.service.models.PrecipitationSummary
    :param temperature_summary: Summary of temperature fluctuations over the past 6, 12, and 24
     hours.
    :type temperature_summary: ~azure.maps.service.models.TemperatureSummary
    """

    _attribute_map = {
        'date_time': {'key': 'dateTime', 'type': 'str'},
        'phrase': {'key': 'phrase', 'type': 'str'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'has_precipitation': {'key': 'hasPrecipitation', 'type': 'bool'},
        'is_day_time': {'key': 'isDayTime', 'type': 'bool'},
        'temperature': {'key': 'temperature', 'type': 'WeatherUnit'},
        'real_feel_temperature': {'key': 'realFeelTemperature', 'type': 'WeatherUnit'},
        'real_feel_temperature_shade': {'key': 'realFeelTemperatureShade', 'type': 'WeatherUnit'},
        'relative_humidity': {'key': 'relativeHumidity', 'type': 'int'},
        'dew_point': {'key': 'dewPoint', 'type': 'WeatherUnit'},
        'wind': {'key': 'wind', 'type': 'Wind'},
        'wind_gust': {'key': 'windGust', 'type': 'Wind'},
        'uv_index': {'key': 'uvIndex', 'type': 'int'},
        'uv_index_phrase': {'key': 'uvIndexPhrase', 'type': 'str'},
        'visibility': {'key': 'visibility', 'type': 'WeatherUnit'},
        'obstructions_to_visibility': {'key': 'obstructionsToVisibility', 'type': 'str'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
        'ceiling': {'key': 'ceiling', 'type': 'WeatherUnit'},
        'pressure': {'key': 'pressure', 'type': 'WeatherUnit'},
        'pressure_tendency': {'key': 'pressureTendency', 'type': 'PressureTendency'},
        'past24_hour_temperature_departure': {'key': 'past24HourTemperatureDeparture', 'type': 'WeatherUnit'},
        'apparent_temperature': {'key': 'apparentTemperature', 'type': 'WeatherUnit'},
        'wind_chill_temperature': {'key': 'windChillTemperature', 'type': 'WeatherUnit'},
        'wet_bulb_temperature': {'key': 'wetBulbTemperature', 'type': 'WeatherUnit'},
        'precipitation_summary': {'key': 'precipitationSummary', 'type': 'PrecipitationSummary'},
        'temperature_summary': {'key': 'temperatureSummary', 'type': 'TemperatureSummary'},
    }

    def __init__(
        self,
        *,
        date_time: Optional[str] = None,
        phrase: Optional[str] = None,
        icon_code: Optional[int] = None,
        has_precipitation: Optional[bool] = None,
        is_day_time: Optional[bool] = None,
        temperature: Optional["WeatherUnit"] = None,
        real_feel_temperature: Optional["WeatherUnit"] = None,
        real_feel_temperature_shade: Optional["WeatherUnit"] = None,
        relative_humidity: Optional[int] = None,
        dew_point: Optional["WeatherUnit"] = None,
        wind: Optional["Wind"] = None,
        wind_gust: Optional["Wind"] = None,
        uv_index: Optional[int] = None,
        uv_index_phrase: Optional[str] = None,
        visibility: Optional["WeatherUnit"] = None,
        obstructions_to_visibility: Optional[str] = None,
        cloud_cover: Optional[int] = None,
        ceiling: Optional["WeatherUnit"] = None,
        pressure: Optional["WeatherUnit"] = None,
        pressure_tendency: Optional["PressureTendency"] = None,
        past24_hour_temperature_departure: Optional["WeatherUnit"] = None,
        apparent_temperature: Optional["WeatherUnit"] = None,
        wind_chill_temperature: Optional["WeatherUnit"] = None,
        wet_bulb_temperature: Optional["WeatherUnit"] = None,
        precipitation_summary: Optional["PrecipitationSummary"] = None,
        temperature_summary: Optional["TemperatureSummary"] = None,
        **kwargs
    ):
        super(CurrentConditions, self).__init__(**kwargs)
        self.date_time = date_time
        self.phrase = phrase
        self.icon_code = icon_code
        self.has_precipitation = has_precipitation
        self.is_day_time = is_day_time
        self.temperature = temperature
        self.real_feel_temperature = real_feel_temperature
        self.real_feel_temperature_shade = real_feel_temperature_shade
        self.relative_humidity = relative_humidity
        self.dew_point = dew_point
        self.wind = wind
        self.wind_gust = wind_gust
        self.uv_index = uv_index
        self.uv_index_phrase = uv_index_phrase
        self.visibility = visibility
        self.obstructions_to_visibility = obstructions_to_visibility
        self.cloud_cover = cloud_cover
        self.ceiling = ceiling
        self.pressure = pressure
        self.pressure_tendency = pressure_tendency
        self.past24_hour_temperature_departure = past24_hour_temperature_departure
        self.apparent_temperature = apparent_temperature
        self.wind_chill_temperature = wind_chill_temperature
        self.wet_bulb_temperature = wet_bulb_temperature
        self.precipitation_summary = precipitation_summary
        self.temperature_summary = temperature_summary


class CurrentConditionsResponse(msrest.serialization.Model):
    """CurrentConditionsResponse.

    :param results:
    :type results: list[~azure.maps.service.models.CurrentConditions]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[CurrentConditions]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["CurrentConditions"]] = None,
        **kwargs
    ):
        super(CurrentConditionsResponse, self).__init__(**kwargs)
        self.results = results


class DailyAirQuality(msrest.serialization.Model):
    """Information about the air quality in a specific location at a specific time.

    :param date_time: Date and time of the current observation displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type date_time: str
    :param index: Air quality rating on a scale set by local regulating bodies. Scales can vary
     widely based on location. See `Wikipedia <https://en.wikipedia.org/wiki/Air_quality_index>`_
     for more information.
    :type index: float
    :param global_index: Internationally normalized air quality rating on a scale from 0 to 300 and
     up, with higher numbers representing worse air quality.
    :type global_index: float
    :param dominant_pollutant: The pollutant with the highest concentration. Possible values
     include: "Carbon Monoxide", "Nitrogen Dioxide", "Ozone", "Particulate Matter 2.5", "Particulate
     Matter 10", "Sulfur Dioxide".
    :type dominant_pollutant: str or ~azure.maps.service.models.DominantPollutant
    :param category: One-word description of the air quality in the requested language. For
     example, "Excellent".
    :type category: str
    :param category_color: A unique color corresponding to the category of this air quality result.
    :type category_color: str
    :param description: A textual explanation of this air quality result in the requested language.
    :type description: str
    """

    _attribute_map = {
        'date_time': {'key': 'dateTime', 'type': 'str'},
        'index': {'key': 'index', 'type': 'float'},
        'global_index': {'key': 'globalIndex', 'type': 'float'},
        'dominant_pollutant': {'key': 'dominantPollutant', 'type': 'str'},
        'category': {'key': 'category', 'type': 'str'},
        'category_color': {'key': 'categoryColor', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        date_time: Optional[str] = None,
        index: Optional[float] = None,
        global_index: Optional[float] = None,
        dominant_pollutant: Optional[Union[str, "DominantPollutant"]] = None,
        category: Optional[str] = None,
        category_color: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(DailyAirQuality, self).__init__(**kwargs)
        self.date_time = date_time
        self.index = index
        self.global_index = global_index
        self.dominant_pollutant = dominant_pollutant
        self.category = category
        self.category_color = category_color
        self.description = description


class DailyAirQualityForecastResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Daily Air Quality Forecast call.

    :param forecasts: A list of all daily air quality forecasts for the queried location.
    :type forecasts: list[~azure.maps.service.models.DailyAirQuality]
    """

    _attribute_map = {
        'forecasts': {'key': 'forecasts', 'type': '[DailyAirQuality]'},
    }

    def __init__(
        self,
        *,
        forecasts: Optional[List["DailyAirQuality"]] = None,
        **kwargs
    ):
        super(DailyAirQualityForecastResponse, self).__init__(**kwargs)
        self.forecasts = forecasts


class DailyForecast(msrest.serialization.Model):
    """DailyForecast.

    :param date: Date and time of the current observation displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type date: str
    :param temperature: Temperature values for the day.
    :type temperature: ~azure.maps.service.models.WeatherUnitRange
    :param real_feel_temperature: RealFeel™ Temperature being returned.
    :type real_feel_temperature: ~azure.maps.service.models.WeatherUnitRange
    :param real_feel_temperature_shade: RealFeel™ Temperature being returned. Describes what the
     temperature really feels like in the shade.
    :type real_feel_temperature_shade: ~azure.maps.service.models.WeatherUnitRange
    :param hours_of_sun: Hours of sun.
    :type hours_of_sun: float
    :param degree_day_summary: Summary of Heating Degree Day or Cooling Degree Day information.
    :type degree_day_summary: ~azure.maps.service.models.DegreeDaySummary
    :param air_and_pollen: airAndPollen.
    :type air_and_pollen: list[~azure.maps.service.models.AirAndPollen]
    :param day: Day.
    :type day: ~azure.maps.service.models.DayOrNight
    :param night: Night.
    :type night: ~azure.maps.service.models.DayOrNight
    :param sources:
    :type sources: list[str]
    """

    _attribute_map = {
        'date': {'key': 'date', 'type': 'str'},
        'temperature': {'key': 'temperature', 'type': 'WeatherUnitRange'},
        'real_feel_temperature': {'key': 'realFeelTemperature', 'type': 'WeatherUnitRange'},
        'real_feel_temperature_shade': {'key': 'realFeelTemperatureShade', 'type': 'WeatherUnitRange'},
        'hours_of_sun': {'key': 'hoursOfSun', 'type': 'float'},
        'degree_day_summary': {'key': 'degreeDaySummary', 'type': 'DegreeDaySummary'},
        'air_and_pollen': {'key': 'airAndPollen', 'type': '[AirAndPollen]'},
        'day': {'key': 'day', 'type': 'DayOrNight'},
        'night': {'key': 'night', 'type': 'DayOrNight'},
        'sources': {'key': 'sources', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        date: Optional[str] = None,
        temperature: Optional["WeatherUnitRange"] = None,
        real_feel_temperature: Optional["WeatherUnitRange"] = None,
        real_feel_temperature_shade: Optional["WeatherUnitRange"] = None,
        hours_of_sun: Optional[float] = None,
        degree_day_summary: Optional["DegreeDaySummary"] = None,
        air_and_pollen: Optional[List["AirAndPollen"]] = None,
        day: Optional["DayOrNight"] = None,
        night: Optional["DayOrNight"] = None,
        sources: Optional[List[str]] = None,
        **kwargs
    ):
        super(DailyForecast, self).__init__(**kwargs)
        self.date = date
        self.temperature = temperature
        self.real_feel_temperature = real_feel_temperature
        self.real_feel_temperature_shade = real_feel_temperature_shade
        self.hours_of_sun = hours_of_sun
        self.degree_day_summary = degree_day_summary
        self.air_and_pollen = air_and_pollen
        self.day = day
        self.night = night
        self.sources = sources


class DailyForecastResponse(msrest.serialization.Model):
    """DailyForecastResponse.

    :param summary: Summary for the main conditions for the requested time period. Notice that
     summary can cover only part of the time period.
    :type summary: ~azure.maps.service.models.DailyForecastSummary
    :param forecasts: Forecast data for each requested day.
    :type forecasts: list[~azure.maps.service.models.DailyForecast]
    """

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'DailyForecastSummary'},
        'forecasts': {'key': 'forecasts', 'type': '[DailyForecast]'},
    }

    def __init__(
        self,
        *,
        summary: Optional["DailyForecastSummary"] = None,
        forecasts: Optional[List["DailyForecast"]] = None,
        **kwargs
    ):
        super(DailyForecastResponse, self).__init__(**kwargs)
        self.summary = summary
        self.forecasts = forecasts


class DailyForecastSummary(msrest.serialization.Model):
    """Summary for the main conditions for the requested time period. Notice that summary can cover only part of the time period.

    :param start_date: Date and time that the summary is in effect, displayed in ISO 8601 format,
     for example, 2019-10-27T19:39:57-08:00.
    :type start_date: str
    :param end_date: Date and time that the summary period ends, displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type end_date: str
    :param severity: severity.
    :type severity: int
    :param phrase: Summary phrase of the daily forecast.  Displayed in specified language.
    :type phrase: str
    :param category: one or 2 word(s) to summarize the phrase.
    :type category: str
    """

    _attribute_map = {
        'start_date': {'key': 'startDate', 'type': 'str'},
        'end_date': {'key': 'endDate', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'int'},
        'phrase': {'key': 'phrase', 'type': 'str'},
        'category': {'key': 'category', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        severity: Optional[int] = None,
        phrase: Optional[str] = None,
        category: Optional[str] = None,
        **kwargs
    ):
        super(DailyForecastSummary, self).__init__(**kwargs)
        self.start_date = start_date
        self.end_date = end_date
        self.severity = severity
        self.phrase = phrase
        self.category = category


class DailyIndex(msrest.serialization.Model):
    """Information about a daily index.

    :param index_name: Name of the index, for example, "Construction", "Outdoor Activity", "Flight
     Delays".
    :type index_name: str
    :param index_id: Numeric ID used to identify the specific index. Please refer to `Weather
     Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details and to see the
     supported index IDs. For example, the index ID can support UI visualization scenarios.
    :type index_id: int
    :param date_time: Date and time of the current observation displayed in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type date_time: str
    :param value: Index value. Ranges from 0.0 to 10.0. Please refer to `Weather Service Concepts
     <https://aka.ms/AzureMapsWeatherConcepts>`_ for details and to see the supported ranges.
    :type value: float
    :param category: Textual description for ``categoryValue`` corresponding to the level that the
     index value falls under, for example "Very Good".
    :type category: str
    :param category_value: Level that the index value falls under, represented by an integer. This
     value can be 1 through 5 and should be used in combination with the ``ascending`` flag because
     it can differ among indices. For example, the following values apply for Mosquito Activity:
     Low=1, Moderate=2, High=3, Very High=4, and Extreme=5.
    :type category_value: int
    :param ascending: Describes the direction of the ``value`` and ``categoryValue``. For example,
     when ``ascending``\ =True, the poorest index value is 0 and the best index value is 10. When
     ``ascending``\ =True, the poorest index value is 10 and the best index value is 0.
    :type ascending: bool
    :param description: A textual explanation that can be used for display purposes to summarize
     the index value and category. For example, when the index value for Flight Delays is very good,
     the description will be "Conditions are excellent for flying!".
    :type description: str
    """

    _attribute_map = {
        'index_name': {'key': 'indexName', 'type': 'str'},
        'index_id': {'key': 'indexId', 'type': 'int'},
        'date_time': {'key': 'dateTime', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
        'category': {'key': 'category', 'type': 'str'},
        'category_value': {'key': 'categoryValue', 'type': 'int'},
        'ascending': {'key': 'ascending', 'type': 'bool'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        index_name: Optional[str] = None,
        index_id: Optional[int] = None,
        date_time: Optional[str] = None,
        value: Optional[float] = None,
        category: Optional[str] = None,
        category_value: Optional[int] = None,
        ascending: Optional[bool] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(DailyIndex, self).__init__(**kwargs)
        self.index_name = index_name
        self.index_id = index_id
        self.date_time = date_time
        self.value = value
        self.category = category
        self.category_value = category_value
        self.ascending = ascending
        self.description = description


class DailyIndicesResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Daily Indices call.

    :param results: A list of all daily indices for the queried location.
    :type results: list[~azure.maps.service.models.DailyIndex]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[DailyIndex]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["DailyIndex"]] = None,
        **kwargs
    ):
        super(DailyIndicesResponse, self).__init__(**kwargs)
        self.results = results


class DatasetDetailInfo(msrest.serialization.Model):
    """Detail information for the dataset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar created: The created timestamp for the dataset.
    :vartype created: str
    :ivar dataset_id: The id for the dataset.
    :vartype dataset_id: str
    :ivar description: The description for the dataset.
    :vartype description: str
    :param dataset_sources: Information about the details of the create request for the dataset.
    :type dataset_sources: ~azure.maps.service.models.DatasetSources
    :ivar feature_counts: The feature counts for the dataset.
    :vartype feature_counts: object
    """

    _validation = {
        'created': {'readonly': True},
        'dataset_id': {'readonly': True},
        'description': {'readonly': True},
        'feature_counts': {'readonly': True},
    }

    _attribute_map = {
        'created': {'key': 'created', 'type': 'str'},
        'dataset_id': {'key': 'datasetId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'dataset_sources': {'key': 'datasetSources', 'type': 'DatasetSources'},
        'feature_counts': {'key': 'featureCounts', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        dataset_sources: Optional["DatasetSources"] = None,
        **kwargs
    ):
        super(DatasetDetailInfo, self).__init__(**kwargs)
        self.created = None
        self.dataset_id = None
        self.description = None
        self.dataset_sources = dataset_sources
        self.feature_counts = None


class DatasetListResponse(msrest.serialization.Model):
    """The response model for the Dataset List API. The response body will contain a list of all the previously created datasets.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar datasets: A list of all the previously created datasets.
    :vartype datasets: list[~azure.maps.service.models.DatasetDetailInfo]
    """

    _validation = {
        'datasets': {'readonly': True},
    }

    _attribute_map = {
        'datasets': {'key': 'datasets', 'type': '[DatasetDetailInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DatasetListResponse, self).__init__(**kwargs)
        self.datasets = None


class DatasetSources(msrest.serialization.Model):
    """Information about the details of the create request for the dataset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversion_ids: The list of ``conversionId`` that were used to create the dataset.
    :vartype conversion_ids: list[str]
    :ivar udids: The list of ``conversionId`` that were used to create the dataset.
    :vartype udids: list[str]
    :ivar append_dataset_id: The dataset that was appended to to create the current dataset.
    :vartype append_dataset_id: str
    :ivar type: The type of data stored in the dataset.
    :vartype type: str
    """

    _validation = {
        'conversion_ids': {'readonly': True},
        'udids': {'readonly': True},
        'append_dataset_id': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'conversion_ids': {'key': 'conversionIds', 'type': '[str]'},
        'udids': {'key': 'udids', 'type': '[str]'},
        'append_dataset_id': {'key': 'appendDatasetId', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DatasetSources, self).__init__(**kwargs)
        self.conversion_ids = None
        self.udids = None
        self.append_dataset_id = None
        self.type = None


class DataSources(msrest.serialization.Model):
    """Optional section. Reference ids for use with the `Get Search Polygon <https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon>`_ API.

    :param geometry: Information about the geometric shape of the result. Only present if type ==
     Geography.
    :type geometry: ~azure.maps.service.models.DataSourcesGeometry
    """

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'DataSourcesGeometry'},
    }

    def __init__(
        self,
        *,
        geometry: Optional["DataSourcesGeometry"] = None,
        **kwargs
    ):
        super(DataSources, self).__init__(**kwargs)
        self.geometry = geometry


class DataSourcesGeometry(msrest.serialization.Model):
    """Information about the geometric shape of the result. Only present if type == Geography.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Pass this as geometryId to the `Get Search Polygon
     <https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon>`_ API to fetch geometry
     information for this result.
    :vartype id: str
    """

    _validation = {
        'id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DataSourcesGeometry, self).__init__(**kwargs)
        self.id = None


class DayOrNight(msrest.serialization.Model):
    """DayOrNight.

    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param icon_phrase: Phrase description of the icon. Displayed in specified language. For
     example, 'Sunny'.
    :type icon_phrase: str
    :param local_source:
    :type local_source: ~azure.maps.service.models.LocalSource
    :param has_precipitation: Indicates the presence or absence of precipitation. True indicates
     the presence of precipitation, false indicates the absence of precipitation.
    :type has_precipitation: bool
    :param precipitation_type: Specifies the type of precipitation ("rain" "snow" "ice" or "mix").
     If dbz = zero, precipitationType is not present in the response.
    :type precipitation_type: str
    :param precipitation_intensity: Description of the intensity.
    :type precipitation_intensity: str
    :param short_phrase: Phrase description of the forecast in specified language. Azure Maps
     attempts to keep this phrase under 30 characters in length, but some languages/weather events
     may result in a longer phrase length, exceeding 30 characters.
    :type short_phrase: str
    :param long_phrase: Phrase description of the forecast in specified language. Azure Maps
     attempts to keep this phrase under 100 characters in length, but some languages/weather events
     may result in a longer phrase length, exceeding 100 characters.
    :type long_phrase: str
    :param precipitation_probability: Percent representing the probability of precipitation. For
     example, '20'.
    :type precipitation_probability: int
    :param thunderstorm_probability: Percent representing the probability of a thunderstorm. For
     example, '80'.
    :type thunderstorm_probability: int
    :param rain_probability: Percent representing the probability of rain. For example, '40'.
    :type rain_probability: int
    :param snow_probability: Percent representing the probability of snow. For example, '30'.
    :type snow_probability: int
    :param ice_probability: Percent representing the probability of ice. For example, '30'.
    :type ice_probability: int
    :param wind: Wind details being returned including speed and direction.
    :type wind: ~azure.maps.service.models.Wind
    :param wind_gust: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    :type wind_gust: ~azure.maps.service.models.Wind
    :param total_liquid: Total liquid equivalent of precipitation during the forecast period.
    :type total_liquid: ~azure.maps.service.models.WeatherUnit
    :param rain: Rain.
    :type rain: ~azure.maps.service.models.WeatherUnit
    :param snow: Snow.
    :type snow: ~azure.maps.service.models.WeatherUnit
    :param ice: Ice.
    :type ice: ~azure.maps.service.models.WeatherUnit
    :param hours_of_precipitation: Hours of precipitation.
    :type hours_of_precipitation: float
    :param hours_of_rain: Hours of rain.
    :type hours_of_rain: float
    :param hours_of_snow: Hours of snow.
    :type hours_of_snow: float
    :param hours_of_ice: Hours of ice.
    :type hours_of_ice: float
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    """

    _attribute_map = {
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'icon_phrase': {'key': 'iconPhrase', 'type': 'str'},
        'local_source': {'key': 'localSource', 'type': 'LocalSource'},
        'has_precipitation': {'key': 'hasPrecipitation', 'type': 'bool'},
        'precipitation_type': {'key': 'precipitationType', 'type': 'str'},
        'precipitation_intensity': {'key': 'precipitationIntensity', 'type': 'str'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
        'long_phrase': {'key': 'longPhrase', 'type': 'str'},
        'precipitation_probability': {'key': 'precipitationProbability', 'type': 'int'},
        'thunderstorm_probability': {'key': 'thunderstormProbability', 'type': 'int'},
        'rain_probability': {'key': 'rainProbability', 'type': 'int'},
        'snow_probability': {'key': 'snowProbability', 'type': 'int'},
        'ice_probability': {'key': 'iceProbability', 'type': 'int'},
        'wind': {'key': 'wind', 'type': 'Wind'},
        'wind_gust': {'key': 'windGust', 'type': 'Wind'},
        'total_liquid': {'key': 'totalLiquid', 'type': 'WeatherUnit'},
        'rain': {'key': 'rain', 'type': 'WeatherUnit'},
        'snow': {'key': 'snow', 'type': 'WeatherUnit'},
        'ice': {'key': 'ice', 'type': 'WeatherUnit'},
        'hours_of_precipitation': {'key': 'hoursOfPrecipitation', 'type': 'float'},
        'hours_of_rain': {'key': 'hoursOfRain', 'type': 'float'},
        'hours_of_snow': {'key': 'hoursOfSnow', 'type': 'float'},
        'hours_of_ice': {'key': 'hoursOfIce', 'type': 'float'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        icon_code: Optional[int] = None,
        icon_phrase: Optional[str] = None,
        local_source: Optional["LocalSource"] = None,
        has_precipitation: Optional[bool] = None,
        precipitation_type: Optional[str] = None,
        precipitation_intensity: Optional[str] = None,
        short_phrase: Optional[str] = None,
        long_phrase: Optional[str] = None,
        precipitation_probability: Optional[int] = None,
        thunderstorm_probability: Optional[int] = None,
        rain_probability: Optional[int] = None,
        snow_probability: Optional[int] = None,
        ice_probability: Optional[int] = None,
        wind: Optional["Wind"] = None,
        wind_gust: Optional["Wind"] = None,
        total_liquid: Optional["WeatherUnit"] = None,
        rain: Optional["WeatherUnit"] = None,
        snow: Optional["WeatherUnit"] = None,
        ice: Optional["WeatherUnit"] = None,
        hours_of_precipitation: Optional[float] = None,
        hours_of_rain: Optional[float] = None,
        hours_of_snow: Optional[float] = None,
        hours_of_ice: Optional[float] = None,
        cloud_cover: Optional[int] = None,
        **kwargs
    ):
        super(DayOrNight, self).__init__(**kwargs)
        self.icon_code = icon_code
        self.icon_phrase = icon_phrase
        self.local_source = local_source
        self.has_precipitation = has_precipitation
        self.precipitation_type = precipitation_type
        self.precipitation_intensity = precipitation_intensity
        self.short_phrase = short_phrase
        self.long_phrase = long_phrase
        self.precipitation_probability = precipitation_probability
        self.thunderstorm_probability = thunderstorm_probability
        self.rain_probability = rain_probability
        self.snow_probability = snow_probability
        self.ice_probability = ice_probability
        self.wind = wind
        self.wind_gust = wind_gust
        self.total_liquid = total_liquid
        self.rain = rain
        self.snow = snow
        self.ice = ice
        self.hours_of_precipitation = hours_of_precipitation
        self.hours_of_rain = hours_of_rain
        self.hours_of_snow = hours_of_snow
        self.hours_of_ice = hours_of_ice
        self.cloud_cover = cloud_cover


class DefinitionProperties(msrest.serialization.Model):
    """DefinitionProperties.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. name of attribute.
    :type name: str
    :param required: Required. is attribute required.
    :type required: bool
    :param type: Required. type of attribute.
    :type type: object
    """

    _validation = {
        'name': {'required': True},
        'required': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'required': {'key': 'required', 'type': 'bool'},
        'type': {'key': 'type', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        name: str,
        required: bool,
        type: object,
        **kwargs
    ):
        super(DefinitionProperties, self).__init__(**kwargs)
        self.name = name
        self.required = required
        self.type = type


class DegreeDaySummary(msrest.serialization.Model):
    """DegreeDaySummary.

    :param heating: Number of degrees that the mean temperature is below 65 degrees F/ 18 degree C.
    :type heating: ~azure.maps.service.models.WeatherUnit
    :param cooling: Number of degrees that the mean temperature is above 65 degrees F/ 18 degree C.
    :type cooling: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'heating': {'key': 'heating', 'type': 'WeatherUnit'},
        'cooling': {'key': 'cooling', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        heating: Optional["WeatherUnit"] = None,
        cooling: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(DegreeDaySummary, self).__init__(**kwargs)
        self.heating = heating
        self.cooling = cooling


class Description(msrest.serialization.Model):
    """Description of a severe weather alert.

    :param localized: Description of the alert in the specified language. By default English (en-
     US) is returned if the language parameter is not specified in the request.
    :type localized: str
    :param english: Description of the alert in English (en-US).
    :type english: str
    """

    _attribute_map = {
        'localized': {'key': 'localized', 'type': 'str'},
        'english': {'key': 'english', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        localized: Optional[str] = None,
        english: Optional[str] = None,
        **kwargs
    ):
        super(Description, self).__init__(**kwargs)
        self.localized = localized
        self.english = english


class Direction(msrest.serialization.Model):
    """The walking directions guidance.

    :param relative_direction: The relative walking direction associated with applicable step.
     Possible values include: "depart", "hardLeft", "left", "slightlyLeft", "continue",
     "slightlyRight", "right", "hardRight", "circleClockwise", "circleCounterclockwise", "elevator",
     "uturnLeft", "uturnRight".
    :type relative_direction: str or ~azure.maps.service.models.RelativeDirection
    :param absolute_direction: The absolute walking direction associated with this step. Possible
     values include: "north", "northeast", "east", "southeast", "south", "southwest", "west",
     "northwest".
    :type absolute_direction: str or ~azure.maps.service.models.AbsoluteDirection
    """

    _attribute_map = {
        'relative_direction': {'key': 'relativeDirection', 'type': 'str'},
        'absolute_direction': {'key': 'absoluteDirection', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        relative_direction: Optional[Union[str, "RelativeDirection"]] = None,
        absolute_direction: Optional[Union[str, "AbsoluteDirection"]] = None,
        **kwargs
    ):
        super(Direction, self).__init__(**kwargs)
        self.relative_direction = relative_direction
        self.absolute_direction = absolute_direction


class ErrorAdditionalInfo(msrest.serialization.Model):
    """The resource management error additional info.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: object
    """

    _validation = {
        'type': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'info': {'key': 'info', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorAdditionalInfo, self).__init__(**kwargs)
        self.type = None
        self.info = None


class ErrorDetail(msrest.serialization.Model):
    """The error detail.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.maps.service.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.maps.service.models.ErrorAdditionalInfo]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
        'details': {'readonly': True},
        'additional_info': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
        'additional_info': {'key': 'additionalInfo', 'type': '[ErrorAdditionalInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorDetail, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None
        self.details = None
        self.additional_info = None


class ErrorResponse(msrest.serialization.Model):
    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).

    :param error: The error object.
    :type error: ~azure.maps.service.models.ErrorDetail
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        error: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class Fares(msrest.serialization.Model):
    """Detailed fare information for the leg.

    :param price: The price of the ticket when purchased for the individual leg, not for the
     entire route at once.
    :type price: ~azure.maps.service.models.Price
    :param usage: Supported values are:
    
    
     * pay – user is expected to pay for this ticket in order to consume the current leg
     * transfer – user can use a ticket purchased in a previous leg in order to consume the current
     leg. In general, when transfer is specified, the number of transfers is counted, and has a
     limit.
     * continue – user can use a ticket purchased in a previous leg in order to consume the current
     leg. In general, when continue is specified, the number of transfers isn’t incremented for this
     leg.
     * upgrade – user is expected to upgrade a ticket purchased in a previous leg in order to
     consume the current leg.
    :type usage: str
    """

    _attribute_map = {
        'price': {'key': 'price', 'type': 'Price'},
        'usage': {'key': 'usage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        price: Optional["Price"] = None,
        usage: Optional[str] = None,
        **kwargs
    ):
        super(Fares, self).__init__(**kwargs)
        self.price = price
        self.usage = usage


class Feature(msrest.serialization.Model):
    """Feature.

    All required parameters must be populated in order to send to Azure.

    :param feature: Required. GeoJSON Feature.
    :type feature: ~azure.maps.service.models.FeatureGeoJSON
    :param links:
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'feature': {'required': True},
    }

    _attribute_map = {
        'feature': {'key': 'feature', 'type': 'FeatureGeoJSON'},
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        feature: "FeatureGeoJSON",
        links: Optional[List["Link"]] = None,
        **kwargs
    ):
        super(Feature, self).__init__(**kwargs)
        self.feature = feature
        self.links = links


class FeatureCollectionGeoJSON(msrest.serialization.Model):
    """FeatureCollectionGeoJSON.

    All required parameters must be populated in order to send to Azure.

    :param type: Required.
    :type type: str
    :param number_returned:
    :type number_returned: int
    :param features: Required.
    :type features: list[~azure.maps.service.models.FeatureGeoJSON]
    :param links:
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'type': {'required': True},
        'features': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'number_returned': {'key': 'numberReturned', 'type': 'int'},
        'features': {'key': 'features', 'type': '[FeatureGeoJSON]'},
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        type: str,
        features: List["FeatureGeoJSON"],
        number_returned: Optional[int] = None,
        links: Optional[List["Link"]] = None,
        **kwargs
    ):
        super(FeatureCollectionGeoJSON, self).__init__(**kwargs)
        self.type = type
        self.number_returned = number_returned
        self.features = features
        self.links = links


class FeatureGeoJSON(msrest.serialization.Model):
    """GeoJSON Feature.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. feature.
    :type type: str
    :param geometry: Required. This represents the geometry for one or more geographical features
     (parks, state boundary etc.) and should be a ``GeoJSON`` compliant type. Please refer to `RFC
     7946 <https://tools.ietf.org/html/rfc7946>`_ for details.
    :type geometry: object
    :param properties: Required. Additional properties of the feature.
    :type properties: object
    :param id: Identifier for the feature.
    :type id: str
    :param feature_type: The type of the feature. The value depends on the data model the current
     feature is part of. Some data models may have an empty value.
    :type feature_type: str
    """

    _validation = {
        'type': {'required': True},
        'geometry': {'required': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'geometry': {'key': 'geometry', 'type': 'object'},
        'properties': {'key': 'properties', 'type': 'object'},
        'id': {'key': 'id', 'type': 'str'},
        'feature_type': {'key': 'featureType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        geometry: object,
        properties: object,
        id: Optional[str] = None,
        feature_type: Optional[str] = None,
        **kwargs
    ):
        super(FeatureGeoJSON, self).__init__(**kwargs)
        self.type = type
        self.geometry = geometry
        self.properties = properties
        self.id = id
        self.feature_type = feature_type


class FeatureStateObject(msrest.serialization.Model):
    """Single feature state model.

    :param key_name: Feature state Keyname.
    :type key_name: str
    :param value: Value for the feature state.
    :type value: object
    :param event_timestamp: Timestamp when the feature state was captured.
    :type event_timestamp: str
    """

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'value': {'key': 'value', 'type': 'object'},
        'event_timestamp': {'key': 'eventTimestamp', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_name: Optional[str] = None,
        value: Optional[object] = None,
        event_timestamp: Optional[str] = None,
        **kwargs
    ):
        super(FeatureStateObject, self).__init__(**kwargs)
        self.key_name = key_name
        self.value = value
        self.event_timestamp = event_timestamp


class FeatureStatesStructure(msrest.serialization.Model):
    """The feature states model for a feature.

    :param states: The feature states array.
    :type states: list[~azure.maps.service.models.FeatureStateObject]
    """

    _attribute_map = {
        'states': {'key': 'states', 'type': '[FeatureStateObject]'},
    }

    def __init__(
        self,
        *,
        states: Optional[List["FeatureStateObject"]] = None,
        **kwargs
    ):
        super(FeatureStatesStructure, self).__init__(**kwargs)
        self.states = states


class GeofenceGeometry(msrest.serialization.Model):
    """The geofencing geometry.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar device_id: ID of the device.
    :vartype device_id: str
    :ivar ud_id: The unique id returned from `Data Upload API <https://docs.microsoft.com/en-
     us/rest/api/maps/data/uploadPreview>`_ after uploading a valid GeoJSON FeatureCollection
     object. Please refer to  `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
     details. All the feature's properties should  contain ``geometryId``\ , which is used for
     identifying the geometry and is case-sensitive.
    :vartype ud_id: str
    :ivar geometry_id: The unique id identifies a geometry.
    :vartype geometry_id: str
    :ivar distance: Distance from the coordinate to the closest border of the geofence. Positive
     means the  coordinate is outside of the geofence. If the coordinate is outside of the geofence,
     but more than the value of searchBuffer away from the closest geofence border, then the value
     is 999. Negative means the coordinate is inside of the geofence. If the coordinate is inside
     the polygon, but more than the value of searchBuffer away from the closest geofencing border,
     then the value is -999. A value of 999 means that there is great confidence the coordinate is
     well outside the geofence. A value of -999 means that there is great confidence the coordinate
     is well within the geofence.
    :vartype distance: float
    :ivar nearest_lat: Latitude of the nearest point of the geometry.
    :vartype nearest_lat: float
    :ivar nearest_lon: Longitude of the nearest point of the geometry.
    :vartype nearest_lon: float
    :ivar nearest_z: Sea level in meter of the nearest point on the 2D extrusion geometry. This
     will only be presented in response when value is provided for 'zInMeter' in the request.
    :vartype nearest_z: float
    """

    _validation = {
        'device_id': {'readonly': True},
        'ud_id': {'readonly': True},
        'geometry_id': {'readonly': True},
        'distance': {'readonly': True},
        'nearest_lat': {'readonly': True},
        'nearest_lon': {'readonly': True},
        'nearest_z': {'readonly': True},
    }

    _attribute_map = {
        'device_id': {'key': 'deviceId', 'type': 'str'},
        'ud_id': {'key': 'udId', 'type': 'str'},
        'geometry_id': {'key': 'geometryId', 'type': 'str'},
        'distance': {'key': 'distance', 'type': 'float'},
        'nearest_lat': {'key': 'nearestLat', 'type': 'float'},
        'nearest_lon': {'key': 'nearestLon', 'type': 'float'},
        'nearest_z': {'key': 'nearestZ', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeofenceGeometry, self).__init__(**kwargs)
        self.device_id = None
        self.ud_id = None
        self.geometry_id = None
        self.distance = None
        self.nearest_lat = None
        self.nearest_lon = None
        self.nearest_z = None


class GeofenceResponse(msrest.serialization.Model):
    """This object is returned from a geofence proximity call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar geometries: Lists the fence geometries that contain the coordinate position or overlap
     the searchBuffer around the position.
    :vartype geometries: list[~azure.maps.service.models.GeofenceGeometry]
    :ivar expired_geofence_geometry_id: Lists of the geometry ID of the geofence which is expired
     relative to the user time in the request.
    :vartype expired_geofence_geometry_id: list[str]
    :ivar invalid_period_geofence_geometry_id: Lists of the geometry ID of the geofence which is in
     invalid period relative to the user time in the request.
    :vartype invalid_period_geofence_geometry_id: list[str]
    :ivar is_event_published: True if at least one event is published to the Azure Maps event
     subscriber, false if no event is published to the Azure Maps event subscriber. This will only
     be presented in response when 'isAsync' query parameter is set to true.
    :vartype is_event_published: bool
    """

    _validation = {
        'geometries': {'readonly': True},
        'expired_geofence_geometry_id': {'readonly': True},
        'invalid_period_geofence_geometry_id': {'readonly': True},
        'is_event_published': {'readonly': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeofenceGeometry]'},
        'expired_geofence_geometry_id': {'key': 'expiredGeofenceGeometryId', 'type': '[str]'},
        'invalid_period_geofence_geometry_id': {'key': 'invalidPeriodGeofenceGeometryId', 'type': '[str]'},
        'is_event_published': {'key': 'isEventPublished', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeofenceResponse, self).__init__(**kwargs)
        self.geometries = None
        self.expired_geofence_geometry_id = None
        self.invalid_period_geofence_geometry_id = None
        self.is_event_published = None


class GeoJSONFeatureCollection(msrest.serialization.Model):
    """A valid ``GeoJSON FeatureCollection`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``type`` for the object. Value should always be equal to
     "FeatureCollection".
    :type type: str
    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.service.models.GeoJSONFeatureCollectionFeaturesItem]
    """

    _validation = {
        'type': {'required': True},
        'features': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'features': {'key': 'features', 'type': '[GeoJSONFeatureCollectionFeaturesItem]'},
    }

    def __init__(
        self,
        *,
        type: str,
        features: List["GeoJSONFeatureCollectionFeaturesItem"],
        **kwargs
    ):
        super(GeoJSONFeatureCollection, self).__init__(**kwargs)
        self.type = type
        self.features = features


class GeoJSONFeatureCollectionFeaturesItem(msrest.serialization.Model):
    """A valid ``GeoJSON Feature`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.2>`_ for details.

    :param type: Specifies the ``type`` for the object. Value should always be equal to "Feature".
    :type type: str
    :param geometry: A valid ``GeoJSON`` geometry object. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.
    :type geometry: ~azure.maps.service.models.GeoJSONGeometry
    :param properties: Properties can contain any additional metadata about the ``Feature``. Value
     can be any JSON object or a JSON null value.
    :type properties: object
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'geometry': {'key': 'geometry', 'type': 'GeoJSONGeometry'},
        'properties': {'key': 'properties', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        geometry: Optional["GeoJSONGeometry"] = None,
        properties: Optional[object] = None,
        **kwargs
    ):
        super(GeoJSONFeatureCollectionFeaturesItem, self).__init__(**kwargs)
        self.type = type
        self.geometry = geometry
        self.properties = properties


class GeoJSONGeometry(msrest.serialization.Model):
    """A valid ``GeoJSON`` geometry object. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: LineString, MultiPoint, MultiPolygon, Point, Polygon.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'LineString': 'LineString', 'MultiPoint': 'MultiPoint', 'MultiPolygon': 'MultiPolygon', 'Point': 'Point', 'Polygon': 'Polygon'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoJSONGeometry, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class GetClosestPointResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Spatial Closest Point call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Get Closest Point Summary object.
    :vartype summary: ~azure.maps.service.models.GetClosestPointSummary
    :param result: Closest Point Result Array.
    :type result: list[~azure.maps.service.models.ClosestPointResultEntry]
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'GetClosestPointSummary'},
        'result': {'key': 'result', 'type': '[ClosestPointResultEntry]'},
    }

    def __init__(
        self,
        *,
        result: Optional[List["ClosestPointResultEntry"]] = None,
        **kwargs
    ):
        super(GetClosestPointResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class GetClosestPointSummary(msrest.serialization.Model):
    """Get Closest Point Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.service.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content.
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(GetClosestPointSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class GetPointInPolygonResponse(msrest.serialization.Model):
    """Returns true if point is within the polygon, false otherwise.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Point In Polygon Summary object.
    :vartype summary: ~azure.maps.service.models.GetPointInPolygonSummary
    :param result: Point In Polygon Result Object.
    :type result: ~azure.maps.service.models.PointInPolygonResult
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'GetPointInPolygonSummary'},
        'result': {'key': 'result', 'type': 'PointInPolygonResult'},
    }

    def __init__(
        self,
        *,
        result: Optional["PointInPolygonResult"] = None,
        **kwargs
    ):
        super(GetPointInPolygonResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class GetPointInPolygonSummary(msrest.serialization.Model):
    """Point In Polygon Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.service.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content.
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(GetPointInPolygonSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class GreatCircleDistanceResponse(msrest.serialization.Model):
    """This object is returned from a successful Great Circle Distance call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object.
    :vartype summary: ~azure.maps.service.models.GreatCircleDistanceResponseSummary
    :ivar result: Result Object.
    :vartype result: ~azure.maps.service.models.GreatCircleDistanceResponseResult
    """

    _validation = {
        'summary': {'readonly': True},
        'result': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'GreatCircleDistanceResponseSummary'},
        'result': {'key': 'result', 'type': 'GreatCircleDistanceResponseResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GreatCircleDistanceResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = None


class GreatCircleDistanceResponseResult(msrest.serialization.Model):
    """Result Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar distance_in_meters: The great circle distance in meters from the source point to the
     target point.
    :vartype distance_in_meters: float
    """

    _validation = {
        'distance_in_meters': {'readonly': True},
    }

    _attribute_map = {
        'distance_in_meters': {'key': 'distanceInMeters', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GreatCircleDistanceResponseResult, self).__init__(**kwargs)
        self.distance_in_meters = None


class GreatCircleDistanceResponseSummary(msrest.serialization.Model):
    """Summary object.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.service.models.SpatialCoordinate
    :param target_point: A location represented as a latitude and longitude.
    :type target_point: ~azure.maps.service.models.SpatialCoordinate
    """

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'target_point': {'key': 'targetPoint', 'type': 'SpatialCoordinate'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        target_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(GreatCircleDistanceResponseSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.target_point = target_point


class HazardDetail(msrest.serialization.Model):
    """HazardDetail.

    :param hazard_index: A severity/hazard index.
    
    
     * ``0`` - No hazard.
     * ``1`` - Be informed, be aware.
     * ``2`` - Pay attention, be prepared.
     * ``3`` - Take action.
     * ``4`` - Life threatening, emergency.
    :type hazard_index: int
    :param hazard_code: A unique identifier (non-displayable) for each type of hazard: LightRain,
     ModerateRain, HeavyRain, LightMix, ModerateMix, HeavyMix, LightSnow, ModerateSnow, HeavySnow,
     LightIce, ModerateIce, HeavyIce, Hail, LargeHail, SunGlare, SunGlareHigh, Lightning,
     SevereLightning, WindModerate, WindHigh, WindExtreme, FloodWarning, FlashFloodWarning,
     TornadoWarning, TsunamiWarning, SevereThunderstormWarning.
    :type hazard_code: str
    :param short_phrase: A displayable short phrase describing the forecasted conditions and
     precipitation intensity/type.
    :type short_phrase: str
    """

    _attribute_map = {
        'hazard_index': {'key': 'hazardIndex', 'type': 'int'},
        'hazard_code': {'key': 'hazardCode', 'type': 'str'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        hazard_index: Optional[int] = None,
        hazard_code: Optional[str] = None,
        short_phrase: Optional[str] = None,
        **kwargs
    ):
        super(HazardDetail, self).__init__(**kwargs)
        self.hazard_index = hazard_index
        self.hazard_code = hazard_code
        self.short_phrase = short_phrase


class Hazards(msrest.serialization.Model):
    """Hazards.

    :param max_hazard_index: A severity/hazard index.
    
    
     * ``0`` - No hazard.
     * ``1`` - Be informed, be aware.
     * ``2`` - Pay attention, be prepared.
     * ``3`` - Take action.
     * ``4`` - Life threatening, emergency.
    :type max_hazard_index: int
    :param hazard_details: Details of the weather hazards affecting the trip.
    :type hazard_details: list[~azure.maps.service.models.HazardDetail]
    """

    _attribute_map = {
        'max_hazard_index': {'key': 'maxHazardIndex', 'type': 'int'},
        'hazard_details': {'key': 'hazardDetails', 'type': '[HazardDetail]'},
    }

    def __init__(
        self,
        *,
        max_hazard_index: Optional[int] = None,
        hazard_details: Optional[List["HazardDetail"]] = None,
        **kwargs
    ):
        super(Hazards, self).__init__(**kwargs)
        self.max_hazard_index = max_hazard_index
        self.hazard_details = hazard_details


class HourlyAirQualityForecastResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Hourly Air Quality Forecast call.

    :param forecasts: A list of all hourly air quality forecasts for the queried location.
    :type forecasts: list[~azure.maps.service.models.AirQuality]
    """

    _attribute_map = {
        'forecasts': {'key': 'forecasts', 'type': '[AirQuality]'},
    }

    def __init__(
        self,
        *,
        forecasts: Optional[List["AirQuality"]] = None,
        **kwargs
    ):
        super(HourlyAirQualityForecastResponse, self).__init__(**kwargs)
        self.forecasts = forecasts


class HourlyForecast(msrest.serialization.Model):
    """HourlyForecast.

    :param date: Date and time of the forecast in ISO 8601 format, for example,
     2019-10-27T19:39:57-08:00.
    :type date: str
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param icon_phrase: Phrase description of the weather icon.
    :type icon_phrase: str
    :param has_precipitation: Indicates the presence or absence of precipitation. True indicates
     the presence of precipitation, false indicates the absence of precipitation.
    :type has_precipitation: bool
    :param is_daylight: Specifies whether or not it is daylight. True indicates day light.
    :type is_daylight: bool
    :param temperature: Temperature being returned.
    :type temperature: ~azure.maps.service.models.WeatherUnit
    :param real_feel_temperature: RealFeel™ Temperature being returned. Describes what the
     temperature really feels like in the shade.
    :type real_feel_temperature: ~azure.maps.service.models.WeatherUnit
    :param wet_bulb_temperature: The temperature to which air may be cooled by evaporating water
     into it at constant pressure until it reaches saturation.
    :type wet_bulb_temperature: ~azure.maps.service.models.WeatherUnit
    :param dew_point: The dewpoint temperature in specified unit. The dewpoint temperature is the
     temperature that the air must be cooled to in order to reach saturation.
    :type dew_point: ~azure.maps.service.models.WeatherUnit
    :param wind: Wind details being returned including speed and direction.
    :type wind: ~azure.maps.service.models.Wind
    :param wind_gust: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    :type wind_gust: ~azure.maps.service.models.Wind
    :param relative_humidity: Relative humidity is the amount of water vapor present in air
     expressed as a percentage of the amount needed for saturation at the same temperature.
    :type relative_humidity: int
    :param visibility: Visibility in specified unit. A measure of the distance at which an object
     or light can be clearly discerned.
    :type visibility: ~azure.maps.service.models.WeatherUnit
    :param ceiling: Cloud ceiling in specified unit. The ceiling is a measurement of the height of
     the base of the lowest clouds.
    :type ceiling: ~azure.maps.service.models.WeatherUnit
    :param uv_index: Measure of the strength of the ultraviolet radiation from the sun. Supported
     values are:
    
    
     * ``0-2`` - Low danger from the sun's UV rays or the average person.
     * ``3-5`` - Moderate risk of harm from unprotected sun exposure.
     * ``6-7`` - High risk of harm from unprotected sun exposure.
     * ``8-10`` - Very high risk of harm from unprotected sun exposure.
     * ``11+`` - Extreme risk of harm from unprotected sun exposure.
    :type uv_index: int
    :param uv_index_phrase: Phrase associated with the ``uvIndex``.
    :type uv_index_phrase: str
    :param precipitation_probability: Percent representing the probability of precipitation. For
     example, '20'.
    :type precipitation_probability: int
    :param rain_probability: Percent representing the probability of rain. For example, '50'.
    :type rain_probability: int
    :param snow_probability: Percent representing the probability of snow. For example, '50'.
    :type snow_probability: int
    :param ice_probability: Percent representing the probability of snow. For example, '5'.
    :type ice_probability: int
    :param total_liquid: Total liquid equivalent of precipitation during the forecast period.
    :type total_liquid: ~azure.maps.service.models.WeatherUnit
    :param rain: Rain.
    :type rain: ~azure.maps.service.models.WeatherUnit
    :param snow: Snow.
    :type snow: ~azure.maps.service.models.WeatherUnit
    :param ice: Ice.
    :type ice: ~azure.maps.service.models.WeatherUnit
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    """

    _attribute_map = {
        'date': {'key': 'date', 'type': 'str'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'icon_phrase': {'key': 'iconPhrase', 'type': 'str'},
        'has_precipitation': {'key': 'hasPrecipitation', 'type': 'bool'},
        'is_daylight': {'key': 'isDaylight', 'type': 'bool'},
        'temperature': {'key': 'temperature', 'type': 'WeatherUnit'},
        'real_feel_temperature': {'key': 'realFeelTemperature', 'type': 'WeatherUnit'},
        'wet_bulb_temperature': {'key': 'wetBulbTemperature', 'type': 'WeatherUnit'},
        'dew_point': {'key': 'dewPoint', 'type': 'WeatherUnit'},
        'wind': {'key': 'wind', 'type': 'Wind'},
        'wind_gust': {'key': 'windGust', 'type': 'Wind'},
        'relative_humidity': {'key': 'relativeHumidity', 'type': 'int'},
        'visibility': {'key': 'visibility', 'type': 'WeatherUnit'},
        'ceiling': {'key': 'ceiling', 'type': 'WeatherUnit'},
        'uv_index': {'key': 'uvIndex', 'type': 'int'},
        'uv_index_phrase': {'key': 'uvIndexPhrase', 'type': 'str'},
        'precipitation_probability': {'key': 'precipitationProbability', 'type': 'int'},
        'rain_probability': {'key': 'rainProbability', 'type': 'int'},
        'snow_probability': {'key': 'snowProbability', 'type': 'int'},
        'ice_probability': {'key': 'iceProbability', 'type': 'int'},
        'total_liquid': {'key': 'totalLiquid', 'type': 'WeatherUnit'},
        'rain': {'key': 'rain', 'type': 'WeatherUnit'},
        'snow': {'key': 'snow', 'type': 'WeatherUnit'},
        'ice': {'key': 'ice', 'type': 'WeatherUnit'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        date: Optional[str] = None,
        icon_code: Optional[int] = None,
        icon_phrase: Optional[str] = None,
        has_precipitation: Optional[bool] = None,
        is_daylight: Optional[bool] = None,
        temperature: Optional["WeatherUnit"] = None,
        real_feel_temperature: Optional["WeatherUnit"] = None,
        wet_bulb_temperature: Optional["WeatherUnit"] = None,
        dew_point: Optional["WeatherUnit"] = None,
        wind: Optional["Wind"] = None,
        wind_gust: Optional["Wind"] = None,
        relative_humidity: Optional[int] = None,
        visibility: Optional["WeatherUnit"] = None,
        ceiling: Optional["WeatherUnit"] = None,
        uv_index: Optional[int] = None,
        uv_index_phrase: Optional[str] = None,
        precipitation_probability: Optional[int] = None,
        rain_probability: Optional[int] = None,
        snow_probability: Optional[int] = None,
        ice_probability: Optional[int] = None,
        total_liquid: Optional["WeatherUnit"] = None,
        rain: Optional["WeatherUnit"] = None,
        snow: Optional["WeatherUnit"] = None,
        ice: Optional["WeatherUnit"] = None,
        cloud_cover: Optional[int] = None,
        **kwargs
    ):
        super(HourlyForecast, self).__init__(**kwargs)
        self.date = date
        self.icon_code = icon_code
        self.icon_phrase = icon_phrase
        self.has_precipitation = has_precipitation
        self.is_daylight = is_daylight
        self.temperature = temperature
        self.real_feel_temperature = real_feel_temperature
        self.wet_bulb_temperature = wet_bulb_temperature
        self.dew_point = dew_point
        self.wind = wind
        self.wind_gust = wind_gust
        self.relative_humidity = relative_humidity
        self.visibility = visibility
        self.ceiling = ceiling
        self.uv_index = uv_index
        self.uv_index_phrase = uv_index_phrase
        self.precipitation_probability = precipitation_probability
        self.rain_probability = rain_probability
        self.snow_probability = snow_probability
        self.ice_probability = ice_probability
        self.total_liquid = total_liquid
        self.rain = rain
        self.snow = snow
        self.ice = ice
        self.cloud_cover = cloud_cover


class HourlyForecastResponse(msrest.serialization.Model):
    """HourlyForecastResponse.

    :param forecasts: Forecast data for each returned hour.
    :type forecasts: list[~azure.maps.service.models.HourlyForecast]
    """

    _attribute_map = {
        'forecasts': {'key': 'forecasts', 'type': '[HourlyForecast]'},
    }

    def __init__(
        self,
        *,
        forecasts: Optional[List["HourlyForecast"]] = None,
        **kwargs
    ):
        super(HourlyForecastResponse, self).__init__(**kwargs)
        self.forecasts = forecasts


class IanaId(msrest.serialization.Model):
    """IanaId.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Id property.
    :vartype id: str
    :ivar is_alias: IsAlias property.
    :vartype is_alias: bool
    :ivar alias_of: AliasOf property.
    :vartype alias_of: str
    :ivar has_zone1970_location: HasZone1970Location property.
    :vartype has_zone1970_location: bool
    """

    _validation = {
        'id': {'readonly': True},
        'is_alias': {'readonly': True},
        'alias_of': {'readonly': True},
        'has_zone1970_location': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'is_alias': {'key': 'isAlias', 'type': 'bool'},
        'alias_of': {'key': 'aliasOf', 'type': 'str'},
        'has_zone1970_location': {'key': 'hasZone1970Location', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IanaId, self).__init__(**kwargs)
        self.id = None
        self.is_alias = None
        self.alias_of = None
        self.has_zone1970_location = None


class Interval(msrest.serialization.Model):
    """Interval.

    :param start_time: The date and time for the start of the interval in ISO 8601 format, for
     example, 2019-10-27T19:39:57-08:00.
    :type start_time: str
    :param minute: The first minute for the interval.
    :type minute: int
    :param dbz: A unit that represents forecasted precipitation intensity.
    :type dbz: float
    :param short_phrase: A short phrase describing precipitation condition for the interval.
    :type short_phrase: str
    :param threshold: Key that specifies the threshold value. Along with precipitationType, can be
     used to determine the simplifiedColor. If dbz is zero, not present in the response.
    :type threshold: str
    :param color: The full spectrum color that maps to the dBZ (decibel relative to Z). If dbz is
     zero, color is not present in the response.
    :type color: ~azure.maps.service.models.Color
    :param simplified_color: The band color that maps to the precipitation type and threshold. If
     dbz is zero, not present in the response.
    :type simplified_color: ~azure.maps.service.models.Color
    :param precipitation_type: Specifies the type of precipitation ("rain" "snow" "ice" or "mix").
     If dbz is zero, precipitationType is not present in the response.
    :type precipitation_type: str
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    """

    _attribute_map = {
        'start_time': {'key': 'startTime', 'type': 'str'},
        'minute': {'key': 'minute', 'type': 'int'},
        'dbz': {'key': 'dbz', 'type': 'float'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'str'},
        'color': {'key': 'color', 'type': 'Color'},
        'simplified_color': {'key': 'simplifiedColor', 'type': 'Color'},
        'precipitation_type': {'key': 'precipitationType', 'type': 'str'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        start_time: Optional[str] = None,
        minute: Optional[int] = None,
        dbz: Optional[float] = None,
        short_phrase: Optional[str] = None,
        threshold: Optional[str] = None,
        color: Optional["Color"] = None,
        simplified_color: Optional["Color"] = None,
        precipitation_type: Optional[str] = None,
        icon_code: Optional[int] = None,
        cloud_cover: Optional[int] = None,
        **kwargs
    ):
        super(Interval, self).__init__(**kwargs)
        self.start_time = start_time
        self.minute = minute
        self.dbz = dbz
        self.short_phrase = short_phrase
        self.threshold = threshold
        self.color = color
        self.simplified_color = simplified_color
        self.precipitation_type = precipitation_type
        self.icon_code = icon_code
        self.cloud_cover = cloud_cover


class IntervalSummary(msrest.serialization.Model):
    """IntervalSummary.

    :param start_minute: The first minute to which the summary applies.
    :type start_minute: int
    :param end_minute: The last minute to which the summary applies.
    :type end_minute: int
    :param total_minutes: The number of minutes for which the summary applies.
    :type total_minutes: int
    :param short_phrase: Short summary phrase. Phrase length is approximately 25 characters.
    :type short_phrase: str
    :param brief_phrase: Brief summary phrase. Phrase length is approximately 60 characters.
    :type brief_phrase: str
    :param long_phrase: Long summary phrase. Phrase length is 60+ characters.
    :type long_phrase: str
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    """

    _attribute_map = {
        'start_minute': {'key': 'startMinute', 'type': 'int'},
        'end_minute': {'key': 'endMinute', 'type': 'int'},
        'total_minutes': {'key': 'totalMinutes', 'type': 'int'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
        'brief_phrase': {'key': 'briefPhrase', 'type': 'str'},
        'long_phrase': {'key': 'longPhrase', 'type': 'str'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        start_minute: Optional[int] = None,
        end_minute: Optional[int] = None,
        total_minutes: Optional[int] = None,
        short_phrase: Optional[str] = None,
        brief_phrase: Optional[str] = None,
        long_phrase: Optional[str] = None,
        icon_code: Optional[int] = None,
        **kwargs
    ):
        super(IntervalSummary, self).__init__(**kwargs)
        self.start_minute = start_minute
        self.end_minute = end_minute
        self.total_minutes = total_minutes
        self.short_phrase = short_phrase
        self.brief_phrase = brief_phrase
        self.long_phrase = long_phrase
        self.icon_code = icon_code


class IpAddressToLocationResult(msrest.serialization.Model):
    """This object is returned from a successful call to IP Address to country/region API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar country_region: The object containing the country/region information.
    :vartype country_region: ~azure.maps.service.models.CountryRegion
    :ivar ip_address: The IP Address of the request.
    :vartype ip_address: str
    """

    _validation = {
        'country_region': {'readonly': True},
        'ip_address': {'readonly': True},
    }

    _attribute_map = {
        'country_region': {'key': 'countryRegion', 'type': 'CountryRegion'},
        'ip_address': {'key': 'ipAddress', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IpAddressToLocationResult, self).__init__(**kwargs)
        self.country_region = None
        self.ip_address = None


class ItineraryFare(msrest.serialization.Model):
    """Itinerary level transit fare information.

    :param price: The total price for all tickets a user is expected to purchase in order to
     complete this itinerary.
    :type price: ~azure.maps.service.models.Price
    :param tickets: An array describing the individual prices of each of the tickets that the user
     is expected to purchase throughout this itinerary. The list isn’t ordered.
    :type tickets: list[~azure.maps.service.models.Tickets]
    """

    _attribute_map = {
        'price': {'key': 'price', 'type': 'Price'},
        'tickets': {'key': 'tickets', 'type': '[Tickets]'},
    }

    def __init__(
        self,
        *,
        price: Optional["Price"] = None,
        tickets: Optional[List["Tickets"]] = None,
        **kwargs
    ):
        super(ItineraryFare, self).__init__(**kwargs)
        self.price = price
        self.tickets = tickets


class ItineraryResult(msrest.serialization.Model):
    """ItineraryResult.

    :param itinerary_id: A unique identifier of the returned itinerary.
    :type itinerary_id: str
    :param departure_time: The date and time of departure from the origin point in ISO 8601 format,
     e.g. 1996-12-19T16:39:57-08:00.
    :type departure_time: ~datetime.datetime
    :param arrival_time: The date and time of arrival at the destination point in ISO 8601 format,
     e.g. 1996-12-19T19:39:57-08:00.
    :type arrival_time: ~datetime.datetime
    :param travel_time_in_seconds: Estimated travel time in seconds.
    :type travel_time_in_seconds: int
    :param number_of_legs: Number of legs.
    :type number_of_legs: int
    :param legs: An array summarizing the legs of this itinerary.
    :type legs: list[~azure.maps.service.models.RouteItineraryLeg]
    :param itinerary_fare: Itinerary level transit fare information. Returned only if fare
     information is available for the entire itinerary. `Get Metro Area Info API
     <https://aka.ms/AzureMapsMobilityMetroAreaInfo>`_ can be requested to confirm if fare
     information is available in the metro area.
    :type itinerary_fare: ~azure.maps.service.models.ItineraryFare
    """

    _attribute_map = {
        'itinerary_id': {'key': 'itineraryId', 'type': 'str'},
        'departure_time': {'key': 'departureTime', 'type': 'iso-8601'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'iso-8601'},
        'travel_time_in_seconds': {'key': 'travelTimeInSeconds', 'type': 'int'},
        'number_of_legs': {'key': 'numberOfLegs', 'type': 'int'},
        'legs': {'key': 'legs', 'type': '[RouteItineraryLeg]'},
        'itinerary_fare': {'key': 'itineraryFare', 'type': 'ItineraryFare'},
    }

    def __init__(
        self,
        *,
        itinerary_id: Optional[str] = None,
        departure_time: Optional[datetime.datetime] = None,
        arrival_time: Optional[datetime.datetime] = None,
        travel_time_in_seconds: Optional[int] = None,
        number_of_legs: Optional[int] = None,
        legs: Optional[List["RouteItineraryLeg"]] = None,
        itinerary_fare: Optional["ItineraryFare"] = None,
        **kwargs
    ):
        super(ItineraryResult, self).__init__(**kwargs)
        self.itinerary_id = itinerary_id
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.travel_time_in_seconds = travel_time_in_seconds
        self.number_of_legs = number_of_legs
        self.legs = legs
        self.itinerary_fare = itinerary_fare


class LatestStatus(msrest.serialization.Model):
    """The latest status on the alert in the current area.

    :param localized: The latest status keyword for the alert, in the specified language. By
     default, returned in English (en-US).
    :type localized: str
    :param english: Latest status keyword for the alert, in English (en-US). Possible values
     include: "New", "Extend", "Cancel", "Correct", "Expire", "Upgrade", "Continue", "Update".
    :type english: str or ~azure.maps.service.models.LatestStatusKeyword
    """

    _attribute_map = {
        'localized': {'key': 'localized', 'type': 'str'},
        'english': {'key': 'english', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        localized: Optional[str] = None,
        english: Optional[Union[str, "LatestStatusKeyword"]] = None,
        **kwargs
    ):
        super(LatestStatus, self).__init__(**kwargs)
        self.localized = localized
        self.english = english


class Leg(msrest.serialization.Model):
    """Leg.

    :param leg_type: The travel mode of the leg. Possible values include: "Walk", "Bicycle",
     "Tram", "Subway", "Rail", "Bus", "Ferry", "Cable", "Gondola", "Funicular", "PathWayWalk",
     "Wait", "WaitOnVehicle".
    :type leg_type: str or ~azure.maps.service.models.LegType
    :param leg_start_time: Start time for the leg.
    :type leg_start_time: str
    :param leg_end_time: End time for the leg.
    :type leg_end_time: str
    :param steps: In case of walk or bike leg, the directions.
    :type steps: list[~azure.maps.service.models.Step]
    :param origin: The walk/bike leg’s origin.
    :type origin: ~azure.maps.service.models.LegPoint
    :param destination: The walk/bike leg’s destination.
    :type destination: ~azure.maps.service.models.LegPoint
    :param geometry: A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.
    :type geometry: ~azure.maps.service.models.LineString
    :param line_group: In case of a public transit leg, the line group serving this leg.
    :type line_group: ~azure.maps.service.models.LineGroup
    :param line: In case of a public transit leg, the line serving this leg.
    :type line: ~azure.maps.service.models.Line
    :param stops: List of stops comprising the line’s route within the leg (e.g. the stops the leg
     passes through).
    :type stops: list[~azure.maps.service.models.Stop]
    :param departures: Relevant for Public Transit and Wait legs only.
    :type departures: list[~azure.maps.service.models.LineArrival]
    :param leg_fare: Leg level public transit fare information. Returned only if fare information
     is available for the entire itinerary.
    :type leg_fare: ~azure.maps.service.models.LegFare
    :param wait_on_vehicle: Indicates whether it’s necessary to wait for the next leg on the same
     vehicle (i.e. the bus will only change its line number).
    :type wait_on_vehicle: str
    """

    _attribute_map = {
        'leg_type': {'key': 'legType', 'type': 'str'},
        'leg_start_time': {'key': 'legStartTime', 'type': 'str'},
        'leg_end_time': {'key': 'legEndTime', 'type': 'str'},
        'steps': {'key': 'steps', 'type': '[Step]'},
        'origin': {'key': 'origin', 'type': 'LegPoint'},
        'destination': {'key': 'destination', 'type': 'LegPoint'},
        'geometry': {'key': 'geometry', 'type': 'LineString'},
        'line_group': {'key': 'lineGroup', 'type': 'LineGroup'},
        'line': {'key': 'line', 'type': 'Line'},
        'stops': {'key': 'stops', 'type': '[Stop]'},
        'departures': {'key': 'departures', 'type': '[LineArrival]'},
        'leg_fare': {'key': 'legFare', 'type': 'LegFare'},
        'wait_on_vehicle': {'key': 'waitOnVehicle', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        leg_type: Optional[Union[str, "LegType"]] = None,
        leg_start_time: Optional[str] = None,
        leg_end_time: Optional[str] = None,
        steps: Optional[List["Step"]] = None,
        origin: Optional["LegPoint"] = None,
        destination: Optional["LegPoint"] = None,
        geometry: Optional["LineString"] = None,
        line_group: Optional["LineGroup"] = None,
        line: Optional["Line"] = None,
        stops: Optional[List["Stop"]] = None,
        departures: Optional[List["LineArrival"]] = None,
        leg_fare: Optional["LegFare"] = None,
        wait_on_vehicle: Optional[str] = None,
        **kwargs
    ):
        super(Leg, self).__init__(**kwargs)
        self.leg_type = leg_type
        self.leg_start_time = leg_start_time
        self.leg_end_time = leg_end_time
        self.steps = steps
        self.origin = origin
        self.destination = destination
        self.geometry = geometry
        self.line_group = line_group
        self.line = line
        self.stops = stops
        self.departures = departures
        self.leg_fare = leg_fare
        self.wait_on_vehicle = wait_on_vehicle


class LegFare(msrest.serialization.Model):
    """Leg level public transit fare information. Returned only if fare information is available for the entire itinerary level and supported by the local transit agency.

    :param fares:
    :type fares: list[~azure.maps.service.models.Fares]
    """

    _attribute_map = {
        'fares': {'key': 'fares', 'type': '[Fares]'},
    }

    def __init__(
        self,
        *,
        fares: Optional[List["Fares"]] = None,
        **kwargs
    ):
        super(LegFare, self).__init__(**kwargs)
        self.fares = fares


class LegPoint(msrest.serialization.Model):
    """LegPoint.

    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.Coordinate
    """

    _attribute_map = {
        'position': {'key': 'position', 'type': 'Coordinate'},
    }

    def __init__(
        self,
        *,
        position: Optional["Coordinate"] = None,
        **kwargs
    ):
        super(LegPoint, self).__init__(**kwargs)
        self.position = position


class Line(msrest.serialization.Model):
    """A stop line.

    :param line_id: Line Id.
    :type line_id: str
    :param line_group_id: Line group Id. Typically contains 2 lines having the same agency and
     line, one going from A to B, and the other from B to A.
    :type line_group_id: str
    :param direction: Line direction. Possible values 'forward' or 'backward'.
    :type direction: str
    :param agency_id: The Id of the transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: The name of the transit agency, for example, 'NJ Transit'.
    :type agency_name: str
    :param line_number: The transit line number.
    :type line_number: str
    :param origin: The line’s origin, will be present according to metro settings.
    :type origin: str
    :param line_destination: The line’s user displayable destination.
    :type line_destination: str
    :param most_frequent_pattern_id: Most common pattern for the line.
    :type most_frequent_pattern_id: str
    :param transit_type: The public transit type of the line. Possible values include: "Bus",
     "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram", "Subway".
    :type transit_type: str or ~azure.maps.service.models.TransitType
    """

    _attribute_map = {
        'line_id': {'key': 'lineId', 'type': 'str'},
        'line_group_id': {'key': 'lineGroupId', 'type': 'str'},
        'direction': {'key': 'direction', 'type': 'str'},
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'line_number': {'key': 'lineNumber', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'line_destination': {'key': 'lineDestination', 'type': 'str'},
        'most_frequent_pattern_id': {'key': 'mostFrequentPatternId', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_id: Optional[str] = None,
        line_group_id: Optional[str] = None,
        direction: Optional[str] = None,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        line_number: Optional[str] = None,
        origin: Optional[str] = None,
        line_destination: Optional[str] = None,
        most_frequent_pattern_id: Optional[str] = None,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        **kwargs
    ):
        super(Line, self).__init__(**kwargs)
        self.line_id = line_id
        self.line_group_id = line_group_id
        self.direction = direction
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.line_number = line_number
        self.origin = origin
        self.line_destination = line_destination
        self.most_frequent_pattern_id = most_frequent_pattern_id
        self.transit_type = transit_type


class LineArrival(msrest.serialization.Model):
    """LineArrival.

    :param line_id: Line Id.
    :type line_id: str
    :param stop_id: The unique Azure Maps identifier for the respective public transit stop. When
     referring to public transit stops over time, it is recommended to use ``stopId`` since it will
     not change, as long as the physical stop exists.
    :type stop_id: str
    :param schedule_time: The date and time of departure from the stop in ISO 8601 format, e.g.
     1996-12-19T19:39:57-08:00.
    :type schedule_time: ~datetime.datetime
    :param schedule_type: Whether the result is based on real-time or static data. Possible values
     include: "scheduledTime", "realTime".
    :type schedule_type: str or ~azure.maps.service.models.ScheduleType
    """

    _attribute_map = {
        'line_id': {'key': 'lineId', 'type': 'str'},
        'stop_id': {'key': 'stopId', 'type': 'str'},
        'schedule_time': {'key': 'scheduleTime', 'type': 'iso-8601'},
        'schedule_type': {'key': 'scheduleType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_id: Optional[str] = None,
        stop_id: Optional[str] = None,
        schedule_time: Optional[datetime.datetime] = None,
        schedule_type: Optional[Union[str, "ScheduleType"]] = None,
        **kwargs
    ):
        super(LineArrival, self).__init__(**kwargs)
        self.line_id = line_id
        self.stop_id = stop_id
        self.schedule_time = schedule_time
        self.schedule_type = schedule_type


class LineGroup(msrest.serialization.Model):
    """A line group.

    :param line_group_id: Line group Id. Typically contains 2 lines having the same agency and
     line, one going from A to B, and the other from B to A.
    :type line_group_id: str
    :param agency_id: The Id of the transit agency, for example, '5872'.
    :type agency_id: str
    :param agency_name: The name of the transit agency, e.g. Metro Transit.
    :type agency_name: str
    :param line_number: The transit line number.
    :type line_number: str
    :param caption1: A descriptive string. In case caption2 is null, should be used alone as a
     subtitle to the line number (i.e. Circular). In case caption2 has a value present, should be
     used in conjunction with it (i.e. Rome ↔ Napoli).
    :type caption1: str
    :param caption2: A descriptive string.
    :type caption2: str
    :param color: HEX color for the line.
    :type color: str
    :param transit_type: The public transit type of the line. Possible values include: "Bus",
     "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram", "Subway".
    :type transit_type: str or ~azure.maps.service.models.TransitType
    """

    _attribute_map = {
        'line_group_id': {'key': 'lineGroupId', 'type': 'str'},
        'agency_id': {'key': 'agencyId', 'type': 'str'},
        'agency_name': {'key': 'agencyName', 'type': 'str'},
        'line_number': {'key': 'lineNumber', 'type': 'str'},
        'caption1': {'key': 'caption1', 'type': 'str'},
        'caption2': {'key': 'caption2', 'type': 'str'},
        'color': {'key': 'color', 'type': 'str'},
        'transit_type': {'key': 'transitType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        line_group_id: Optional[str] = None,
        agency_id: Optional[str] = None,
        agency_name: Optional[str] = None,
        line_number: Optional[str] = None,
        caption1: Optional[str] = None,
        caption2: Optional[str] = None,
        color: Optional[str] = None,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        **kwargs
    ):
        super(LineGroup, self).__init__(**kwargs)
        self.line_group_id = line_group_id
        self.agency_id = agency_id
        self.agency_name = agency_name
        self.line_number = line_number
        self.caption1 = caption1
        self.caption2 = caption2
        self.color = color
        self.transit_type = transit_type


class LinesResult(msrest.serialization.Model):
    """The response from a successful Elevation Polyline request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar data: The response from the Get Data for Polyline API. The results will be listed in the
     direction from the first endpoint towards the last endpoint.
    :vartype data: list[~azure.maps.service.models.PointElevationResult]
    """

    _validation = {
        'data': {'readonly': True},
    }

    _attribute_map = {
        'data': {'key': 'data', 'type': '[PointElevationResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinesResult, self).__init__(**kwargs)
        self.data = None


class LineStringData(msrest.serialization.Model):
    """LineStringData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``LineString`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(LineStringData, self).__init__(**kwargs)
        self.coordinates = coordinates


class LineString(GeoJSONGeometry, LineStringData):
    """A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``LineString`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(LineString, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'LineString'  # type: str
        self.type = 'LineString'  # type: str


class Link(msrest.serialization.Model):
    """Links to other WFS endpoints.

    All required parameters must be populated in order to send to Azure.

    :param href: Required.
    :type href: str
    :param rel:
    :type rel: str
    :param type:
    :type type: str
    :param hreflang:
    :type hreflang: str
    :param title:
    :type title: str
    """

    _validation = {
        'href': {'required': True},
    }

    _attribute_map = {
        'href': {'key': 'href', 'type': 'str'},
        'rel': {'key': 'rel', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'hreflang': {'key': 'hreflang', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        href: str,
        rel: Optional[str] = None,
        type: Optional[str] = None,
        hreflang: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs
    ):
        super(Link, self).__init__(**kwargs)
        self.href = href
        self.rel = rel
        self.type = type
        self.hreflang = hreflang
        self.title = title


class LocalSource(msrest.serialization.Model):
    """LocalSource.

    :param id: Numeric identifier, unique to the local data provider.
    :type id: int
    :param name: Name of the local data provider. Name is displayed in the language specified by
     language code in URL, if available. Otherwise, Name is displayed in English or the language in
     which the name was provided.
    :type name: str
    :param weather_code: Weather code provided by the local data provider. This weather code allows
     the forecast to be matched to icons provided by the local data provider instead of Azure Maps
     icons.
    :type weather_code: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'weather_code': {'key': 'weatherCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        weather_code: Optional[str] = None,
        **kwargs
    ):
        super(LocalSource, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.weather_code = weather_code


class LongRunningOperationResult(msrest.serialization.Model):
    """The response model for a Long-Running Operations API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param operation_id: The Id for this long-running operation.
    :type operation_id: str
    :ivar status: The status state of the request. Possible values include: "NotStarted",
     "Running", "Failed", "Succeeded".
    :vartype status: str or ~azure.maps.service.models.Type
    :ivar created: The created timestamp.
    :vartype created: str
    :ivar resource_location: The location URI for details about the created resource. This is only
     provided when the request was successfully completed.
    :vartype resource_location: str
    :param error: The error detail.
    :type error: ~azure.maps.service.models.ErrorDetail
    :param warning: The error detail.
    :type warning: ~azure.maps.service.models.ErrorDetail
    """

    _validation = {
        'status': {'readonly': True},
        'created': {'readonly': True},
        'resource_location': {'readonly': True},
    }

    _attribute_map = {
        'operation_id': {'key': 'operationId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created': {'key': 'created', 'type': 'str'},
        'resource_location': {'key': 'resourceLocation', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorDetail'},
        'warning': {'key': 'warning', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        operation_id: Optional[str] = None,
        error: Optional["ErrorDetail"] = None,
        warning: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(LongRunningOperationResult, self).__init__(**kwargs)
        self.operation_id = operation_id
        self.status = None
        self.created = None
        self.resource_location = None
        self.error = error
        self.warning = warning


class MapDataDetailInfo(msrest.serialization.Model):
    """Detail information for the data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: The unique data id for the data.
    :vartype udid: str
    :ivar location: The location of the data. Execute a HTTP ``GET`` on this location to download
     the data.
    :vartype location: str
    :ivar size_in_bytes: The size of the content in bytes.
    :vartype size_in_bytes: long
    :ivar upload_status: The current upload status of the content.
    :vartype upload_status: str
    """

    _validation = {
        'udid': {'readonly': True},
        'location': {'readonly': True},
        'size_in_bytes': {'readonly': True},
        'upload_status': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'size_in_bytes': {'key': 'sizeInBytes', 'type': 'long'},
        'upload_status': {'key': 'uploadStatus', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MapDataDetailInfo, self).__init__(**kwargs)
        self.udid = None
        self.location = None
        self.size_in_bytes = None
        self.upload_status = None


class MapDataListResponse(msrest.serialization.Model):
    """The response model for the Data List API. Returns a list of all the previously uploaded data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar map_data_list: A list of all the previously uploaded data.
    :vartype map_data_list: list[~azure.maps.service.models.MapDataDetailInfo]
    """

    _validation = {
        'map_data_list': {'readonly': True},
    }

    _attribute_map = {
        'map_data_list': {'key': 'mapDataList', 'type': '[MapDataDetailInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MapDataListResponse, self).__init__(**kwargs)
        self.map_data_list = None


class MetroAreaInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Metro Area Info call.

    :param metro_name: The name of the metro area.
    :type metro_name: str
    :param is_fares_supported: Indicates if public transit fares information is available in the
     metro area. Fare information is available through `Get Transit Route API
     <https://aka.ms/AzureMapsMobilityTransitRoute>`_ and `Get Transit Itinerary APIs
     <https://aka.ms/AzureMapsMobilityTransitItinerary>`_.
    :type is_fares_supported: str
    :param transit_types: Supported transit types in the metro area. Returned if specified in the
     request.
    :type transit_types: list[~azure.maps.service.models.TransitTypeResult]
    :param agencies:
    :type agencies: list[~azure.maps.service.models.Agency]
    :param alerts:
    :type alerts: list[~azure.maps.service.models.Alert]
    """

    _attribute_map = {
        'metro_name': {'key': 'metroName', 'type': 'str'},
        'is_fares_supported': {'key': 'isFaresSupported', 'type': 'str'},
        'transit_types': {'key': 'transitTypes', 'type': '[TransitTypeResult]'},
        'agencies': {'key': 'agencies', 'type': '[Agency]'},
        'alerts': {'key': 'alerts', 'type': '[Alert]'},
    }

    def __init__(
        self,
        *,
        metro_name: Optional[str] = None,
        is_fares_supported: Optional[str] = None,
        transit_types: Optional[List["TransitTypeResult"]] = None,
        agencies: Optional[List["Agency"]] = None,
        alerts: Optional[List["Alert"]] = None,
        **kwargs
    ):
        super(MetroAreaInfoResponse, self).__init__(**kwargs)
        self.metro_name = metro_name
        self.is_fares_supported = is_fares_supported
        self.transit_types = transit_types
        self.agencies = agencies
        self.alerts = alerts


class MetroAreaResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Metro Area call.

    :param results:
    :type results: list[~azure.maps.service.models.MetroAreaResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[MetroAreaResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["MetroAreaResult"]] = None,
        **kwargs
    ):
        super(MetroAreaResponse, self).__init__(**kwargs)
        self.results = results


class MetroAreaResult(msrest.serialization.Model):
    """Details of the metro area.

    :param metro_id: The metro area's Id for use with other API calls.
    :type metro_id: int
    :param metro_name: The main display name of the metro.
    :type metro_name: str
    :param geometry: A valid ``GeoJSON Polygon`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.6>`_ for details.
    :type geometry: ~azure.maps.service.models.Polygon
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.ResultViewport
    """

    _attribute_map = {
        'metro_id': {'key': 'metroId', 'type': 'int'},
        'metro_name': {'key': 'metroName', 'type': 'str'},
        'geometry': {'key': 'geometry', 'type': 'Polygon'},
        'viewport': {'key': 'viewport', 'type': 'ResultViewport'},
    }

    def __init__(
        self,
        *,
        metro_id: Optional[int] = None,
        metro_name: Optional[str] = None,
        geometry: Optional["Polygon"] = None,
        viewport: Optional["ResultViewport"] = None,
        **kwargs
    ):
        super(MetroAreaResult, self).__init__(**kwargs)
        self.metro_id = metro_id
        self.metro_name = metro_name
        self.geometry = geometry
        self.viewport = viewport


class MinuteForecastResponse(msrest.serialization.Model):
    """MinuteForecastResponse.

    :param summary: Phrase summaries for the entire forecast period.
    :type summary: ~azure.maps.service.models.MinuteForecastSummary
    :param interval_summaries: Summary information for each interval in the forecast. The Summaries
     breaks down each potential interval where precipitation starts and stops.
    :type interval_summaries: list[~azure.maps.service.models.IntervalSummary]
    :param intervals: Forecast data for each interval in the forecast.
    :type intervals: list[~azure.maps.service.models.Interval]
    """

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'MinuteForecastSummary'},
        'interval_summaries': {'key': 'intervalSummaries', 'type': '[IntervalSummary]'},
        'intervals': {'key': 'intervals', 'type': '[Interval]'},
    }

    def __init__(
        self,
        *,
        summary: Optional["MinuteForecastSummary"] = None,
        interval_summaries: Optional[List["IntervalSummary"]] = None,
        intervals: Optional[List["Interval"]] = None,
        **kwargs
    ):
        super(MinuteForecastResponse, self).__init__(**kwargs)
        self.summary = summary
        self.interval_summaries = interval_summaries
        self.intervals = intervals


class MinuteForecastSummary(msrest.serialization.Model):
    """Phrase summaries for the entire forecast period.

    :param brief_phrase60: Summary phrase for the next 60 minutes. Phrase length is approximately
     60 characters.
    :type brief_phrase60: str
    :param short_phrase: Short summary phrase for the next 120 minutes. Phrase length is
     approximately 25 characters.
    :type short_phrase: str
    :param brief_phrase: Summary phrase for the next 120 minutes. Phrase length is approximately 60
     characters.
    :type brief_phrase: str
    :param long_phrase: Long summary phrase for the next 120 minutes. Phrase length is 60+
     characters.
    :type long_phrase: str
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    """

    _attribute_map = {
        'brief_phrase60': {'key': 'briefPhrase60', 'type': 'str'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
        'brief_phrase': {'key': 'briefPhrase', 'type': 'str'},
        'long_phrase': {'key': 'longPhrase', 'type': 'str'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        brief_phrase60: Optional[str] = None,
        short_phrase: Optional[str] = None,
        brief_phrase: Optional[str] = None,
        long_phrase: Optional[str] = None,
        icon_code: Optional[int] = None,
        **kwargs
    ):
        super(MinuteForecastSummary, self).__init__(**kwargs)
        self.brief_phrase60 = brief_phrase60
        self.short_phrase = short_phrase
        self.brief_phrase = brief_phrase
        self.long_phrase = long_phrase
        self.icon_code = icon_code


class MultiPointData(msrest.serialization.Model):
    """Data contained by a ``MultiPoint``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(MultiPointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class MultiPoint(GeoJSONGeometry, MultiPointData):
    """A valid ``GeoJSON MultiPoint`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.3>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(MultiPoint, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPoint'  # type: str
        self.type = 'MultiPoint'  # type: str


class MultiPolygonData(msrest.serialization.Model):
    """MultiPolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON`` Polygon objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(MultiPolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class MultiPolygon(GeoJSONGeometry, MultiPolygonData):
    """A valid ``GeoJSON MultiPolygon`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.7>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON`` Polygon objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(MultiPolygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPolygon'  # type: str
        self.type = 'MultiPolygon'  # type: str


class Names(msrest.serialization.Model):
    """Timezone names object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar iso6391_language_code: The ISO 639-1 language code of the Names.
    :vartype iso6391_language_code: str
    :ivar generic: Generic Name.
    :vartype generic: str
    :ivar standard: Standard Name.
    :vartype standard: str
    :ivar daylight: Daylight Name.
    :vartype daylight: str
    """

    _validation = {
        'iso6391_language_code': {'readonly': True},
        'generic': {'readonly': True},
        'standard': {'readonly': True},
        'daylight': {'readonly': True},
    }

    _attribute_map = {
        'iso6391_language_code': {'key': 'ISO6391LanguageCode', 'type': 'str'},
        'generic': {'key': 'Generic', 'type': 'str'},
        'standard': {'key': 'Standard', 'type': 'str'},
        'daylight': {'key': 'Daylight', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Names, self).__init__(**kwargs)
        self.iso6391_language_code = None
        self.generic = None
        self.standard = None
        self.daylight = None


class NearbyTransitResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Nearby Transit call.

    :param results:
    :type results: list[~azure.maps.service.models.TransitObjectResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[TransitObjectResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["TransitObjectResult"]] = None,
        **kwargs
    ):
        super(NearbyTransitResponse, self).__init__(**kwargs)
        self.results = results


class Notification(msrest.serialization.Model):
    """Notification.

    :param type: A type of notification generated to warn drivers of the onset of a hazard, or
     increase in intensity of a hazard.
    :type type: str
    :param hazard_index: A severity/hazard index.
    
    
     * ``0`` - No hazard.
     * ``1`` - Be informed, be aware.
     * ``2`` - Pay attention, be prepared.
     * ``3`` - Take action.
     * ``4`` - Life threatening, emergency.
    :type hazard_index: int
    :param hazard_code: A unique identifier (non-displayable) for each type of hazard: LightRain,
     ModerateRain, HeavyRain, LightMix, ModerateMix, HeavyMix, LightSnow, ModerateSnow, HeavySnow,
     LightIce, ModerateIce, HeavyIce, Hail, LargeHail, SunGlare, SunGlareHigh, Lightning,
     SevereLightning, WindModerate, WindHigh, WindExtreme, FloodWarning, FlashFloodWarning,
     TornadoWarning, TsunamiWarning, SevereThunderstormWarning.
    :type hazard_code: str
    :param short_phrase: A displayable short phrase describing the forecasted conditions and
     precipitation intensity/type.
    :type short_phrase: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'hazard_index': {'key': 'hazardIndex', 'type': 'int'},
        'hazard_code': {'key': 'hazardCode', 'type': 'str'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        hazard_index: Optional[int] = None,
        hazard_code: Optional[str] = None,
        short_phrase: Optional[str] = None,
        **kwargs
    ):
        super(Notification, self).__init__(**kwargs)
        self.type = type
        self.hazard_index = hazard_index
        self.hazard_code = hazard_code
        self.short_phrase = short_phrase


class NumberRuleObject(msrest.serialization.Model):
    """The numeric rule.

    :param range: The numeric value range for this style rule, If the value is in the range, all
     the conditions must hold true.
    :type range: ~azure.maps.service.models.RangeObject
    :param color: Color is a JSON string in a variety of permitted formats, HTML-style hex values,
     RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%,
     50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue,
     are also permitted.
    :type color: str
    """

    _attribute_map = {
        'range': {'key': 'range', 'type': 'RangeObject'},
        'color': {'key': 'color', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        range: Optional["RangeObject"] = None,
        color: Optional[str] = None,
        **kwargs
    ):
        super(NumberRuleObject, self).__init__(**kwargs)
        self.range = range
        self.color = color


class NumberTypeStyleRule(StyleRuleBase):
    """The numeric type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "number", "boolean", "string".
    :type type: str or ~azure.maps.service.models.StyleRuleBaseType
    :param rules: Numeric style rules.
    :type rules: list[~azure.maps.service.models.NumberRuleObject]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[NumberRuleObject]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: Optional[List["NumberRuleObject"]] = None,
        **kwargs
    ):
        super(NumberTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'NumberTypeStyleRule'  # type: str
        self.rules = rules


class Pattern(msrest.serialization.Model):
    """Stop-shape-segments of the trip pattern, which are an ordered list of the stops and the shapes connecting them.

    :param pattern_id: Pattern Id, for example, '3267995'.
    :type pattern_id: str
    :param line_id: Line Id.
    :type line_id: str
    :param stop_ids: Stops the line goes through.
    :type stop_ids: list[str]
    :param geometry: Stop sequence and shape per a line in GeoJSON format.
    :type geometry: ~azure.maps.service.models.LineString
    """

    _attribute_map = {
        'pattern_id': {'key': 'patternId', 'type': 'str'},
        'line_id': {'key': 'lineId', 'type': 'str'},
        'stop_ids': {'key': 'stopIds', 'type': '[str]'},
        'geometry': {'key': 'geometry', 'type': 'LineString'},
    }

    def __init__(
        self,
        *,
        pattern_id: Optional[str] = None,
        line_id: Optional[str] = None,
        stop_ids: Optional[List[str]] = None,
        geometry: Optional["LineString"] = None,
        **kwargs
    ):
        super(Pattern, self).__init__(**kwargs)
        self.pattern_id = pattern_id
        self.line_id = line_id
        self.stop_ids = stop_ids
        self.geometry = geometry


class PoiCategoryResponse(msrest.serialization.Model):
    """This object is returned from a successful POI Category Tree call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar poi_categories: Categories array.
    :vartype poi_categories: list[~azure.maps.service.models.PoiCategoryResult]
    """

    _validation = {
        'poi_categories': {'readonly': True},
    }

    _attribute_map = {
        'poi_categories': {'key': 'poiCategories', 'type': '[PoiCategoryResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PoiCategoryResponse, self).__init__(**kwargs)
        self.poi_categories = None


class PoiCategoryResult(msrest.serialization.Model):
    """POI category result.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Unique ID for the category. ID can be used to restrict search results to specific
     categories through other Search Service APIs, like `Get Search POI
     <https://docs.microsoft.com/rest/api/maps/search/getsearchpoi>`_.
    :vartype id: int
    :ivar name: Name of the category.
    :vartype name: str
    :ivar child_category_ids: Array of child category ids.
    :vartype child_category_ids: list[int]
    :ivar synonyms: Array of alternative names of the category.
    :vartype synonyms: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'child_category_ids': {'readonly': True},
        'synonyms': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'child_category_ids': {'key': 'childCategoryIds', 'type': '[int]'},
        'synonyms': {'key': 'synonyms', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PoiCategoryResult, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.child_category_ids = None
        self.synonyms = None


class PointData(msrest.serialization.Model):
    """Data contained by a ``Point``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A valid ``GeoJSON Position`` geometry type. A ``Position`` is an
     array of numbers with two or more elements. The first two elements are *longitude* and
     *latitude*\ , precisely in that order. *Altitude/Elevation* is an optional third element.
     Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(PointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class Point(GeoJSONGeometry, PointData):
    """A valid ``GeoJSON Point`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.2>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A valid ``GeoJSON Position`` geometry type. A ``Position`` is an
     array of numbers with two or more elements. The first two elements are *longitude* and
     *latitude*\ , precisely in that order. *Altitude/Elevation* is an optional third element.
     Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(Point, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Point'  # type: str
        self.type = 'Point'  # type: str


class PointArray(msrest.serialization.Model):
    """PointArray.

    All required parameters must be populated in order to send to Azure.

    :param type: Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid GeoJSON
     geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and
     GeometryCollection.
    :type type: str
    :param geometries: Required.
    :type geometries: list[~azure.maps.service.models.Point]
    """

    _validation = {
        'geometries': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'geometries': {'key': 'geometries', 'type': '[Point]'},
    }

    def __init__(
        self,
        *,
        geometries: List["Point"],
        type: Optional[str] = None,
        **kwargs
    ):
        super(PointArray, self).__init__(**kwargs)
        self.type = type
        self.geometries = geometries


class PointElevationResult(msrest.serialization.Model):
    """The elevation data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param coordinate: A location represented as a latitude and longitude.
    :type coordinate: ~azure.maps.service.models.Coordinate
    :ivar elevation_in_meter: The elevation value in meters.
    :vartype elevation_in_meter: float
    """

    _validation = {
        'elevation_in_meter': {'readonly': True},
    }

    _attribute_map = {
        'coordinate': {'key': 'coordinate', 'type': 'Coordinate'},
        'elevation_in_meter': {'key': 'elevationInMeter', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        coordinate: Optional["Coordinate"] = None,
        **kwargs
    ):
        super(PointElevationResult, self).__init__(**kwargs)
        self.coordinate = coordinate
        self.elevation_in_meter = None


class PointInPolygonResult(msrest.serialization.Model):
    """Point In Polygon Result Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar point_in_polygons: Point In Polygons Property.
    :vartype point_in_polygons: bool
    :ivar intersecting_geometries: Geometries array.
    :vartype intersecting_geometries: list[str]
    """

    _validation = {
        'point_in_polygons': {'readonly': True},
        'intersecting_geometries': {'readonly': True},
    }

    _attribute_map = {
        'point_in_polygons': {'key': 'pointInPolygons', 'type': 'bool'},
        'intersecting_geometries': {'key': 'intersectingGeometries', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PointInPolygonResult, self).__init__(**kwargs)
        self.point_in_polygons = None
        self.intersecting_geometries = None


class PointsResult(msrest.serialization.Model):
    """The response from a successful Elevation Points request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar data: The response for point/points elevation API. The result will be in same sequence of
     points listed in request.
    :vartype data: list[~azure.maps.service.models.PointElevationResult]
    """

    _validation = {
        'data': {'readonly': True},
    }

    _attribute_map = {
        'data': {'key': 'data', 'type': '[PointElevationResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PointsResult, self).__init__(**kwargs)
        self.data = None


class Pollutant(msrest.serialization.Model):
    """Detailed information about an individual pollutant. Not returned if ``pollutants``\ =false.

    :param type: Type of pollutant. Please note that more may be added at any time. Possible values
     include: "CO", "NO2", "O3", "PM2.5", "PM10", "SO2".
    :type type: str or ~azure.maps.service.models.PollutantType
    :param name: The name of the pollutant in English.
    :type name: str
    :param index: Air quality rating on a scale set by local regulating bodies. Scales can vary
     widely based on location. See `Wikipedia <https://en.wikipedia.org/wiki/Air_quality_index>`_
     for more information.
    :type index: float
    :param global_index: Internationally normalized air quality rating on a scale from 0 to 300 and
     up, with higher numbers representing worse air quality.
    :type global_index: float
    :param concentration: An object containing the number of pollutant particles per volume of air.
    :type concentration: ~azure.maps.service.models.Concentration
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'index': {'key': 'index', 'type': 'float'},
        'global_index': {'key': 'globalIndex', 'type': 'float'},
        'concentration': {'key': 'concentration', 'type': 'Concentration'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "PollutantType"]] = None,
        name: Optional[str] = None,
        index: Optional[float] = None,
        global_index: Optional[float] = None,
        concentration: Optional["Concentration"] = None,
        **kwargs
    ):
        super(Pollutant, self).__init__(**kwargs)
        self.type = type
        self.name = name
        self.index = index
        self.global_index = global_index
        self.concentration = concentration


class PolygonData(msrest.serialization.Model):
    """PolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(PolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class Polygon(GeoJSONGeometry, PolygonData):
    """A valid ``GeoJSON Polygon`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.6>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    :param type: Required. Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid
     GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon
     and GeometryCollection.Constant filled by server.  Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type type: str or ~azure.maps.service.models.GeoJSONGeometryType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(Polygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Polygon'  # type: str
        self.type = 'Polygon'  # type: str


class PostClosestPointResponse(msrest.serialization.Model):
    """This object is returned from a successful Post Spatial Closest Point call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Post Closest Point Summary object.
    :vartype summary: ~azure.maps.service.models.PostClosestPointSummary
    :param result: Closest Point Result Array.
    :type result: list[~azure.maps.service.models.ClosestPointResultEntry]
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'PostClosestPointSummary'},
        'result': {'key': 'result', 'type': '[ClosestPointResultEntry]'},
    }

    def __init__(
        self,
        *,
        result: Optional[List["ClosestPointResultEntry"]] = None,
        **kwargs
    ):
        super(PostClosestPointResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class PostClosestPointSummary(msrest.serialization.Model):
    """Post Closest Point Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.service.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content. Udid is not applicable for POST
     spatial operations(set to null).
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(PostClosestPointSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class PostPointInPolygonResponse(msrest.serialization.Model):
    """Returns true if point is within the polygon, false otherwise.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Point In Polygon Summary object.
    :vartype summary: ~azure.maps.service.models.PostPointInPolygonSummary
    :param result: Point In Polygon Result Object.
    :type result: ~azure.maps.service.models.PointInPolygonResult
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'PostPointInPolygonSummary'},
        'result': {'key': 'result', 'type': 'PointInPolygonResult'},
    }

    def __init__(
        self,
        *,
        result: Optional["PointInPolygonResult"] = None,
        **kwargs
    ):
        super(PostPointInPolygonResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class PostPointInPolygonSummary(msrest.serialization.Model):
    """Point In Polygon Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.service.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content. Udid is not applicable for POST
     spatial operations(set to null).
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(PostPointInPolygonSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class PrecipitationSummary(msrest.serialization.Model):
    """PrecipitationSummary.

    :param past_hour: The amount of precipitation (liquid equivalent) that has fallen in the past
     hour.
    :type past_hour: ~azure.maps.service.models.WeatherUnit
    :param past3_hours: The amount of precipitation (liquid equivalent) that has fallen in the past
     three hours.
    :type past3_hours: ~azure.maps.service.models.WeatherUnit
    :param past6_hours: The amount of precipitation (liquid equivalent) that has fallen in the past
     six hours. Contains Metric and Imperial Values.
    :type past6_hours: ~azure.maps.service.models.WeatherUnit
    :param past9_hours: The amount of precipitation (liquid equivalent) that has fallen in the past
     nine hours.
    :type past9_hours: ~azure.maps.service.models.WeatherUnit
    :param past12_hours: The amount of precipitation (liquid equivalent) that has fallen in the
     past 12 hours.
    :type past12_hours: ~azure.maps.service.models.WeatherUnit
    :param past18_hours: The amount of precipitation (liquid equivalent) that has fallen in the
     past 18 hours.
    :type past18_hours: ~azure.maps.service.models.WeatherUnit
    :param past24_hours: The amount of precipitation (liquid equivalent) that has fallen in the
     past 24 hours.
    :type past24_hours: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'past_hour': {'key': 'pastHour', 'type': 'WeatherUnit'},
        'past3_hours': {'key': 'past3Hours', 'type': 'WeatherUnit'},
        'past6_hours': {'key': 'past6Hours', 'type': 'WeatherUnit'},
        'past9_hours': {'key': 'past9Hours', 'type': 'WeatherUnit'},
        'past12_hours': {'key': 'past12Hours', 'type': 'WeatherUnit'},
        'past18_hours': {'key': 'past18Hours', 'type': 'WeatherUnit'},
        'past24_hours': {'key': 'past24Hours', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        past_hour: Optional["WeatherUnit"] = None,
        past3_hours: Optional["WeatherUnit"] = None,
        past6_hours: Optional["WeatherUnit"] = None,
        past9_hours: Optional["WeatherUnit"] = None,
        past12_hours: Optional["WeatherUnit"] = None,
        past18_hours: Optional["WeatherUnit"] = None,
        past24_hours: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(PrecipitationSummary, self).__init__(**kwargs)
        self.past_hour = past_hour
        self.past3_hours = past3_hours
        self.past6_hours = past6_hours
        self.past9_hours = past9_hours
        self.past12_hours = past12_hours
        self.past18_hours = past18_hours
        self.past24_hours = past24_hours


class PressureTendency(msrest.serialization.Model):
    """PressureTendency.

    :param localized_description: Description of the pressure tendency in specified language.
    :type localized_description: str
    :param code: Pressure tendency code regardless of language. One of F=Falling, S=Steady,
     R=Rising.
    :type code: str
    """

    _attribute_map = {
        'localized_description': {'key': 'localizedDescription', 'type': 'str'},
        'code': {'key': 'code', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        localized_description: Optional[str] = None,
        code: Optional[str] = None,
        **kwargs
    ):
        super(PressureTendency, self).__init__(**kwargs)
        self.localized_description = localized_description
        self.code = code


class Price(msrest.serialization.Model):
    """Price.

    :param amount: Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
    :type amount: int
    :param currency_code: Currency code, for example for US dollars “USD”.
    :type currency_code: str
    """

    _attribute_map = {
        'amount': {'key': 'amount', 'type': 'int'},
        'currency_code': {'key': 'currencyCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        amount: Optional[int] = None,
        currency_code: Optional[str] = None,
        **kwargs
    ):
        super(Price, self).__init__(**kwargs)
        self.amount = amount
        self.currency_code = currency_code


class QuarterDayForecast(msrest.serialization.Model):
    """QuarterDayForecast.

    :param date: Date and time of the forecast in ISO 8601 format, for example,
     2019-10-27T19:39:57-08:00.
    :type date: str
    :param effective_date: Date and time of the beginning of the forecast quarter displayed in ISO
     8601 format, for example, 2019-10-27T19:39:57-08:00.
    :type effective_date: str
    :param quarter: Quarter of the day. Possible values include: 0, 1, 2, 3.
    :type quarter: str or ~azure.maps.service.models.Quarter
    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param icon_phrase: Phrase description of the icon. Displayed in specified language. For
     example, 'Sunny'.
    :type icon_phrase: str
    :param phrase: Short summary phrase summary for quarter.
    :type phrase: str
    :param temperature: Temperature values for the quarter.
    :type temperature: ~azure.maps.service.models.WeatherUnitRange
    :param real_feel_temperature: RealFeel™ Temperature values for the quarter.
    :type real_feel_temperature: ~azure.maps.service.models.WeatherUnitRange
    :param dew_point: The dewpoint temperature in specified unit. The dewpoint temperature is the
     temperature that the air must be cooled to in order to reach saturation.
    :type dew_point: ~azure.maps.service.models.WeatherUnit
    :param relative_humidity: Relative humidity is the amount of water vapor present in air
     expressed as a percentage of the amount needed for saturation at the same temperature.
    :type relative_humidity: int
    :param wind: Wind details being returned including speed and direction.
    :type wind: ~azure.maps.service.models.Wind
    :param wind_gust: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    :type wind_gust: ~azure.maps.service.models.Wind
    :param visibility: Visibility in specified unit. A measure of the distance at which an object
     or light can be clearly discerned.
    :type visibility: ~azure.maps.service.models.WeatherUnit
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    :param has_precipitation: Indicates the presence or absence of precipitation. True indicates
     the presence of precipitation, false indicates the absence of precipitation.
    :type has_precipitation: bool
    :param precipitation_type: Specifies the type of precipitation ("rain" "snow" "ice" or "mix").
     If dbz = zero, precipitationType is not present in the response.
    :type precipitation_type: str
    :param precipitation_intensity: Description of the intensity.
    :type precipitation_intensity: str
    :param precipitation_probability: Percent representing the probability of precipitation. For
     example, '20'.
    :type precipitation_probability: int
    :param thunderstorm_probability: Percent representing the probability of a thunderstorm. For
     example, '10'.
    :type thunderstorm_probability: int
    :param total_liquid: Total liquid equivalent of precipitation during the forecast period.
    :type total_liquid: ~azure.maps.service.models.WeatherUnit
    :param rain: Rain.
    :type rain: ~azure.maps.service.models.WeatherUnit
    :param snow: Snow.
    :type snow: ~azure.maps.service.models.WeatherUnit
    :param ice: Ice.
    :type ice: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'date': {'key': 'date', 'type': 'str'},
        'effective_date': {'key': 'effectiveDate', 'type': 'str'},
        'quarter': {'key': 'quarter', 'type': 'int'},
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'icon_phrase': {'key': 'iconPhrase', 'type': 'str'},
        'phrase': {'key': 'phrase', 'type': 'str'},
        'temperature': {'key': 'temperature', 'type': 'WeatherUnitRange'},
        'real_feel_temperature': {'key': 'realFeelTemperature', 'type': 'WeatherUnitRange'},
        'dew_point': {'key': 'dewPoint', 'type': 'WeatherUnit'},
        'relative_humidity': {'key': 'relativeHumidity', 'type': 'int'},
        'wind': {'key': 'wind', 'type': 'Wind'},
        'wind_gust': {'key': 'windGust', 'type': 'Wind'},
        'visibility': {'key': 'visibility', 'type': 'WeatherUnit'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
        'has_precipitation': {'key': 'hasPrecipitation', 'type': 'bool'},
        'precipitation_type': {'key': 'precipitationType', 'type': 'str'},
        'precipitation_intensity': {'key': 'precipitationIntensity', 'type': 'str'},
        'precipitation_probability': {'key': 'precipitationProbability', 'type': 'int'},
        'thunderstorm_probability': {'key': 'thunderstormProbability', 'type': 'int'},
        'total_liquid': {'key': 'totalLiquid', 'type': 'WeatherUnit'},
        'rain': {'key': 'rain', 'type': 'WeatherUnit'},
        'snow': {'key': 'snow', 'type': 'WeatherUnit'},
        'ice': {'key': 'ice', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        date: Optional[str] = None,
        effective_date: Optional[str] = None,
        quarter: Optional[Union[int, "Quarter"]] = None,
        icon_code: Optional[int] = None,
        icon_phrase: Optional[str] = None,
        phrase: Optional[str] = None,
        temperature: Optional["WeatherUnitRange"] = None,
        real_feel_temperature: Optional["WeatherUnitRange"] = None,
        dew_point: Optional["WeatherUnit"] = None,
        relative_humidity: Optional[int] = None,
        wind: Optional["Wind"] = None,
        wind_gust: Optional["Wind"] = None,
        visibility: Optional["WeatherUnit"] = None,
        cloud_cover: Optional[int] = None,
        has_precipitation: Optional[bool] = None,
        precipitation_type: Optional[str] = None,
        precipitation_intensity: Optional[str] = None,
        precipitation_probability: Optional[int] = None,
        thunderstorm_probability: Optional[int] = None,
        total_liquid: Optional["WeatherUnit"] = None,
        rain: Optional["WeatherUnit"] = None,
        snow: Optional["WeatherUnit"] = None,
        ice: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(QuarterDayForecast, self).__init__(**kwargs)
        self.date = date
        self.effective_date = effective_date
        self.quarter = quarter
        self.icon_code = icon_code
        self.icon_phrase = icon_phrase
        self.phrase = phrase
        self.temperature = temperature
        self.real_feel_temperature = real_feel_temperature
        self.dew_point = dew_point
        self.relative_humidity = relative_humidity
        self.wind = wind
        self.wind_gust = wind_gust
        self.visibility = visibility
        self.cloud_cover = cloud_cover
        self.has_precipitation = has_precipitation
        self.precipitation_type = precipitation_type
        self.precipitation_intensity = precipitation_intensity
        self.precipitation_probability = precipitation_probability
        self.thunderstorm_probability = thunderstorm_probability
        self.total_liquid = total_liquid
        self.rain = rain
        self.snow = snow
        self.ice = ice


class QuarterDayForecastResponse(msrest.serialization.Model):
    """QuarterDayForecastResponse.

    :param forecasts: Forecast data for each quarter in the response.
    :type forecasts: list[~azure.maps.service.models.QuarterDayForecast]
    """

    _attribute_map = {
        'forecasts': {'key': 'forecasts', 'type': '[QuarterDayForecast]'},
    }

    def __init__(
        self,
        *,
        forecasts: Optional[List["QuarterDayForecast"]] = None,
        **kwargs
    ):
        super(QuarterDayForecastResponse, self).__init__(**kwargs)
        self.forecasts = forecasts


class RangeObject(msrest.serialization.Model):
    """The numeric value range for this style rule, If the value is in the range, all the conditions must hold true.

    :param minimum: All the number x that x ≥ minimum.
    :type minimum: float
    :param maximum: All the number x that x ≤ maximum.
    :type maximum: float
    :param exclusive_minimum: All the number x that x > exclusiveMinimum.
    :type exclusive_minimum: float
    :param exclusive_maximum: All the number x that x < exclusiveMaximum.
    :type exclusive_maximum: float
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'float'},
        'maximum': {'key': 'maximum', 'type': 'float'},
        'exclusive_minimum': {'key': 'exclusiveMinimum', 'type': 'float'},
        'exclusive_maximum': {'key': 'exclusiveMaximum', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        minimum: Optional[float] = None,
        maximum: Optional[float] = None,
        exclusive_minimum: Optional[float] = None,
        exclusive_maximum: Optional[float] = None,
        **kwargs
    ):
        super(RangeObject, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.exclusive_minimum = exclusive_minimum
        self.exclusive_maximum = exclusive_maximum


class RealTimeArrivalResult(msrest.serialization.Model):
    """Contains real-time arrival related details.

    :param arrival_minutes: The estimated time of arrival in minutes.
    :type arrival_minutes: int
    :param schedule_type: Whether the result is based on real-time or static data. Possible values
     include: "scheduledTime", "realTime".
    :type schedule_type: str or ~azure.maps.service.models.ScheduleType
    :param pattern_id: The pattern Id.
    :type pattern_id: str
    :param line: The public transit type of the line.
    :type line: ~azure.maps.service.models.Line
    :param stop: Object for the given stop.
    :type stop: ~azure.maps.service.models.Stop
    """

    _attribute_map = {
        'arrival_minutes': {'key': 'arrivalMinutes', 'type': 'int'},
        'schedule_type': {'key': 'scheduleType', 'type': 'str'},
        'pattern_id': {'key': 'patternId', 'type': 'str'},
        'line': {'key': 'line', 'type': 'Line'},
        'stop': {'key': 'stop', 'type': 'Stop'},
    }

    def __init__(
        self,
        *,
        arrival_minutes: Optional[int] = None,
        schedule_type: Optional[Union[str, "ScheduleType"]] = None,
        pattern_id: Optional[str] = None,
        line: Optional["Line"] = None,
        stop: Optional["Stop"] = None,
        **kwargs
    ):
        super(RealTimeArrivalResult, self).__init__(**kwargs)
        self.arrival_minutes = arrival_minutes
        self.schedule_type = schedule_type
        self.pattern_id = pattern_id
        self.line = line
        self.stop = stop


class RealTimeArrivalsResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Real Time Arrival Info call.

    :param results: Results array. Contains results related details.
    :type results: list[~azure.maps.service.models.RealTimeArrivalResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[RealTimeArrivalResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["RealTimeArrivalResult"]] = None,
        **kwargs
    ):
        super(RealTimeArrivalsResponse, self).__init__(**kwargs)
        self.results = results


class ReferenceTimeByCoordinates(msrest.serialization.Model):
    """Details in effect at the local time.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tag: Time zone name in effect at the reference timestamp (i.e. PST or PDT depending
     whether Daylight Savings Time is in effect).
    :vartype tag: str
    :ivar standard_offset: UTC offset in effect at the ``ReferenceUTCTimestamp``.
    :vartype standard_offset: str
    :ivar daylight_savings: Time saving in minutes in effect at the ``ReferenceUTCTimestamp``.
    :vartype daylight_savings: str
    :ivar wall_time: Current wall time at the given time zone as shown in the ``Tag`` property.
    :vartype wall_time: str
    :ivar posix_tz_valid_year: The year this POSIX string is valid for. Note: A POSIX string will
     only be valid in the given year.
    :vartype posix_tz_valid_year: int
    :ivar posix_tz: POSIX string used to set the time zone environment variable.
    :vartype posix_tz: str
    :ivar sunrise: Sunrise at the given time zone as shown in the ``Tag`` property.
    :vartype sunrise: str
    :ivar sunset: Sunset at the given time zone as shown in the ``Tag`` property.
    :vartype sunset: str
    """

    _validation = {
        'tag': {'readonly': True},
        'standard_offset': {'readonly': True},
        'daylight_savings': {'readonly': True},
        'wall_time': {'readonly': True},
        'posix_tz_valid_year': {'readonly': True},
        'posix_tz': {'readonly': True},
        'sunrise': {'readonly': True},
        'sunset': {'readonly': True},
    }

    _attribute_map = {
        'tag': {'key': 'Tag', 'type': 'str'},
        'standard_offset': {'key': 'StandardOffset', 'type': 'str'},
        'daylight_savings': {'key': 'DaylightSavings', 'type': 'str'},
        'wall_time': {'key': 'WallTime', 'type': 'str'},
        'posix_tz_valid_year': {'key': 'PosixTzValidYear', 'type': 'int'},
        'posix_tz': {'key': 'PosixTz', 'type': 'str'},
        'sunrise': {'key': 'Sunrise', 'type': 'str'},
        'sunset': {'key': 'Sunset', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ReferenceTimeByCoordinates, self).__init__(**kwargs)
        self.tag = None
        self.standard_offset = None
        self.daylight_savings = None
        self.wall_time = None
        self.posix_tz_valid_year = None
        self.posix_tz = None
        self.sunrise = None
        self.sunset = None


class ReferenceTimeById(msrest.serialization.Model):
    """Details in effect at the local time.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tag: Time zone name in effect at the reference timestamp (i.e. PST or PDT depending
     whether Daylight Savings Time is in effect).
    :vartype tag: str
    :ivar standard_offset: UTC offset in effect at the ``ReferenceUTCTimestamp``.
    :vartype standard_offset: str
    :ivar daylight_savings: Time saving in minutes in effect at the ``ReferenceUTCTimestamp``.
    :vartype daylight_savings: str
    :ivar wall_time: Current wall time at the given time zone as shown in the ``Tag`` property.
    :vartype wall_time: str
    :ivar posix_tz_valid_year: The year this POSIX string is valid for. Note: A POSIX string will
     only be valid in the given year.
    :vartype posix_tz_valid_year: int
    :ivar posix_tz: POSIX string used to set the time zone environment variable.
    :vartype posix_tz: str
    """

    _validation = {
        'tag': {'readonly': True},
        'standard_offset': {'readonly': True},
        'daylight_savings': {'readonly': True},
        'wall_time': {'readonly': True},
        'posix_tz_valid_year': {'readonly': True},
        'posix_tz': {'readonly': True},
    }

    _attribute_map = {
        'tag': {'key': 'Tag', 'type': 'str'},
        'standard_offset': {'key': 'StandardOffset', 'type': 'str'},
        'daylight_savings': {'key': 'DaylightSavings', 'type': 'str'},
        'wall_time': {'key': 'WallTime', 'type': 'str'},
        'posix_tz_valid_year': {'key': 'PosixTzValidYear', 'type': 'int'},
        'posix_tz': {'key': 'PosixTz', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ReferenceTimeById, self).__init__(**kwargs)
        self.tag = None
        self.standard_offset = None
        self.daylight_savings = None
        self.wall_time = None
        self.posix_tz_valid_year = None
        self.posix_tz = None


class Region(msrest.serialization.Model):
    """Region.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar copyrights: Copyrights array.
    :vartype copyrights: list[str]
    :ivar country: Country property.
    :vartype country: ~azure.maps.service.models.RegionCountry
    """

    _validation = {
        'copyrights': {'readonly': True},
        'country': {'readonly': True},
    }

    _attribute_map = {
        'copyrights': {'key': 'copyrights', 'type': '[str]'},
        'country': {'key': 'country', 'type': 'RegionCountry'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Region, self).__init__(**kwargs)
        self.copyrights = None
        self.country = None


class RegionCountry(msrest.serialization.Model):
    """Country property.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar iso3: ISO3 property.
    :vartype iso3: str
    :ivar label: Label property.
    :vartype label: str
    """

    _validation = {
        'iso3': {'readonly': True},
        'label': {'readonly': True},
    }

    _attribute_map = {
        'iso3': {'key': 'ISO3', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RegionCountry, self).__init__(**kwargs)
        self.iso3 = None
        self.label = None


class RepresentativePoint(msrest.serialization.Model):
    """Representative point property.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar latitude: Latitude property.
    :vartype latitude: float
    :ivar longitude: Longitude property.
    :vartype longitude: float
    """

    _validation = {
        'latitude': {'readonly': True},
        'longitude': {'readonly': True},
    }

    _attribute_map = {
        'latitude': {'key': 'Latitude', 'type': 'float'},
        'longitude': {'key': 'Longitude', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RepresentativePoint, self).__init__(**kwargs)
        self.latitude = None
        self.longitude = None


class ReqClasses(msrest.serialization.Model):
    """ReqClasses.

    All required parameters must be populated in order to send to Azure.

    :param conforms_to: Required.
    :type conforms_to: list[str]
    """

    _validation = {
        'conforms_to': {'required': True},
    }

    _attribute_map = {
        'conforms_to': {'key': 'conformsTo', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        conforms_to: List[str],
        **kwargs
    ):
        super(ReqClasses, self).__init__(**kwargs)
        self.conforms_to = conforms_to


class ResultViewport(msrest.serialization.Model):
    """The viewport that covers the result represented by the top-left and bottom-right coordinates of the  viewport.

    :param top_left_point: A location represented as a latitude and longitude.
    :type top_left_point: ~azure.maps.service.models.Coordinate
    :param btm_right_point: A location represented as a latitude and longitude.
    :type btm_right_point: ~azure.maps.service.models.Coordinate
    """

    _attribute_map = {
        'top_left_point': {'key': 'topLeftPoint', 'type': 'Coordinate'},
        'btm_right_point': {'key': 'btmRightPoint', 'type': 'Coordinate'},
    }

    def __init__(
        self,
        *,
        top_left_point: Optional["Coordinate"] = None,
        btm_right_point: Optional["Coordinate"] = None,
        **kwargs
    ):
        super(ResultViewport, self).__init__(**kwargs)
        self.top_left_point = top_left_point
        self.btm_right_point = btm_right_point


class Root(msrest.serialization.Model):
    """Root.

    All required parameters must be populated in order to send to Azure.

    :param links: Required.
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'links': {'required': True},
    }

    _attribute_map = {
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        links: List["Link"],
        **kwargs
    ):
        super(Root, self).__init__(**kwargs)
        self.links = links


class RouteDirectionsRequestBody(msrest.serialization.Model):
    """Post body parameters for Route directions.

    :param supporting_points: A GeoJSON Geometry collection representing sequence of coordinates
     used as input for route reconstruction and for calculating zero or more alternative routes to
     this reference route.
    
    
     * The provided sequence of supporting points is used as input for route reconstruction.
     * The alternative routes are calculated between the origin and destination points specified in
     the base path parameter locations.
     * If both *minDeviationDistance* and *minDeviationTime* are set to zero, then these origin and
     destination points are
       expected to be at (or very near) the beginning and end of the reference route, respectively.
     * Intermediate locations (\ *waypoints*\ ) are not supported when using
     :code:`<_supportingPoints_>`.
     * The reference route may contain traffic incidents of type _ROAD\ *CLOSURE*\ , which are
       ignored for the calculation of the reference route's travel time and traffic delay.
    :type supporting_points: ~azure.maps.service.models.RouteDirectionsRequestBodySupportingPoints
    :param avoid_vignette: This is a list of 3-character, ISO 3166-1, alpha-3 country codes of
     countries in which all toll roads with vignettes are to be avoided, e.g. "AUS,CHE". Toll roads
     with vignettes in countries not in the list are unaffected. Note: It is an error to specify
     both **avoidVignette** and **allowVignette**.
    :type avoid_vignette: list[str]
    :param allow_vignette: This is a list of 3-character, ISO 3166-1, alpha-3 country codes of
     countries in which toll roads with vignettes are allowed, e.g. "AUS,CHE". Specifying
     **allowVignette** with some countries X is equivalent to specifying **avoidVignette** with all
     countries but X. Specifying **allowVignette** with an empty list is the same as avoiding all
     toll roads with vignettes. Note: It is an error to specify both **avoidVignette** and
     **allowVignette**.
    :type allow_vignette: list[str]
    :param avoid_areas: A GeoJSON MultiPolygon representing list of areas to avoid. Only rectangle
     polygons are supported. The maximum size of a rectangle is about 160x160 km. Maximum number of
     avoided areas is **10**. It cannot cross the 180th meridian. It must be between -80 and +80
     degrees of latitude.
    :type avoid_areas: ~azure.maps.service.models.MultiPolygon
    """

    _attribute_map = {
        'supporting_points': {'key': 'supportingPoints', 'type': 'RouteDirectionsRequestBodySupportingPoints'},
        'avoid_vignette': {'key': 'avoidVignette', 'type': '[str]'},
        'allow_vignette': {'key': 'allowVignette', 'type': '[str]'},
        'avoid_areas': {'key': 'avoidAreas', 'type': 'MultiPolygon'},
    }

    def __init__(
        self,
        *,
        supporting_points: Optional["RouteDirectionsRequestBodySupportingPoints"] = None,
        avoid_vignette: Optional[List[str]] = None,
        allow_vignette: Optional[List[str]] = None,
        avoid_areas: Optional["MultiPolygon"] = None,
        **kwargs
    ):
        super(RouteDirectionsRequestBody, self).__init__(**kwargs)
        self.supporting_points = supporting_points
        self.avoid_vignette = avoid_vignette
        self.allow_vignette = allow_vignette
        self.avoid_areas = avoid_areas


class RouteDirectionsRequestBodySupportingPoints(PointArray):
    """A GeoJSON Geometry collection representing sequence of coordinates used as input for route reconstruction and for calculating zero or more alternative routes to this reference route.


* The provided sequence of supporting points is used as input for route reconstruction.
* The alternative routes are calculated between the origin and destination points specified in the base path parameter locations.
* If both *minDeviationDistance* and *minDeviationTime* are set to zero, then these origin and destination points are
  expected to be at (or very near) the beginning and end of the reference route, respectively.
* Intermediate locations (\ *waypoints*\ ) are not supported when using :code:`<_supportingPoints_>`.
* The reference route may contain traffic incidents of type _ROAD\ *CLOSURE*\ , which are
  ignored for the calculation of the reference route's travel time and traffic delay.

    All required parameters must be populated in order to send to Azure.

    :param type: Specifies the ``GeoJSON`` geometry type. Must be one of the seven valid GeoJSON
     geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and
     GeometryCollection.
    :type type: str
    :param geometries: Required.
    :type geometries: list[~azure.maps.service.models.Point]
    """

    _validation = {
        'geometries': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'geometries': {'key': 'geometries', 'type': '[Point]'},
    }

    def __init__(
        self,
        *,
        geometries: List["Point"],
        type: Optional[str] = None,
        **kwargs
    ):
        super(RouteDirectionsRequestBodySupportingPoints, self).__init__(type=type, geometries=geometries, **kwargs)


class RouteDirectionsResponse(msrest.serialization.Model):
    """This object is returned from a successful Route Directions call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar routes: Routes array.
    :vartype routes: list[~azure.maps.service.models.RouteDirectionsResult]
    :ivar optimized_waypoints: Optimized sequence of waypoints. It shows the index from the user
     provided waypoint sequence for the original and optimized list. For instance, a response:
    
     .. code-block::
    
        <optimizedWaypoints>
        <waypoint providedIndex="0" optimizedIndex="1"/>
        <waypoint providedIndex="1" optimizedIndex="2"/>
        <waypoint providedIndex="2" optimizedIndex="0"/>
        </optimizedWaypoints>
    
     means that the original sequence is [0, 1, 2] and optimized sequence is [1, 2, 0]. Since the
     index starts by 0 the original is "first, second, third" while the optimized is "second, third,
     first".
    :vartype optimized_waypoints: list[~azure.maps.service.models.RouteOptimizedWaypoint]
    :param report: Reports the effective settings used in the current call.
    :type report: ~azure.maps.service.models.RouteResponseReport
    """

    _validation = {
        'format_version': {'readonly': True},
        'routes': {'readonly': True},
        'optimized_waypoints': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'routes': {'key': 'routes', 'type': '[RouteDirectionsResult]'},
        'optimized_waypoints': {'key': 'optimizedWaypoints', 'type': '[RouteOptimizedWaypoint]'},
        'report': {'key': 'report', 'type': 'RouteResponseReport'},
    }

    def __init__(
        self,
        *,
        report: Optional["RouteResponseReport"] = None,
        **kwargs
    ):
        super(RouteDirectionsResponse, self).__init__(**kwargs)
        self.format_version = None
        self.routes = None
        self.optimized_waypoints = None
        self.report = report


class RouteDirectionsResult(msrest.serialization.Model):
    """RouteDirectionsResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object.
    :vartype summary: ~azure.maps.service.models.RouteDirectionsSummary
    :ivar legs: Legs array.
    :vartype legs: list[~azure.maps.service.models.RouteResultLeg]
    :ivar sections: Sections array.
    :vartype sections: list[~azure.maps.service.models.RouteResultSection]
    :ivar guidance: Contains guidance related elements. This field is present only when guidance
     was requested and is available.
    :vartype guidance: ~azure.maps.service.models.RouteResultGuidance
    """

    _validation = {
        'summary': {'readonly': True},
        'legs': {'readonly': True},
        'sections': {'readonly': True},
        'guidance': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'RouteDirectionsSummary'},
        'legs': {'key': 'legs', 'type': '[RouteResultLeg]'},
        'sections': {'key': 'sections', 'type': '[RouteResultSection]'},
        'guidance': {'key': 'guidance', 'type': 'RouteResultGuidance'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteDirectionsResult, self).__init__(**kwargs)
        self.summary = None
        self.legs = None
        self.sections = None
        self.guidance = None


class RouteDirectionsSummary(msrest.serialization.Model):
    """Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar length_in_meters: Length In Meters property.
    :vartype length_in_meters: int
    :ivar travel_time_in_seconds: Estimated travel time in seconds property that includes the delay
     due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes
     the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-
     dependent historic traffic data.
    :vartype travel_time_in_seconds: int
    :ivar traffic_delay_in_seconds: Estimated delay in seconds caused by the real-time incident(s)
     according to traffic information. For routes planned with departure time in the future, delays
     is always 0. To return additional travel times using different types of traffic information,
     parameter computeTravelTimeFor=all needs to be added.
    :vartype traffic_delay_in_seconds: int
    :ivar departure_time: Departure Time property.
    :vartype departure_time: str
    :ivar arrival_time: Arrival Time property.
    :vartype arrival_time: str
    """

    _validation = {
        'length_in_meters': {'readonly': True},
        'travel_time_in_seconds': {'readonly': True},
        'traffic_delay_in_seconds': {'readonly': True},
        'departure_time': {'readonly': True},
        'arrival_time': {'readonly': True},
    }

    _attribute_map = {
        'length_in_meters': {'key': 'lengthInMeters', 'type': 'int'},
        'travel_time_in_seconds': {'key': 'travelTimeInSeconds', 'type': 'int'},
        'traffic_delay_in_seconds': {'key': 'trafficDelayInSeconds', 'type': 'int'},
        'departure_time': {'key': 'departureTime', 'type': 'str'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteDirectionsSummary, self).__init__(**kwargs)
        self.length_in_meters = None
        self.travel_time_in_seconds = None
        self.traffic_delay_in_seconds = None
        self.departure_time = None
        self.arrival_time = None


class RouteItineraryLeg(msrest.serialization.Model):
    """RouteItineraryLeg.

    :param leg_type: The travel mode of the leg. Possible values include: "Walk", "Bicycle",
     "Tram", "Subway", "Rail", "Bus", "Ferry", "Cable", "Gondola", "Funicular", "PathWayWalk",
     "Wait", "WaitOnVehicle".
    :type leg_type: str or ~azure.maps.service.models.LegType
    :param leg_fare: Leg level public transit fare information. Returned only if fare information
     is available for the entire itinerary.
    :type leg_fare: ~azure.maps.service.models.LegFare
    :param leg_start_time: Start time for the leg in ISO 8601 format, e.g.
     1996-12-19T19:39:57-08:00.
    :type leg_start_time: str
    :param leg_end_time: End time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00.
    :type leg_end_time: str
    :param caption: For Public Transit legs the caption of the line serving the leg, for example,
     line number.
    :type caption: str
    :param length_in_meters: The total distance of the leg in meters.
    :type length_in_meters: int
    """

    _attribute_map = {
        'leg_type': {'key': 'legType', 'type': 'str'},
        'leg_fare': {'key': 'legFare', 'type': 'LegFare'},
        'leg_start_time': {'key': 'legStartTime', 'type': 'str'},
        'leg_end_time': {'key': 'legEndTime', 'type': 'str'},
        'caption': {'key': 'caption', 'type': 'str'},
        'length_in_meters': {'key': 'lengthInMeters', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        leg_type: Optional[Union[str, "LegType"]] = None,
        leg_fare: Optional["LegFare"] = None,
        leg_start_time: Optional[str] = None,
        leg_end_time: Optional[str] = None,
        caption: Optional[str] = None,
        length_in_meters: Optional[int] = None,
        **kwargs
    ):
        super(RouteItineraryLeg, self).__init__(**kwargs)
        self.leg_type = leg_type
        self.leg_fare = leg_fare
        self.leg_start_time = leg_start_time
        self.leg_end_time = leg_end_time
        self.caption = caption
        self.length_in_meters = length_in_meters


class RouteMatrixRequestBody(msrest.serialization.Model):
    """An object with a matrix of coordinates.

    :param origins: A valid ``GeoJSON MultiPoint`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.3>`_ for details.
    :type origins: ~azure.maps.service.models.MultiPoint
    :param destinations: A valid ``GeoJSON MultiPoint`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.3>`_ for details.
    :type destinations: ~azure.maps.service.models.MultiPoint
    """

    _attribute_map = {
        'origins': {'key': 'origins', 'type': 'MultiPoint'},
        'destinations': {'key': 'destinations', 'type': 'MultiPoint'},
    }

    def __init__(
        self,
        *,
        origins: Optional["MultiPoint"] = None,
        destinations: Optional["MultiPoint"] = None,
        **kwargs
    ):
        super(RouteMatrixRequestBody, self).__init__(**kwargs)
        self.origins = origins
        self.destinations = destinations


class RouteMatrixResponse(msrest.serialization.Model):
    """This object is returned from a successful Route Matrix call. For ex, if 2 origins and 3 destinations are provided, there are going to 2 arrays with 3 elements in each. Each element's content depends on the options provided in the query.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :ivar matrix: Results as a 2 dimensional array of route summaries.
    :vartype matrix: list[list[~azure.maps.service.models.RouteMatrixResult]]
    :ivar summary: Summary object.
    :vartype summary: ~azure.maps.service.models.RouteMatrixSummary
    """

    _validation = {
        'format_version': {'readonly': True},
        'matrix': {'readonly': True},
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'matrix': {'key': 'matrix', 'type': '[[RouteMatrixResult]]'},
        'summary': {'key': 'summary', 'type': 'RouteMatrixSummary'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteMatrixResponse, self).__init__(**kwargs)
        self.format_version = None
        self.matrix = None
        self.summary = None


class RouteMatrixResult(msrest.serialization.Model):
    """Matrix result object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar status_code: StatusCode property for the current cell in the input matrix.
    :vartype status_code: int
    :ivar response: Response object of the current cell in the input matrix.
    :vartype response: ~azure.maps.service.models.RouteMatrixResultResponse
    """

    _validation = {
        'status_code': {'readonly': True},
        'response': {'readonly': True},
    }

    _attribute_map = {
        'status_code': {'key': 'statusCode', 'type': 'int'},
        'response': {'key': 'response', 'type': 'RouteMatrixResultResponse'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteMatrixResult, self).__init__(**kwargs)
        self.status_code = None
        self.response = None


class RouteMatrixResultResponse(msrest.serialization.Model):
    """Response object of the current cell in the input matrix.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar route_summary: Summary object for route section.
    :vartype route_summary: ~azure.maps.service.models.RouteResultLegSummary
    """

    _validation = {
        'route_summary': {'readonly': True},
    }

    _attribute_map = {
        'route_summary': {'key': 'routeSummary', 'type': 'RouteResultLegSummary'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteMatrixResultResponse, self).__init__(**kwargs)
        self.route_summary = None


class RouteMatrixSummary(msrest.serialization.Model):
    """Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar successful_routes: Number of successful routes in the response.
    :vartype successful_routes: int
    :ivar total_routes: Total number of routes requested. Number of cells in the input matrix.
    :vartype total_routes: int
    """

    _validation = {
        'successful_routes': {'readonly': True},
        'total_routes': {'readonly': True},
    }

    _attribute_map = {
        'successful_routes': {'key': 'successfulRoutes', 'type': 'int'},
        'total_routes': {'key': 'totalRoutes', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteMatrixSummary, self).__init__(**kwargs)
        self.successful_routes = None
        self.total_routes = None


class RouteOptimizedWaypoint(msrest.serialization.Model):
    """Optimized way point object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar provided_index: Way point index provided by the user.
    :vartype provided_index: int
    :ivar optimized_index: Optimized way point index from the system.
    :vartype optimized_index: int
    """

    _validation = {
        'provided_index': {'readonly': True},
        'optimized_index': {'readonly': True},
    }

    _attribute_map = {
        'provided_index': {'key': 'providedIndex', 'type': 'int'},
        'optimized_index': {'key': 'optimizedIndex', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteOptimizedWaypoint, self).__init__(**kwargs)
        self.provided_index = None
        self.optimized_index = None


class RouteRange(msrest.serialization.Model):
    """Reachable Range.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param center: Center point of the reachable range.
    :type center: ~azure.maps.service.models.Coordinate
    :ivar boundary: Polygon boundary of the reachable range represented as a list of points.
    :vartype boundary: list[~azure.maps.service.models.Coordinate]
    """

    _validation = {
        'boundary': {'readonly': True},
    }

    _attribute_map = {
        'center': {'key': 'center', 'type': 'Coordinate'},
        'boundary': {'key': 'boundary', 'type': '[Coordinate]'},
    }

    def __init__(
        self,
        *,
        center: Optional["Coordinate"] = None,
        **kwargs
    ):
        super(RouteRange, self).__init__(**kwargs)
        self.center = center
        self.boundary = None


class RouteRangeResponse(msrest.serialization.Model):
    """This object is returned from a successful Route Reachable Range call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar format_version: Format Version property.
    :vartype format_version: str
    :param reachable_range: Reachable Range.
    :type reachable_range: ~azure.maps.service.models.RouteRange
    :param report: Reports the effective settings used in the current call.
    :type report: ~azure.maps.service.models.RouteResponseReport
    """

    _validation = {
        'format_version': {'readonly': True},
    }

    _attribute_map = {
        'format_version': {'key': 'formatVersion', 'type': 'str'},
        'reachable_range': {'key': 'reachableRange', 'type': 'RouteRange'},
        'report': {'key': 'report', 'type': 'RouteResponseReport'},
    }

    def __init__(
        self,
        *,
        reachable_range: Optional["RouteRange"] = None,
        report: Optional["RouteResponseReport"] = None,
        **kwargs
    ):
        super(RouteRangeResponse, self).__init__(**kwargs)
        self.format_version = None
        self.reachable_range = reachable_range
        self.report = report


class RouteResponseReport(msrest.serialization.Model):
    """Reports the effective settings used in the current call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar effective_settings: Effective parameters or data used when calling this Route API.
    :vartype effective_settings:
     list[~azure.maps.service.models.RouteResponseReportEffectiveSetting]
    """

    _validation = {
        'effective_settings': {'readonly': True},
    }

    _attribute_map = {
        'effective_settings': {'key': 'effectiveSettings', 'type': '[RouteResponseReportEffectiveSetting]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResponseReport, self).__init__(**kwargs)
        self.effective_settings = None


class RouteResponseReportEffectiveSetting(msrest.serialization.Model):
    """Effective parameter or data used when calling this Route API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar key: Name of the parameter used.
    :vartype key: str
    :ivar value: Value of the parameter used.
    :vartype value: str
    """

    _validation = {
        'key': {'readonly': True},
        'value': {'readonly': True},
    }

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResponseReportEffectiveSetting, self).__init__(**kwargs)
        self.key = None
        self.value = None


class RouteResultGuidance(msrest.serialization.Model):
    """Contains guidance related elements. This field is present only when guidance was requested and is available.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar instructions: A list of instructions describing maneuvers.
    :vartype instructions: list[~azure.maps.service.models.RouteResultInstruction]
    :ivar instruction_groups: Groups a sequence of instruction elements which are related to each
     other.
    :vartype instruction_groups: list[~azure.maps.service.models.RouteResultInstructionGroup]
    """

    _validation = {
        'instructions': {'readonly': True},
        'instruction_groups': {'readonly': True},
    }

    _attribute_map = {
        'instructions': {'key': 'instructions', 'type': '[RouteResultInstruction]'},
        'instruction_groups': {'key': 'instructionGroups', 'type': '[RouteResultInstructionGroup]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResultGuidance, self).__init__(**kwargs)
        self.instructions = None
        self.instruction_groups = None


class RouteResultInstruction(msrest.serialization.Model):
    """A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway', 'Arrive'.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar route_offset_in_meters: Distance from the start of the route to the point of the
     instruction.
    :vartype route_offset_in_meters: int
    :ivar travel_time_in_seconds: Estimated travel time up to the point corresponding to
     routeOffsetInMeters.
    :vartype travel_time_in_seconds: int
    :param point: A location represented as a latitude and longitude.
    :type point: ~azure.maps.service.models.Coordinate
    :ivar point_index: The index of the point in the list of polyline "points" corresponding to the
     point of the instruction.
    :vartype point_index: int
    :param instruction_type: Type of the instruction, e.g., turn or change of road form. Possible
     values include: "TURN", "ROAD_CHANGE", "LOCATION_DEPARTURE", "LOCATION_ARRIVAL",
     "DIRECTION_INFO", "LOCATION_WAYPOINT".
    :type instruction_type: str or ~azure.maps.service.models.GuidanceInstructionType
    :ivar road_numbers: The road number(s) of the next significant road segment(s) after the
     maneuver, or of the road(s) to be followed. Example: ["E34", "N205"].
    :vartype road_numbers: list[str]
    :ivar exit_number: The number(s) of a highway exit taken by the current maneuver. If an exit
     has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g.,
     "10, 13-15".
    :vartype exit_number: str
    :ivar street: Street name of the next significant road segment after the maneuver, or of the
     street that should be followed.
    :vartype street: str
    :ivar signpost_text: The text on a signpost which is most relevant to the maneuver, or to the
     direction that should be followed.
    :vartype signpost_text: str
    :ivar country_code: 3-character `ISO 3166-1 <https://www.iso.org/iso-3166-country-codes.html>`_
     alpha-3 country code. E.g. USA.
    :vartype country_code: str
    :ivar state_code: A subdivision (e.g., state) of the country, represented by the second part of
     an `ISO 3166-2 <https://www.iso.org/standard/63546.html>`_ code. This is only available for
     some countries like the US, Canada, and Mexico.
    :vartype state_code: str
    :ivar junction_type: The type of the junction where the maneuver takes place. For larger
     roundabouts, two separate instructions are generated for entering and leaving the roundabout.
     Possible values include: "REGULAR", "ROUNDABOUT", "BIFURCATION".
    :vartype junction_type: str or ~azure.maps.service.models.JunctionType
    :ivar turn_angle_in_decimal_degrees: Indicates the direction of an instruction. If junctionType
     indicates a turn instruction:
    
    
     * 180 = U-turn
     * [-179, -1] = Left turn
     * 0 = Straight on (a '0 degree' turn)
     * [1, 179] = Right turn
    
     If junctionType indicates a bifurcation instruction:
    
    
     * <0 - keep left
     * &gt;0 - keep right.
    :vartype turn_angle_in_decimal_degrees: int
    :ivar roundabout_exit_number: This indicates which exit to take at a roundabout.
    :vartype roundabout_exit_number: str
    :ivar possible_combine_with_next: It is possible to optionally combine the instruction with the
     next one. This can be used to build messages like "Turn left and then turn right".
    :vartype possible_combine_with_next: bool
    :ivar driving_side: Indicates left-hand vs. right-hand side driving at the point of the
     maneuver. Possible values include: "LEFT", "RIGHT".
    :vartype driving_side: str or ~azure.maps.service.models.DrivingSide
    :ivar maneuver: A code identifying the maneuver. Possible values include: "ARRIVE",
     "ARRIVE_LEFT", "ARRIVE_RIGHT", "DEPART", "STRAIGHT", "KEEP_RIGHT", "BEAR_RIGHT", "TURN_RIGHT",
     "SHARP_RIGHT", "KEEP_LEFT", "BEAR_LEFT", "TURN_LEFT", "SHARP_LEFT", "MAKE_UTURN",
     "ENTER_MOTORWAY", "ENTER_FREEWAY", "ENTER_HIGHWAY", "TAKE_EXIT", "MOTORWAY_EXIT_LEFT",
     "MOTORWAY_EXIT_RIGHT", "TAKE_FERRY", "ROUNDABOUT_CROSS", "ROUNDABOUT_RIGHT", "ROUNDABOUT_LEFT",
     "ROUNDABOUT_BACK", "TRY_MAKE_UTURN", "FOLLOW", "SWITCH_PARALLEL_ROAD", "SWITCH_MAIN_ROAD",
     "ENTRANCE_RAMP", "WAYPOINT_LEFT", "WAYPOINT_RIGHT", "WAYPOINT_REACHED".
    :vartype maneuver: str or ~azure.maps.service.models.GuidanceManeuver
    :ivar message: A human-readable message for the maneuver.
    :vartype message: str
    :ivar combined_message: A human-readable message for the maneuver combined with the message
     from the next instruction. Sometimes it is possible to combine two successive instructions into
     a single instruction making it easier to follow. When this is the case the
     possibleCombineWithNext flag will be true. For example:
    
     .. code-block::
    
        10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
        11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
    
     The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of
     coded guidance that it can be combined with instruction 11. The instructions will be combined
     automatically for clients requesting human-readable guidance. The combinedMessage field
     contains the combined message:
    
     .. code-block::
    
        Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
        then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
    :vartype combined_message: str
    """

    _validation = {
        'route_offset_in_meters': {'readonly': True},
        'travel_time_in_seconds': {'readonly': True},
        'point_index': {'readonly': True},
        'road_numbers': {'readonly': True},
        'exit_number': {'readonly': True},
        'street': {'readonly': True},
        'signpost_text': {'readonly': True},
        'country_code': {'readonly': True},
        'state_code': {'readonly': True},
        'junction_type': {'readonly': True},
        'turn_angle_in_decimal_degrees': {'readonly': True},
        'roundabout_exit_number': {'readonly': True},
        'possible_combine_with_next': {'readonly': True},
        'driving_side': {'readonly': True},
        'maneuver': {'readonly': True},
        'message': {'readonly': True},
        'combined_message': {'readonly': True},
    }

    _attribute_map = {
        'route_offset_in_meters': {'key': 'routeOffsetInMeters', 'type': 'int'},
        'travel_time_in_seconds': {'key': 'travelTimeInSeconds', 'type': 'int'},
        'point': {'key': 'point', 'type': 'Coordinate'},
        'point_index': {'key': 'pointIndex', 'type': 'int'},
        'instruction_type': {'key': 'instructionType', 'type': 'str'},
        'road_numbers': {'key': 'roadNumbers', 'type': '[str]'},
        'exit_number': {'key': 'exitNumber', 'type': 'str'},
        'street': {'key': 'street', 'type': 'str'},
        'signpost_text': {'key': 'signpostText', 'type': 'str'},
        'country_code': {'key': 'countryCode', 'type': 'str'},
        'state_code': {'key': 'stateCode', 'type': 'str'},
        'junction_type': {'key': 'junctionType', 'type': 'str'},
        'turn_angle_in_decimal_degrees': {'key': 'turnAngleInDecimalDegrees', 'type': 'int'},
        'roundabout_exit_number': {'key': 'roundaboutExitNumber', 'type': 'str'},
        'possible_combine_with_next': {'key': 'possibleCombineWithNext', 'type': 'bool'},
        'driving_side': {'key': 'drivingSide', 'type': 'str'},
        'maneuver': {'key': 'maneuver', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'combined_message': {'key': 'combinedMessage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        point: Optional["Coordinate"] = None,
        instruction_type: Optional[Union[str, "GuidanceInstructionType"]] = None,
        **kwargs
    ):
        super(RouteResultInstruction, self).__init__(**kwargs)
        self.route_offset_in_meters = None
        self.travel_time_in_seconds = None
        self.point = point
        self.point_index = None
        self.instruction_type = instruction_type
        self.road_numbers = None
        self.exit_number = None
        self.street = None
        self.signpost_text = None
        self.country_code = None
        self.state_code = None
        self.junction_type = None
        self.turn_angle_in_decimal_degrees = None
        self.roundabout_exit_number = None
        self.possible_combine_with_next = None
        self.driving_side = None
        self.maneuver = None
        self.message = None
        self.combined_message = None


class RouteResultInstructionGroup(msrest.serialization.Model):
    """Groups a sequence of instruction elements which are related to each other. The sequence range is constrained with firstInstructionIndex and lastInstructionIndex. When human-readable text messages are requested for guidance (instructionType=text or tagged), then the instructionGroup has a summary message returned when available.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar first_instruction_index: Index of the first instruction.
    :vartype first_instruction_index: int
    :ivar last_instruction_index: Index of the last instruction.
    :vartype last_instruction_index: int
    :ivar group_length_in_meters: Length of the group.
    :vartype group_length_in_meters: int
    :ivar group_message: Summary message when human-readable text messages are requested for
     guidance (instructionType=text or tagged).
    :vartype group_message: str
    """

    _validation = {
        'first_instruction_index': {'readonly': True},
        'last_instruction_index': {'readonly': True},
        'group_length_in_meters': {'readonly': True},
        'group_message': {'readonly': True},
    }

    _attribute_map = {
        'first_instruction_index': {'key': 'firstInstructionIndex', 'type': 'int'},
        'last_instruction_index': {'key': 'lastInstructionIndex', 'type': 'int'},
        'group_length_in_meters': {'key': 'groupLengthInMeters', 'type': 'int'},
        'group_message': {'key': 'groupMessage', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResultInstructionGroup, self).__init__(**kwargs)
        self.first_instruction_index = None
        self.last_instruction_index = None
        self.group_length_in_meters = None
        self.group_message = None


class RouteResultLeg(msrest.serialization.Model):
    """RouteResultLeg.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for route section.
    :vartype summary: ~azure.maps.service.models.RouteResultLegSummary
    :ivar points: Points array.
    :vartype points: list[~azure.maps.service.models.Coordinate]
    """

    _validation = {
        'summary': {'readonly': True},
        'points': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'RouteResultLegSummary'},
        'points': {'key': 'points', 'type': '[Coordinate]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResultLeg, self).__init__(**kwargs)
        self.summary = None
        self.points = None


class RouteResultLegSummary(msrest.serialization.Model):
    """Summary object for route section.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar length_in_meters: Length In Meters property.
    :vartype length_in_meters: int
    :ivar travel_time_in_seconds: Estimated travel time in seconds property that includes the delay
     due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes
     the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-
     dependent historic traffic data.
    :vartype travel_time_in_seconds: int
    :ivar traffic_delay_in_seconds: Estimated delay in seconds caused by the real-time incident(s)
     according to traffic information. For routes planned with departure time in the future, delays
     is always 0. To return additional travel times using different types of traffic information,
     parameter computeTravelTimeFor=all needs to be added.
    :vartype traffic_delay_in_seconds: int
    :ivar departure_time: Departure Time property.
    :vartype departure_time: str
    :ivar arrival_time: Arrival Time property.
    :vartype arrival_time: str
    :ivar no_traffic_travel_time_in_seconds: Estimated travel time calculated as if there are no
     delays on the route due to traffic conditions (e.g. congestion). Included only if
     computeTravelTimeFor = all is used in the query.
    :vartype no_traffic_travel_time_in_seconds: int
    :ivar historic_traffic_travel_time_in_seconds: Estimated travel time calculated using time-
     dependent historic traffic data. Included only if computeTravelTimeFor = all is used in the
     query.
    :vartype historic_traffic_travel_time_in_seconds: int
    :ivar live_traffic_incidents_travel_time_in_seconds: Estimated travel time calculated using
     real-time speed data. Included only if computeTravelTimeFor = all is used in the query.
    :vartype live_traffic_incidents_travel_time_in_seconds: int
    :ivar fuel_consumption_in_liters: Estimated fuel consumption in liters using the Combustion
     Consumption Model. Included if vehicleEngineType is set to *combustion* and
     constantSpeedConsumptionInLitersPerHundredkm is specified. The value will be non-negative.
    :vartype fuel_consumption_in_liters: float
    :ivar battery_consumption_ink_wh: Estimated electric energy consumption in kilowatt hours (kWh)
     using the Electric Consumption Model. Included if vehicleEngineType is set to electric and
     constantSpeedConsumptionInkWhPerHundredkm is specified. The value of batteryConsumptionInkWh
     includes the recuperated electric energy and can therefore be negative (which indicates gaining
     energy). If both maxChargeInkWh and currentChargeInkWh are specified, recuperation will be
     capped to ensure that the battery charge level never exceeds maxChargeInkWh. If neither
     maxChargeInkWh nor currentChargeInkWh are specified, unconstrained recuperation is assumed in
     the consumption calculation.
    :vartype battery_consumption_ink_wh: float
    """

    _validation = {
        'length_in_meters': {'readonly': True},
        'travel_time_in_seconds': {'readonly': True},
        'traffic_delay_in_seconds': {'readonly': True},
        'departure_time': {'readonly': True},
        'arrival_time': {'readonly': True},
        'no_traffic_travel_time_in_seconds': {'readonly': True},
        'historic_traffic_travel_time_in_seconds': {'readonly': True},
        'live_traffic_incidents_travel_time_in_seconds': {'readonly': True},
        'fuel_consumption_in_liters': {'readonly': True},
        'battery_consumption_ink_wh': {'readonly': True},
    }

    _attribute_map = {
        'length_in_meters': {'key': 'lengthInMeters', 'type': 'int'},
        'travel_time_in_seconds': {'key': 'travelTimeInSeconds', 'type': 'int'},
        'traffic_delay_in_seconds': {'key': 'trafficDelayInSeconds', 'type': 'int'},
        'departure_time': {'key': 'departureTime', 'type': 'str'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'str'},
        'no_traffic_travel_time_in_seconds': {'key': 'noTrafficTravelTimeInSeconds', 'type': 'int'},
        'historic_traffic_travel_time_in_seconds': {'key': 'historicTrafficTravelTimeInSeconds', 'type': 'int'},
        'live_traffic_incidents_travel_time_in_seconds': {'key': 'liveTrafficIncidentsTravelTimeInSeconds', 'type': 'int'},
        'fuel_consumption_in_liters': {'key': 'fuelConsumptionInLiters', 'type': 'float'},
        'battery_consumption_ink_wh': {'key': 'batteryConsumptionInkWh', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResultLegSummary, self).__init__(**kwargs)
        self.length_in_meters = None
        self.travel_time_in_seconds = None
        self.traffic_delay_in_seconds = None
        self.departure_time = None
        self.arrival_time = None
        self.no_traffic_travel_time_in_seconds = None
        self.historic_traffic_travel_time_in_seconds = None
        self.live_traffic_incidents_travel_time_in_seconds = None
        self.fuel_consumption_in_liters = None
        self.battery_consumption_ink_wh = None


class RouteResultSection(msrest.serialization.Model):
    """RouteResultSection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar start_point_index: Start Point Index property.
    :vartype start_point_index: int
    :ivar end_point_index: End Point Index property.
    :vartype end_point_index: int
    :ivar section_type: Section Type property.
    :vartype section_type: str
    :ivar travel_mode: Travel Mode property.
    :vartype travel_mode: str
    :ivar simple_category: Type of the incident. Can currently be JAM, ROAD_WORK, ROAD_CLOSURE, or
     OTHER. See "tec" for detailed information.
    :vartype simple_category: str
    :ivar effective_speed_in_kmh: Effective speed of the incident in km/h, averaged over its entire
     length.
    :vartype effective_speed_in_kmh: int
    :ivar delay_in_seconds: Delay in seconds caused by the incident.
    :vartype delay_in_seconds: int
    :ivar magnitude_of_delay: The magnitude of delay caused by the incident. These values
     correspond to the values of the response field ty of the `Get Traffic Incident Detail API
     <https://docs.microsoft.com/rest/api/maps/traffic/gettrafficincidentdetail>`_. Possible values
     include: "0", "1", "2", "3", "4".
    :vartype magnitude_of_delay: str or ~azure.maps.service.models.MagnitudeOfDelay
    :param tec: Details of the traffic event, using definitions in the `TPEG2-TEC
     <https://www.iso.org/standard/63116.html>`_ standard. Can contain effectCode and causes
     elements.
    :type tec: ~azure.maps.service.models.RouteResultSectionTec
    """

    _validation = {
        'start_point_index': {'readonly': True},
        'end_point_index': {'readonly': True},
        'section_type': {'readonly': True},
        'travel_mode': {'readonly': True},
        'simple_category': {'readonly': True},
        'effective_speed_in_kmh': {'readonly': True},
        'delay_in_seconds': {'readonly': True},
        'magnitude_of_delay': {'readonly': True},
    }

    _attribute_map = {
        'start_point_index': {'key': 'startPointIndex', 'type': 'int'},
        'end_point_index': {'key': 'endPointIndex', 'type': 'int'},
        'section_type': {'key': 'sectionType', 'type': 'str'},
        'travel_mode': {'key': 'travelMode', 'type': 'str'},
        'simple_category': {'key': 'simpleCategory', 'type': 'str'},
        'effective_speed_in_kmh': {'key': 'effectiveSpeedInKmh', 'type': 'int'},
        'delay_in_seconds': {'key': 'delayInSeconds', 'type': 'int'},
        'magnitude_of_delay': {'key': 'magnitudeOfDelay', 'type': 'str'},
        'tec': {'key': 'tec', 'type': 'RouteResultSectionTec'},
    }

    def __init__(
        self,
        *,
        tec: Optional["RouteResultSectionTec"] = None,
        **kwargs
    ):
        super(RouteResultSection, self).__init__(**kwargs)
        self.start_point_index = None
        self.end_point_index = None
        self.section_type = None
        self.travel_mode = None
        self.simple_category = None
        self.effective_speed_in_kmh = None
        self.delay_in_seconds = None
        self.magnitude_of_delay = None
        self.tec = tec


class RouteResultSectionTec(msrest.serialization.Model):
    """Details of the traffic event, using definitions in the `TPEG2-TEC <https://www.iso.org/standard/63116.html>`_ standard. Can contain effectCode and causes elements.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar effect_code: The effect on the traffic flow. Contains a value in the tec001:EffectCode
     table, as defined in the `TPEG2-TEC <https://www.iso.org/standard/63116.html>`_ standard. Can
     be used to color-code traffic events according to severity.
    :vartype effect_code: int
    :param causes: Causes array.
    :type causes: list[~azure.maps.service.models.RouteResultSectionTecCause]
    """

    _validation = {
        'effect_code': {'readonly': True},
    }

    _attribute_map = {
        'effect_code': {'key': 'effectCode', 'type': 'int'},
        'causes': {'key': 'causes', 'type': '[RouteResultSectionTecCause]'},
    }

    def __init__(
        self,
        *,
        causes: Optional[List["RouteResultSectionTecCause"]] = None,
        **kwargs
    ):
        super(RouteResultSectionTec, self).__init__(**kwargs)
        self.effect_code = None
        self.causes = causes


class RouteResultSectionTecCause(msrest.serialization.Model):
    """The cause of the traffic event. Can contain mainCauseCode and subCauseCode elements. Can be used to define iconography and descriptions.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar main_cause_code: The main cause of the traffic event. Contains a value in the
     tec002:CauseCode table, as defined in the `TPEG2-TEC
     <https://www.iso.org/standard/63116.html>`_ standard.
    :vartype main_cause_code: int
    :ivar sub_cause_code: The subcause of the traffic event. Contains a value in the sub cause
     table defined by the mainCauseCode, as defined in the `TPEG2-TEC
     <https://www.iso.org/standard/63116.html>`_ standard.
    :vartype sub_cause_code: int
    """

    _validation = {
        'main_cause_code': {'readonly': True},
        'sub_cause_code': {'readonly': True},
    }

    _attribute_map = {
        'main_cause_code': {'key': 'mainCauseCode', 'type': 'int'},
        'sub_cause_code': {'key': 'subCauseCode', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RouteResultSectionTecCause, self).__init__(**kwargs)
        self.main_cause_code = None
        self.sub_cause_code = None


class SearchAddressResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Address call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Address response.
    :vartype summary: ~azure.maps.service.models.SearchAddressSummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchAddressResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchAddressSummary'},
        'results': {'key': 'results', 'type': '[SearchAddressResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchAddressResult(msrest.serialization.Model):
    """SearchAddressResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: One of:
    
    
     * POI
     * Street
     * Geography
     * Point Address
     * Address Range
     * Cross Street.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    :param data_sources: Optional section. Reference ids for use with the `Get Search Polygon
     <https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon>`_ API.
    :type data_sources: ~azure.maps.service.models.DataSources
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
        'data_sources': {'key': 'dataSources', 'type': 'DataSources'},
    }

    def __init__(
        self,
        *,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        data_sources: Optional["DataSources"] = None,
        **kwargs
    ):
        super(SearchAddressResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points
        self.data_sources = data_sources


class SearchAddressReverseCrossStreetResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Address Reverse CrossStreet call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Address Reverse Cross Street response.
    :vartype summary: ~azure.maps.service.models.SearchAddressReverseCrossStreetSummary
    :ivar addresses: Addresses array.
    :vartype addresses: list[~azure.maps.service.models.SearchAddressReverseCrossStreetResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'addresses': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchAddressReverseCrossStreetSummary'},
        'addresses': {'key': 'addresses', 'type': '[SearchAddressReverseCrossStreetResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressReverseCrossStreetResponse, self).__init__(**kwargs)
        self.summary = None
        self.addresses = None


class SearchAddressReverseCrossStreetResult(msrest.serialization.Model):
    """SearchAddressReverseCrossStreetResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :ivar position: Position property in the form of "{latitude},{longitude}".
    :vartype position: str
    """

    _validation = {
        'position': {'readonly': True},
    }

    _attribute_map = {
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional["SearchResultAddress"] = None,
        **kwargs
    ):
        super(SearchAddressReverseCrossStreetResult, self).__init__(**kwargs)
        self.address = address
        self.position = None


class SearchAddressReverseCrossStreetSummary(msrest.serialization.Model):
    """Summary object for a Search Address Reverse Cross Street response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    """

    _validation = {
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
    }

    _attribute_map = {
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressReverseCrossStreetSummary, self).__init__(**kwargs)
        self.query_time = None
        self.num_results = None


class SearchAddressReverseResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Address Reverse call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Address Reverse response.
    :vartype summary: ~azure.maps.service.models.SearchAddressReverseSummary
    :ivar addresses: Addresses array.
    :vartype addresses: list[~azure.maps.service.models.SearchAddressReverseResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'addresses': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchAddressReverseSummary'},
        'addresses': {'key': 'addresses', 'type': '[SearchAddressReverseResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressReverseResponse, self).__init__(**kwargs)
        self.summary = None
        self.addresses = None


class SearchAddressReverseResult(msrest.serialization.Model):
    """SearchAddressReverseResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :ivar position: Position property in the form of "{latitude},{longitude}".
    :vartype position: str
    :ivar match_type: Information on the type of match.
    
     One of:
    
    
     * AddressPoint
     * HouseNumberRange
     * Street.
    :vartype match_type: str
    """

    _validation = {
        'position': {'readonly': True},
        'match_type': {'readonly': True},
    }

    _attribute_map = {
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'str'},
        'match_type': {'key': 'matchType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional["SearchResultAddress"] = None,
        **kwargs
    ):
        super(SearchAddressReverseResult, self).__init__(**kwargs)
        self.address = address
        self.position = None
        self.match_type = None


class SearchAddressReverseSummary(msrest.serialization.Model):
    """Summary object for a Search Address Reverse response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    """

    _validation = {
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
    }

    _attribute_map = {
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressReverseSummary, self).__init__(**kwargs)
        self.query_time = None
        self.num_results = None


class SearchAddressStructuredResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Address Structured call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Address Structured response.
    :vartype summary: ~azure.maps.service.models.SearchAddressStructuredSummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchAddressStructuredResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchAddressStructuredSummary'},
        'results': {'key': 'results', 'type': '[SearchAddressStructuredResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressStructuredResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchAddressStructuredResult(msrest.serialization.Model):
    """SearchAddressStructuredResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar dist: Straight line distance between the result and geobias location in meters.
    :vartype dist: float
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    :param address_ranges: Describes the address range on both sides of the street for a search
     result. Coordinates for the start and end locations of the address range are included.
    :type address_ranges: ~azure.maps.service.models.SearchResultAddressRanges
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'dist': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'dist': {'key': 'dist', 'type': 'float'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
        'address_ranges': {'key': 'addressRanges', 'type': 'SearchResultAddressRanges'},
    }

    def __init__(
        self,
        *,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        address_ranges: Optional["SearchResultAddressRanges"] = None,
        **kwargs
    ):
        super(SearchAddressStructuredResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.dist = None
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points
        self.address_ranges = address_ranges


class SearchAddressStructuredSummary(msrest.serialization.Model):
    """Summary object for a Search Address Structured response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar limit: Maximum number of responses that will be returned.
    :vartype limit: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    :ivar geo_bias: Indication when the internal search engine has applied a geospatial bias to
     improve the ranking of results.  In  some methods, this can be affected by setting the lat and
     lon parameters where available.  In other cases it is  purely internal.
    :vartype geo_bias: ~azure.maps.service.models.SearchSummaryGeoBias
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'limit': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
        'geo_bias': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'limit': {'key': 'limit', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
        'geo_bias': {'key': 'geoBias', 'type': 'SearchSummaryGeoBias'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressStructuredSummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.limit = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None
        self.geo_bias = None


class SearchAddressSummary(msrest.serialization.Model):
    """Summary object for a Search Address response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAddressSummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None


class SearchAlongRouteRequestBody(msrest.serialization.Model):
    """This type represents the request body for the Search Along Route service.

    :param route: A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.
    :type route: ~azure.maps.service.models.LineString
    """

    _attribute_map = {
        'route': {'key': 'route', 'type': 'LineString'},
    }

    def __init__(
        self,
        *,
        route: Optional["LineString"] = None,
        **kwargs
    ):
        super(SearchAlongRouteRequestBody, self).__init__(**kwargs)
        self.route = route


class SearchAlongRouteResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Along Route call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Along Route response.
    :vartype summary: ~azure.maps.service.models.SearchAlongRouteSummary
    :ivar results: A list of Search Along Route results.
    :vartype results: list[~azure.maps.service.models.SearchAlongRouteResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchAlongRouteSummary'},
        'results': {'key': 'results', 'type': '[SearchAlongRouteResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAlongRouteResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchAlongRouteResult(msrest.serialization.Model):
    """This type represents the Search Along Route result object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar info: Info property.
    :vartype info: str
    :param entity_type: Geography entity type. Present only when entityType was requested and is
     available. Possible values include: "Country", "CountrySubdivision",
     "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
     "MunicipalitySubdivision", "Neighbourhood", "PostalCodeArea".
    :type entity_type: str or ~azure.maps.service.models.EntityType
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    :ivar dist: Straight line distance between the result and geobias location in meters.
    :vartype dist: float
    :ivar detour_time: Detour time in seconds.
    :vartype detour_time: float
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'info': {'readonly': True},
        'dist': {'readonly': True},
        'detour_time': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
        'dist': {'key': 'dist', 'type': 'float'},
        'detour_time': {'key': 'detourTime', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        entity_type: Optional[Union[str, "EntityType"]] = None,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        **kwargs
    ):
        super(SearchAlongRouteResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.info = None
        self.entity_type = entity_type
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points
        self.dist = None
        self.detour_time = None


class SearchAlongRouteSummary(msrest.serialization.Model):
    """Summary object for a Search Along Route response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchAlongRouteSummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None


class SearchFuzzyResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Fuzzy call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Fuzzy response.
    :vartype summary: ~azure.maps.service.models.SearchFuzzySummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchFuzzyResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchFuzzySummary'},
        'results': {'key': 'results', 'type': '[SearchFuzzyResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchFuzzyResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchFuzzyResult(msrest.serialization.Model):
    """SearchFuzzyResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: One of:
    
    
     * POI
     * Street
     * Geography
     * Point Address
     * Address Range
     * Cross Street.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar info: Info property.
    :vartype info: str
    :param entity_type: Geography entity type. Present only when entityType was requested and is
     available. Possible values include: "Country", "CountrySubdivision",
     "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
     "MunicipalitySubdivision", "Neighbourhood", "PostalCodeArea".
    :type entity_type: str or ~azure.maps.service.models.EntityType
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    :param address_ranges: Describes the address range on both sides of the street for a search
     result. Coordinates for the start and end locations of the address range are included.
    :type address_ranges: ~azure.maps.service.models.SearchResultAddressRanges
    :param data_sources: Optional section. Reference ids for use with the `Get Search Polygon
     <https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon>`_ API.
    :type data_sources: ~azure.maps.service.models.DataSources
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
        'address_ranges': {'key': 'addressRanges', 'type': 'SearchResultAddressRanges'},
        'data_sources': {'key': 'dataSources', 'type': 'DataSources'},
    }

    def __init__(
        self,
        *,
        entity_type: Optional[Union[str, "EntityType"]] = None,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        address_ranges: Optional["SearchResultAddressRanges"] = None,
        data_sources: Optional["DataSources"] = None,
        **kwargs
    ):
        super(SearchFuzzyResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.info = None
        self.entity_type = entity_type
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points
        self.address_ranges = address_ranges
        self.data_sources = data_sources


class SearchFuzzySummary(msrest.serialization.Model):
    """Summary object for a Search Fuzzy response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchFuzzySummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None


class SearchGeometryResponse(msrest.serialization.Model):
    """This object is returned from a successful Search By Geometry call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Geometry response.
    :vartype summary: ~azure.maps.service.models.SearchGeometrySummary
    :ivar results: A list of Search Inside Geometry results.
    :vartype results: list[~azure.maps.service.models.SearchGeometryResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchGeometrySummary'},
        'results': {'key': 'results', 'type': '[SearchGeometryResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchGeometryResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchGeometryResult(msrest.serialization.Model):
    """This type represents the Search Inside Geometry result object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar info: Info property.
    :vartype info: str
    :param entity_type: Geography entity type. Present only when entityType was requested and is
     available. Possible values include: "Country", "CountrySubdivision",
     "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
     "MunicipalitySubdivision", "Neighbourhood", "PostalCodeArea".
    :type entity_type: str or ~azure.maps.service.models.EntityType
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
    }

    def __init__(
        self,
        *,
        entity_type: Optional[Union[str, "EntityType"]] = None,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        **kwargs
    ):
        super(SearchGeometryResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.info = None
        self.entity_type = entity_type
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points


class SearchGeometrySummary(msrest.serialization.Model):
    """Summary object for a Search Geometry response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchGeometrySummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None


class SearchInsideGeometryRequestBody(msrest.serialization.Model):
    """This type represents the request body for the Search Inside Geometry service.

    :param geometry: Any object.
    :type geometry: object
    """

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        geometry: Optional[object] = None,
        **kwargs
    ):
        super(SearchInsideGeometryRequestBody, self).__init__(**kwargs)
        self.geometry = geometry


class SearchNearbyResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Nearby call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search Nearby response.
    :vartype summary: ~azure.maps.service.models.SearchNearbySummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchNearbyResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchNearbySummary'},
        'results': {'key': 'results', 'type': '[SearchNearbyResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchNearbyResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchNearbyResult(msrest.serialization.Model):
    """SearchNearbyResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar dist: Straight line distance between the result and geobias location in meters.
    :vartype dist: float
    :ivar info: Info property.
    :vartype info: str
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'dist': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'dist': {'key': 'dist', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
    }

    def __init__(
        self,
        *,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        **kwargs
    ):
        super(SearchNearbyResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.dist = None
        self.info = None
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points


class SearchNearbySummary(msrest.serialization.Model):
    """Summary object for a Search Nearby response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    :ivar geo_bias: Indication when the internal search engine has applied a geospatial bias to
     improve the ranking of results.  In  some methods, this can be affected by setting the lat and
     lon parameters where available.  In other cases it is  purely internal.
    :vartype geo_bias: ~azure.maps.service.models.SearchSummaryGeoBias
    """

    _validation = {
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
        'geo_bias': {'readonly': True},
    }

    _attribute_map = {
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
        'geo_bias': {'key': 'geoBias', 'type': 'SearchSummaryGeoBias'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchNearbySummary, self).__init__(**kwargs)
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None
        self.geo_bias = None


class SearchPoiCategoryResponse(msrest.serialization.Model):
    """This object is returned from a successful Search POI Category call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search POI Category response.
    :vartype summary: ~azure.maps.service.models.SearchPoiCategorySummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchPoiCategoryResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchPoiCategorySummary'},
        'results': {'key': 'results', 'type': '[SearchPoiCategoryResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchPoiCategoryResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchPoiCategoryResult(msrest.serialization.Model):
    """SearchPoiCategoryResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar dist: Straight line distance between the result and geobias location in meters.
    :vartype dist: float
    :ivar info: Info property.
    :vartype info: str
    :param entity_type: Geography entity type. Present only when entityType was requested and is
     available. Possible values include: "Country", "CountrySubdivision",
     "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
     "MunicipalitySubdivision", "Neighbourhood", "PostalCodeArea".
    :type entity_type: str or ~azure.maps.service.models.EntityType
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'dist': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'dist': {'key': 'dist', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
    }

    def __init__(
        self,
        *,
        entity_type: Optional[Union[str, "EntityType"]] = None,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        **kwargs
    ):
        super(SearchPoiCategoryResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.dist = None
        self.info = None
        self.entity_type = entity_type
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points


class SearchPoiCategorySummary(msrest.serialization.Model):
    """Summary object for a Search POI Category response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    :ivar geo_bias: Indication when the internal search engine has applied a geospatial bias to
     improve the ranking of results.  In  some methods, this can be affected by setting the lat and
     lon parameters where available.  In other cases it is  purely internal.
    :vartype geo_bias: ~azure.maps.service.models.SearchSummaryGeoBias
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
        'geo_bias': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
        'geo_bias': {'key': 'geoBias', 'type': 'SearchSummaryGeoBias'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchPoiCategorySummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None
        self.geo_bias = None


class SearchPoiResponse(msrest.serialization.Model):
    """This object is returned from a successful Search POI call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object for a Search POI response.
    :vartype summary: ~azure.maps.service.models.SearchPoiSummary
    :ivar results: Results array.
    :vartype results: list[~azure.maps.service.models.SearchPoiResult]
    """

    _validation = {
        'summary': {'readonly': True},
        'results': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'SearchPoiSummary'},
        'results': {'key': 'results', 'type': '[SearchPoiResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchPoiResponse, self).__init__(**kwargs)
        self.summary = None
        self.results = None


class SearchPoiResult(msrest.serialization.Model):
    """SearchPoiResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type property.
    :vartype type: str
    :ivar id: Id property.
    :vartype id: str
    :ivar score: The value within a result set to indicate the relative matching score between
     results.  You can use this to  determine that result x is twice as likely to be as relevant as
     result y if the value of x is 2x the value of y.   The values vary between queries and is only
     meant as a relative value for one result set.
    :vartype score: float
    :ivar dist: Straight line distance between the result and geobias location in meters.
    :vartype dist: float
    :ivar info: Info property.
    :vartype info: str
    :param entity_type: Geography entity type. Present only when entityType was requested and is
     available. Possible values include: "Country", "CountrySubdivision",
     "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
     "MunicipalitySubdivision", "Neighbourhood", "PostalCodeArea".
    :type entity_type: str or ~azure.maps.service.models.EntityType
    :param poi: Details of the returned POI including information such as the name, phone, url
     address, and classifications.
    :type poi: ~azure.maps.service.models.SearchResultPoi
    :param address: The address of the result.
    :type address: ~azure.maps.service.models.SearchResultAddress
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.SearchResultViewport
    :param entry_points: Entry Points array.
    :type entry_points: list[~azure.maps.service.models.SearchResultEntryPoint]
    """

    _validation = {
        'type': {'readonly': True},
        'id': {'readonly': True},
        'score': {'readonly': True},
        'dist': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'score': {'key': 'score', 'type': 'float'},
        'dist': {'key': 'dist', 'type': 'float'},
        'info': {'key': 'info', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'poi': {'key': 'poi', 'type': 'SearchResultPoi'},
        'address': {'key': 'address', 'type': 'SearchResultAddress'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
        'viewport': {'key': 'viewport', 'type': 'SearchResultViewport'},
        'entry_points': {'key': 'entryPoints', 'type': '[SearchResultEntryPoint]'},
    }

    def __init__(
        self,
        *,
        entity_type: Optional[Union[str, "EntityType"]] = None,
        poi: Optional["SearchResultPoi"] = None,
        address: Optional["SearchResultAddress"] = None,
        position: Optional["CoordinateAbbreviated"] = None,
        viewport: Optional["SearchResultViewport"] = None,
        entry_points: Optional[List["SearchResultEntryPoint"]] = None,
        **kwargs
    ):
        super(SearchPoiResult, self).__init__(**kwargs)
        self.type = None
        self.id = None
        self.score = None
        self.dist = None
        self.info = None
        self.entity_type = entity_type
        self.poi = poi
        self.address = address
        self.position = position
        self.viewport = viewport
        self.entry_points = entry_points


class SearchPoiSummary(msrest.serialization.Model):
    """Summary object for a Search POI response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query: Query property.
    :vartype query: str
    :ivar query_type: QueryType property.
    :vartype query_type: str
    :ivar query_time: QueryTime property.
    :vartype query_time: int
    :ivar num_results: NumResults property.
    :vartype num_results: int
    :ivar offset: Offset property.
    :vartype offset: int
    :ivar total_results: TotalResults property.
    :vartype total_results: int
    :ivar fuzzy_level: FuzzyLevel property.
    :vartype fuzzy_level: int
    :ivar geo_bias: Indication when the internal search engine has applied a geospatial bias to
     improve the ranking of results.  In  some methods, this can be affected by setting the lat and
     lon parameters where available.  In other cases it is  purely internal.
    :vartype geo_bias: ~azure.maps.service.models.SearchSummaryGeoBias
    """

    _validation = {
        'query': {'readonly': True},
        'query_type': {'readonly': True},
        'query_time': {'readonly': True},
        'num_results': {'readonly': True},
        'offset': {'readonly': True},
        'total_results': {'readonly': True},
        'fuzzy_level': {'readonly': True},
        'geo_bias': {'readonly': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
        'query_time': {'key': 'queryTime', 'type': 'int'},
        'num_results': {'key': 'numResults', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'total_results': {'key': 'totalResults', 'type': 'int'},
        'fuzzy_level': {'key': 'fuzzyLevel', 'type': 'int'},
        'geo_bias': {'key': 'geoBias', 'type': 'SearchSummaryGeoBias'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchPoiSummary, self).__init__(**kwargs)
        self.query = None
        self.query_type = None
        self.query_time = None
        self.num_results = None
        self.offset = None
        self.total_results = None
        self.fuzzy_level = None
        self.geo_bias = None


class SearchPolygonResponse(msrest.serialization.Model):
    """This object is returned from a successful Search Polygon call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_data: Results array.
    :vartype additional_data: list[~azure.maps.service.models.SearchPolygonResult]
    """

    _validation = {
        'additional_data': {'readonly': True},
    }

    _attribute_map = {
        'additional_data': {'key': 'additionalData', 'type': '[SearchPolygonResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchPolygonResponse, self).__init__(**kwargs)
        self.additional_data = None


class SearchPolygonResult(msrest.serialization.Model):
    """SearchPolygonResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar provider_id: ID of the returned entity.
    :vartype provider_id: str
    :ivar error: Reason for the failure to obtain data for this provider.
    :vartype error: str
    :param geometry_data: Geometry data in GeoJSON format. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946>`_ for details. Present only if "error" is not present.
    :type geometry_data: object
    """

    _validation = {
        'provider_id': {'readonly': True},
        'error': {'readonly': True},
    }

    _attribute_map = {
        'provider_id': {'key': 'providerID', 'type': 'str'},
        'error': {'key': 'error', 'type': 'str'},
        'geometry_data': {'key': 'geometryData', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        geometry_data: Optional[object] = None,
        **kwargs
    ):
        super(SearchPolygonResult, self).__init__(**kwargs)
        self.provider_id = None
        self.error = None
        self.geometry_data = geometry_data


class SearchResultAddress(msrest.serialization.Model):
    """The address of the result.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar building_number: Building Number property.
    :vartype building_number: str
    :ivar street: Street property.
    :vartype street: str
    :ivar cross_street: Cross Street property.
    :vartype cross_street: str
    :ivar street_number: Street Number property.
    :vartype street_number: str
    :ivar route_numbers: number of routes.
    :vartype route_numbers: list[int]
    :ivar street_name: Street Name property.
    :vartype street_name: str
    :ivar street_name_and_number: Street Name and Number property.
    :vartype street_name_and_number: str
    :ivar municipality: Municipality property.
    :vartype municipality: str
    :ivar municipality_subdivision: Municipality Subdivision property.
    :vartype municipality_subdivision: str
    :ivar country_tertiary_subdivision: Country Tertiary Subdivision property.
    :vartype country_tertiary_subdivision: str
    :ivar country_secondary_subdivision: Country Secondary Subdivision property.
    :vartype country_secondary_subdivision: str
    :ivar country_subdivision: Country Subdivision property.
    :vartype country_subdivision: str
    :ivar postal_code: Postal Code property.
    :vartype postal_code: str
    :ivar extended_postal_code: Extended Postal Code property.
    :vartype extended_postal_code: str
    :ivar country_code: Country Code property.
    :vartype country_code: str
    :ivar country: Country property.
    :vartype country: str
    :ivar country_code_iso3: Country Code ISO3 property.
    :vartype country_code_iso3: str
    :ivar freeform_address: Free form Address property.
    :vartype freeform_address: str
    :ivar country_subdivision_name: Country Subdivision Name property.
    :vartype country_subdivision_name: str
    :ivar local_name: An address component which represents the name of a geographic area or
     locality that groups a number of addressable objects for addressing purposes, without being an
     administrative unit. This field is used to build the ``freeformAddress`` property.
    :vartype local_name: str
    """

    _validation = {
        'building_number': {'readonly': True},
        'street': {'readonly': True},
        'cross_street': {'readonly': True},
        'street_number': {'readonly': True},
        'route_numbers': {'readonly': True},
        'street_name': {'readonly': True},
        'street_name_and_number': {'readonly': True},
        'municipality': {'readonly': True},
        'municipality_subdivision': {'readonly': True},
        'country_tertiary_subdivision': {'readonly': True},
        'country_secondary_subdivision': {'readonly': True},
        'country_subdivision': {'readonly': True},
        'postal_code': {'readonly': True},
        'extended_postal_code': {'readonly': True},
        'country_code': {'readonly': True},
        'country': {'readonly': True},
        'country_code_iso3': {'readonly': True},
        'freeform_address': {'readonly': True},
        'country_subdivision_name': {'readonly': True},
        'local_name': {'readonly': True},
    }

    _attribute_map = {
        'building_number': {'key': 'buildingNumber', 'type': 'str'},
        'street': {'key': 'street', 'type': 'str'},
        'cross_street': {'key': 'crossStreet', 'type': 'str'},
        'street_number': {'key': 'streetNumber', 'type': 'str'},
        'route_numbers': {'key': 'routeNumbers', 'type': '[int]'},
        'street_name': {'key': 'streetName', 'type': 'str'},
        'street_name_and_number': {'key': 'streetNameAndNumber', 'type': 'str'},
        'municipality': {'key': 'municipality', 'type': 'str'},
        'municipality_subdivision': {'key': 'municipalitySubdivision', 'type': 'str'},
        'country_tertiary_subdivision': {'key': 'countryTertiarySubdivision', 'type': 'str'},
        'country_secondary_subdivision': {'key': 'countrySecondarySubdivision', 'type': 'str'},
        'country_subdivision': {'key': 'countrySubdivision', 'type': 'str'},
        'postal_code': {'key': 'postalCode', 'type': 'str'},
        'extended_postal_code': {'key': 'extendedPostalCode', 'type': 'str'},
        'country_code': {'key': 'countryCode', 'type': 'str'},
        'country': {'key': 'country', 'type': 'str'},
        'country_code_iso3': {'key': 'countryCodeISO3', 'type': 'str'},
        'freeform_address': {'key': 'freeformAddress', 'type': 'str'},
        'country_subdivision_name': {'key': 'countrySubdivisionName', 'type': 'str'},
        'local_name': {'key': 'localName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultAddress, self).__init__(**kwargs)
        self.building_number = None
        self.street = None
        self.cross_street = None
        self.street_number = None
        self.route_numbers = None
        self.street_name = None
        self.street_name_and_number = None
        self.municipality = None
        self.municipality_subdivision = None
        self.country_tertiary_subdivision = None
        self.country_secondary_subdivision = None
        self.country_subdivision = None
        self.postal_code = None
        self.extended_postal_code = None
        self.country_code = None
        self.country = None
        self.country_code_iso3 = None
        self.freeform_address = None
        self.country_subdivision_name = None
        self.local_name = None


class SearchResultAddressRanges(msrest.serialization.Model):
    """Describes the address range on both sides of the street for a search result. Coordinates for the start and end locations of the address range are included.

    :param range_left:
    :type range_left: str
    :param range_right:
    :type range_right: str
    :param from_property: A location represented as a latitude and longitude.
    :type from_property: ~azure.maps.service.models.CoordinateAbbreviated
    :param to: A location represented as a latitude and longitude.
    :type to: ~azure.maps.service.models.CoordinateAbbreviated
    """

    _attribute_map = {
        'range_left': {'key': 'rangeLeft', 'type': 'str'},
        'range_right': {'key': 'rangeRight', 'type': 'str'},
        'from_property': {'key': 'from', 'type': 'CoordinateAbbreviated'},
        'to': {'key': 'to', 'type': 'CoordinateAbbreviated'},
    }

    def __init__(
        self,
        *,
        range_left: Optional[str] = None,
        range_right: Optional[str] = None,
        from_property: Optional["CoordinateAbbreviated"] = None,
        to: Optional["CoordinateAbbreviated"] = None,
        **kwargs
    ):
        super(SearchResultAddressRanges, self).__init__(**kwargs)
        self.range_left = range_left
        self.range_right = range_right
        self.from_property = from_property
        self.to = to


class SearchResultEntryPoint(msrest.serialization.Model):
    """The entry point for the POI being returned.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The type of entry point. Value can be either *main* or *minor*. Possible values
     include: "main", "minor".
    :vartype type: str or ~azure.maps.service.models.EntryPointType
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.service.models.CoordinateAbbreviated
    """

    _validation = {
        'type': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'position': {'key': 'position', 'type': 'CoordinateAbbreviated'},
    }

    def __init__(
        self,
        *,
        position: Optional["CoordinateAbbreviated"] = None,
        **kwargs
    ):
        super(SearchResultEntryPoint, self).__init__(**kwargs)
        self.type = None
        self.position = position


class SearchResultPoi(msrest.serialization.Model):
    """Details of the returned POI including information such as the name, phone, url address, and classifications.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: Name of the POI property.
    :vartype name: str
    :ivar phone: Telephone number property.
    :vartype phone: str
    :ivar url: Website URL property.
    :vartype url: str
    :ivar category_set: The list of the most specific POI categories.
    :vartype category_set: list[~azure.maps.service.models.SearchResultPoiCategorySet]
    :ivar categories: **[Deprecated]** Use classifications instead. Categories array.
    :vartype categories: list[str]
    :ivar classifications: Classification array.
    :vartype classifications: list[~azure.maps.service.models.SearchResultPoiClassification]
    :ivar brands: Brands array. The name of the brand for the POI being returned.
    :vartype brands: list[~azure.maps.service.models.SearchResultPoiBrand]
    :param opening_hours: Opening hours for a POI (Points of Interest).
    :type opening_hours: ~azure.maps.service.models.SearchResultPoiOpeningHours
    """

    _validation = {
        'name': {'readonly': True},
        'phone': {'readonly': True},
        'url': {'readonly': True},
        'category_set': {'readonly': True},
        'categories': {'readonly': True},
        'classifications': {'readonly': True},
        'brands': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'phone': {'key': 'phone', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
        'category_set': {'key': 'categorySet', 'type': '[SearchResultPoiCategorySet]'},
        'categories': {'key': 'categories', 'type': '[str]'},
        'classifications': {'key': 'classifications', 'type': '[SearchResultPoiClassification]'},
        'brands': {'key': 'brands', 'type': '[SearchResultPoiBrand]'},
        'opening_hours': {'key': 'openingHours', 'type': 'SearchResultPoiOpeningHours'},
    }

    def __init__(
        self,
        *,
        opening_hours: Optional["SearchResultPoiOpeningHours"] = None,
        **kwargs
    ):
        super(SearchResultPoi, self).__init__(**kwargs)
        self.name = None
        self.phone = None
        self.url = None
        self.category_set = None
        self.categories = None
        self.classifications = None
        self.brands = None
        self.opening_hours = opening_hours


class SearchResultPoiBrand(msrest.serialization.Model):
    """The name of the brand for the POI being returned.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: Name of the brand.
    :vartype name: str
    """

    _validation = {
        'name': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiBrand, self).__init__(**kwargs)
        self.name = None


class SearchResultPoiCategorySet(msrest.serialization.Model):
    """POI category.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Category ID.
    :vartype id: int
    """

    _validation = {
        'id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiCategorySet, self).__init__(**kwargs)
        self.id = None


class SearchResultPoiClassification(msrest.serialization.Model):
    """The classification for the POI being returned.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: Code property.
    :vartype code: str
    :ivar names: Names array.
    :vartype names: list[~azure.maps.service.models.SearchResultPoiClassificationName]
    """

    _validation = {
        'code': {'readonly': True},
        'names': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'names': {'key': 'names', 'type': '[SearchResultPoiClassificationName]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiClassification, self).__init__(**kwargs)
        self.code = None
        self.names = None


class SearchResultPoiClassificationName(msrest.serialization.Model):
    """Name for the classification.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name_locale: Name Locale property.
    :vartype name_locale: str
    :ivar name: Name property.
    :vartype name: str
    """

    _validation = {
        'name_locale': {'readonly': True},
        'name': {'readonly': True},
    }

    _attribute_map = {
        'name_locale': {'key': 'nameLocale', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiClassificationName, self).__init__(**kwargs)
        self.name_locale = None
        self.name = None


class SearchResultPoiOpeningHours(msrest.serialization.Model):
    """Opening hours for a POI (Points of Interest).

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar mode: Value used in the Request.
    :vartype mode: str
    :ivar time_ranges: List of time ranges for the next 7 days.
    :vartype time_ranges: list[~azure.maps.service.models.SearchResultPoiOpeningHoursTimeRange]
    """

    _validation = {
        'mode': {'readonly': True},
        'time_ranges': {'readonly': True},
    }

    _attribute_map = {
        'mode': {'key': 'mode', 'type': 'str'},
        'time_ranges': {'key': 'timeRanges', 'type': '[SearchResultPoiOpeningHoursTimeRange]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiOpeningHours, self).__init__(**kwargs)
        self.mode = None
        self.time_ranges = None


class SearchResultPoiOpeningHoursTimeRange(msrest.serialization.Model):
    """Open time range for a day.

    :param start_time: The point in the next 7 days range when a given POI is being opened, or the
     beginning of the range if it was opened before the range.
    :type start_time: ~azure.maps.service.models.SearchResultPoiOpeningHoursTimeRangeTime
    :param end_time: The point in the next 7 days range when a given POI is being closed, or the
     beginning of the range if it was closed before the range.
    :type end_time: ~azure.maps.service.models.SearchResultPoiOpeningHoursTimeRangeTime
    """

    _attribute_map = {
        'start_time': {'key': 'startTime', 'type': 'SearchResultPoiOpeningHoursTimeRangeTime'},
        'end_time': {'key': 'endTime', 'type': 'SearchResultPoiOpeningHoursTimeRangeTime'},
    }

    def __init__(
        self,
        *,
        start_time: Optional["SearchResultPoiOpeningHoursTimeRangeTime"] = None,
        end_time: Optional["SearchResultPoiOpeningHoursTimeRangeTime"] = None,
        **kwargs
    ):
        super(SearchResultPoiOpeningHoursTimeRange, self).__init__(**kwargs)
        self.start_time = start_time
        self.end_time = end_time


class SearchResultPoiOpeningHoursTimeRangeTime(msrest.serialization.Model):
    """Represents a date and time.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar date: Represents current day in calendar year in POI time zone.
    :vartype date: str
    :ivar hour: Hours are in the 24 hour format in the local time of a POI; possible values are 0 -
     23.
    :vartype hour: int
    :ivar minute: Minutes are in the local time of a POI; possible values are 0 - 59.
    :vartype minute: int
    """

    _validation = {
        'date': {'readonly': True},
        'hour': {'readonly': True},
        'minute': {'readonly': True},
    }

    _attribute_map = {
        'date': {'key': 'date', 'type': 'str'},
        'hour': {'key': 'hour', 'type': 'int'},
        'minute': {'key': 'minute', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchResultPoiOpeningHoursTimeRangeTime, self).__init__(**kwargs)
        self.date = None
        self.hour = None
        self.minute = None


class SearchResultViewport(msrest.serialization.Model):
    """The viewport that covers the result represented by the top-left and bottom-right coordinates of the  viewport.

    :param top_left_point: A location represented as a latitude and longitude.
    :type top_left_point: ~azure.maps.service.models.CoordinateAbbreviated
    :param btm_right_point: A location represented as a latitude and longitude.
    :type btm_right_point: ~azure.maps.service.models.CoordinateAbbreviated
    """

    _attribute_map = {
        'top_left_point': {'key': 'topLeftPoint', 'type': 'CoordinateAbbreviated'},
        'btm_right_point': {'key': 'btmRightPoint', 'type': 'CoordinateAbbreviated'},
    }

    def __init__(
        self,
        *,
        top_left_point: Optional["CoordinateAbbreviated"] = None,
        btm_right_point: Optional["CoordinateAbbreviated"] = None,
        **kwargs
    ):
        super(SearchResultViewport, self).__init__(**kwargs)
        self.top_left_point = top_left_point
        self.btm_right_point = btm_right_point


class SearchSummaryGeoBias(msrest.serialization.Model):
    """Indication when the internal search engine has applied a geospatial bias to improve the ranking of results.  In  some methods, this can be affected by setting the lat and lon parameters where available.  In other cases it is  purely internal.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar lat: Latitude property.
    :vartype lat: float
    :ivar lon: Longitude property.
    :vartype lon: float
    """

    _validation = {
        'lat': {'readonly': True},
        'lon': {'readonly': True},
    }

    _attribute_map = {
        'lat': {'key': 'lat', 'type': 'float'},
        'lon': {'key': 'lon', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SearchSummaryGeoBias, self).__init__(**kwargs)
        self.lat = None
        self.lon = None


class SevereWeatherAlert(msrest.serialization.Model):
    """Information about a severe weather alert.

    :param country_code: 2-character ISO 3166-1 Alpha-2 country code, for example, "US".
    :type country_code: str
    :param alert_id: A unique numerical identifier for a weather alert.
    :type alert_id: int
    :param description: Description of the alert.
    :type description: ~azure.maps.service.models.Description
    :param category: Category of the alert.
    :type category: str
    :param priority: Number signifying the importance or ranking order of the given alert within
     the country/region it has originated. A lower number signifies a higher priority. For example,
     1 is the highest priority. The number varies by country/region and can change over time as each
     country/region evolves their alert systems.
    :type priority: int
    :param class_property: Classification of the alert. This field is not available for all
     countries and therefore not always returned.
    :type class_property: str
    :param level: Severity level of the alert. This field is not available for all countries and
     therefore not always returned.
    :type level: str
    :param source: The provider of the alert information. By default the source is returned in
     English (en-US). The alerts are from official Government Meteorological Agencies and leading
     global weather alert providers.
    :type source: str
    :param source_id: A numerical identifier associated with the source provider name of the alert
     data.
    :type source_id: int
    :param disclaimer: A disclaimer regarding the source of the alert information. This field is
     not always available. For example, disclaimer may include details about the delays or potential
     issues related to the alarm.
    :type disclaimer: str
    :param alert_areas: Information about the alert specific to the affected area(s).
    :type alert_areas: list[~azure.maps.service.models.AlertArea]
    """

    _attribute_map = {
        'country_code': {'key': 'countryCode', 'type': 'str'},
        'alert_id': {'key': 'alertId', 'type': 'int'},
        'description': {'key': 'description', 'type': 'Description'},
        'category': {'key': 'category', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'class_property': {'key': 'class', 'type': 'str'},
        'level': {'key': 'level', 'type': 'str'},
        'source': {'key': 'source', 'type': 'str'},
        'source_id': {'key': 'sourceId', 'type': 'int'},
        'disclaimer': {'key': 'disclaimer', 'type': 'str'},
        'alert_areas': {'key': 'alertAreas', 'type': '[AlertArea]'},
    }

    def __init__(
        self,
        *,
        country_code: Optional[str] = None,
        alert_id: Optional[int] = None,
        description: Optional["Description"] = None,
        category: Optional[str] = None,
        priority: Optional[int] = None,
        class_property: Optional[str] = None,
        level: Optional[str] = None,
        source: Optional[str] = None,
        source_id: Optional[int] = None,
        disclaimer: Optional[str] = None,
        alert_areas: Optional[List["AlertArea"]] = None,
        **kwargs
    ):
        super(SevereWeatherAlert, self).__init__(**kwargs)
        self.country_code = country_code
        self.alert_id = alert_id
        self.description = description
        self.category = category
        self.priority = priority
        self.class_property = class_property
        self.level = level
        self.source = source
        self.source_id = source_id
        self.disclaimer = disclaimer
        self.alert_areas = alert_areas


class SevereWeatherAlertsResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Severe Weather Alerts call.

    :param results: A list of all severe weather alerts for the queried location.
    :type results: list[~azure.maps.service.models.SevereWeatherAlert]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[SevereWeatherAlert]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["SevereWeatherAlert"]] = None,
        **kwargs
    ):
        super(SevereWeatherAlertsResponse, self).__init__(**kwargs)
        self.results = results


class SpatialCoordinate(msrest.serialization.Model):
    """A location represented as a latitude and longitude.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar lat: Latitude property.
    :vartype lat: float
    :ivar lon: Longitude property.
    :vartype lon: float
    """

    _validation = {
        'lat': {'readonly': True},
        'lon': {'readonly': True},
    }

    _attribute_map = {
        'lat': {'key': 'lat', 'type': 'float'},
        'lon': {'key': 'lon', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SpatialCoordinate, self).__init__(**kwargs)
        self.lat = None
        self.lon = None


class StatesetCreatedResponse(msrest.serialization.Model):
    """The response model for the successful Stateset Create API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar stateset_id: The ID for the new stateset created.
    :vartype stateset_id: str
    """

    _validation = {
        'stateset_id': {'readonly': True},
    }

    _attribute_map = {
        'stateset_id': {'key': 'statesetId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StatesetCreatedResponse, self).__init__(**kwargs)
        self.stateset_id = None


class StatesetGetResponse(msrest.serialization.Model):
    """The response model for the successful Stateset Get API.

    :param dataset_id_list: Dataset ID associated with the stateset.
    :type dataset_id_list: list[str]
    :param stateset_style: The styles model.
    :type stateset_style: ~azure.maps.service.models.StylesObject
    """

    _attribute_map = {
        'dataset_id_list': {'key': 'datasetIdList', 'type': '[str]'},
        'stateset_style': {'key': 'statesetStyle', 'type': 'StylesObject'},
    }

    def __init__(
        self,
        *,
        dataset_id_list: Optional[List[str]] = None,
        stateset_style: Optional["StylesObject"] = None,
        **kwargs
    ):
        super(StatesetGetResponse, self).__init__(**kwargs)
        self.dataset_id_list = dataset_id_list
        self.stateset_style = stateset_style


class StatesetInfoObject(msrest.serialization.Model):
    """The stateset information detail.

    :param stateset_id: The stateset ID of this stateset.
    :type stateset_id: str
    :param dataset_id_list: Dataset ID associated with the stateset.
    :type dataset_id_list: list[str]
    :param stateset_style: The styles model.
    :type stateset_style: ~azure.maps.service.models.StylesObject
    """

    _attribute_map = {
        'stateset_id': {'key': 'statesetId', 'type': 'str'},
        'dataset_id_list': {'key': 'datasetIdList', 'type': '[str]'},
        'stateset_style': {'key': 'statesetStyle', 'type': 'StylesObject'},
    }

    def __init__(
        self,
        *,
        stateset_id: Optional[str] = None,
        dataset_id_list: Optional[List[str]] = None,
        stateset_style: Optional["StylesObject"] = None,
        **kwargs
    ):
        super(StatesetInfoObject, self).__init__(**kwargs)
        self.stateset_id = stateset_id
        self.dataset_id_list = dataset_id_list
        self.stateset_style = stateset_style


class StatesetListResponse(msrest.serialization.Model):
    """The response model for the successful Stateset List API.

    :param stateset_detail_list: A list of statesets information.
    :type stateset_detail_list: list[~azure.maps.service.models.StatesetInfoObject]
    """

    _attribute_map = {
        'stateset_detail_list': {'key': 'statesetDetailList', 'type': '[StatesetInfoObject]'},
    }

    def __init__(
        self,
        *,
        stateset_detail_list: Optional[List["StatesetInfoObject"]] = None,
        **kwargs
    ):
        super(StatesetListResponse, self).__init__(**kwargs)
        self.stateset_detail_list = stateset_detail_list


class Step(msrest.serialization.Model):
    """Step.

    :param direction: The walking direction associated with this step.
    :type direction: ~azure.maps.service.models.Direction
    :param street_name: The name of the street in which this step takes place.
    :type street_name: str
    """

    _attribute_map = {
        'direction': {'key': 'direction', 'type': 'Direction'},
        'street_name': {'key': 'streetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        direction: Optional["Direction"] = None,
        street_name: Optional[str] = None,
        **kwargs
    ):
        super(Step, self).__init__(**kwargs)
        self.direction = direction
        self.street_name = street_name


class Stop(msrest.serialization.Model):
    """The stop's basic info.

    :param stop_id: The unique Azure Maps identifier for the respective public transit stop. When
     referring to public transit stops over time, it is recommended to use ``stopId`` since it will
     not change, as long as the physical stop exists.
    :type stop_id: str
    :param stop_key: The GTFS stop Id. GTFS stop Ids are provided by the transit authority and
     subject to change.
    :type stop_key: str
    :param stop_name: The name of the stop.
    :type stop_name: str
    :param stop_code: The stop code displayed at the physical stop. Returned if available.
    :type stop_code: str
    :param position: The Stop's location, latitude and longitude.
    :type position: ~azure.maps.service.models.Coordinate
    :param main_transit_type: The transit type of most lines stopping at this stop. One of Tram,
     Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular.
    :type main_transit_type: str
    :param main_agency_id: The Id of the transit agency of most lines stopping at this stop. For
     example '5872'.
    :type main_agency_id: str
    :param main_agency_name: The name of the agency of most lines stopping at this stop, for
     example, 'Metro Transit'.
    :type main_agency_name: str
    """

    _attribute_map = {
        'stop_id': {'key': 'stopId', 'type': 'str'},
        'stop_key': {'key': 'stopKey', 'type': 'str'},
        'stop_name': {'key': 'stopName', 'type': 'str'},
        'stop_code': {'key': 'stopCode', 'type': 'str'},
        'position': {'key': 'position', 'type': 'Coordinate'},
        'main_transit_type': {'key': 'mainTransitType', 'type': 'str'},
        'main_agency_id': {'key': 'mainAgencyId', 'type': 'str'},
        'main_agency_name': {'key': 'mainAgencyName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        stop_id: Optional[str] = None,
        stop_key: Optional[str] = None,
        stop_name: Optional[str] = None,
        stop_code: Optional[str] = None,
        position: Optional["Coordinate"] = None,
        main_transit_type: Optional[str] = None,
        main_agency_id: Optional[str] = None,
        main_agency_name: Optional[str] = None,
        **kwargs
    ):
        super(Stop, self).__init__(**kwargs)
        self.stop_id = stop_id
        self.stop_key = stop_key
        self.stop_name = stop_name
        self.stop_code = stop_code
        self.position = position
        self.main_transit_type = main_transit_type
        self.main_agency_id = main_agency_id
        self.main_agency_name = main_agency_name


class StringRuleObject(msrest.serialization.Model):
    """The string rule. The string value matching is case sensitive. If a feature's state doesn't match any of the values defined here, that feature will not have any dynamic style. If duplicate string values are given, the first one takes precedence.

    :param state_value1: The color when value string is stateValue1.
    :type state_value1: str
    :param state_value2: The color when value string is stateValue2.
    :type state_value2: str
    :param state_value_n: The color when value string is stateValueN.
    :type state_value_n: str
    """

    _attribute_map = {
        'state_value1': {'key': 'stateValue1', 'type': 'str'},
        'state_value2': {'key': 'stateValue2', 'type': 'str'},
        'state_value_n': {'key': 'stateValueN', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        state_value1: Optional[str] = None,
        state_value2: Optional[str] = None,
        state_value_n: Optional[str] = None,
        **kwargs
    ):
        super(StringRuleObject, self).__init__(**kwargs)
        self.state_value1 = state_value1
        self.state_value2 = state_value2
        self.state_value_n = state_value_n


class StringTypeStyleRule(StyleRuleBase):
    """The string type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "number", "boolean", "string".
    :type type: str or ~azure.maps.service.models.StyleRuleBaseType
    :param rules: String style rules.
    :type rules: list[~azure.maps.service.models.StringRuleObject]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[StringRuleObject]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: Optional[List["StringRuleObject"]] = None,
        **kwargs
    ):
        super(StringTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'StringTypeStyleRule'  # type: str
        self.rules = rules


class StylesObject(msrest.serialization.Model):
    """The styles model.

    :param styles: An array of stateset styles. The style rule could be a numeric or string or a
     boolean type style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject
     definitions `here <https://aka.ms/AzureMapsStatesetStylesObject>`_.
    :type styles: list[object]
    """

    _attribute_map = {
        'styles': {'key': 'styles', 'type': '[object]'},
    }

    def __init__(
        self,
        *,
        styles: Optional[List[object]] = None,
        **kwargs
    ):
        super(StylesObject, self).__init__(**kwargs)
        self.styles = styles


class SunGlare(msrest.serialization.Model):
    """A rating that indicates how blinding the sun is for the driver.

    :param calculated_vehicle_heading: If the vehicle heading value is not provided for a waypoint,
     then the service will calculate a heading based upon the location of neighboring waypoints if
     provided.
    :type calculated_vehicle_heading: int
    :param glare_index: An index from 0 to 100 indicating sun glare intensity for a driver. A value
     of 50 and above can be considered a hazard for some drivers and a value of 100 signifies the
     driver is driving straight into the sun and atmospheric conditions are clear allowing for the
     full intensity of the sun to blind the driver.
    :type glare_index: int
    """

    _attribute_map = {
        'calculated_vehicle_heading': {'key': 'calculatedVehicleHeading', 'type': 'int'},
        'glare_index': {'key': 'glareIndex', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        calculated_vehicle_heading: Optional[int] = None,
        glare_index: Optional[int] = None,
        **kwargs
    ):
        super(SunGlare, self).__init__(**kwargs)
        self.calculated_vehicle_heading = calculated_vehicle_heading
        self.glare_index = glare_index


class TemperatureSummary(msrest.serialization.Model):
    """TemperatureSummary.

    :param past6_hours: Summary of temperature fluctuations over the past 6 hours.
    :type past6_hours: ~azure.maps.service.models.TemperatureSummaryPast6Hours
    :param past12_hours: Summary of temperature fluctuations over the past 12 hours.
    :type past12_hours: ~azure.maps.service.models.TemperatureSummaryPast12Hours
    :param past24_hours: Summary of temperature fluctuations over the past 24 hours.
    :type past24_hours: ~azure.maps.service.models.TemperatureSummaryPast24Hours
    """

    _attribute_map = {
        'past6_hours': {'key': 'past6Hours', 'type': 'TemperatureSummaryPast6Hours'},
        'past12_hours': {'key': 'past12Hours', 'type': 'TemperatureSummaryPast12Hours'},
        'past24_hours': {'key': 'past24Hours', 'type': 'TemperatureSummaryPast24Hours'},
    }

    def __init__(
        self,
        *,
        past6_hours: Optional["TemperatureSummaryPast6Hours"] = None,
        past12_hours: Optional["TemperatureSummaryPast12Hours"] = None,
        past24_hours: Optional["TemperatureSummaryPast24Hours"] = None,
        **kwargs
    ):
        super(TemperatureSummary, self).__init__(**kwargs)
        self.past6_hours = past6_hours
        self.past12_hours = past12_hours
        self.past24_hours = past24_hours


class TemperatureSummaryPast12Hours(msrest.serialization.Model):
    """Summary of temperature fluctuations over the past 12 hours.

    :param minimum: minimum.
    :type minimum: ~azure.maps.service.models.WeatherUnit
    :param maximum: maximum.
    :type maximum: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'WeatherUnit'},
        'maximum': {'key': 'maximum', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        minimum: Optional["WeatherUnit"] = None,
        maximum: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(TemperatureSummaryPast12Hours, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum


class TemperatureSummaryPast24Hours(msrest.serialization.Model):
    """Summary of temperature fluctuations over the past 24 hours.

    :param minimum: minimum.
    :type minimum: ~azure.maps.service.models.WeatherUnit
    :param maximum: maximum.
    :type maximum: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'WeatherUnit'},
        'maximum': {'key': 'maximum', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        minimum: Optional["WeatherUnit"] = None,
        maximum: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(TemperatureSummaryPast24Hours, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum


class TemperatureSummaryPast6Hours(msrest.serialization.Model):
    """Summary of temperature fluctuations over the past 6 hours.

    :param minimum: minimum.
    :type minimum: ~azure.maps.service.models.WeatherUnit
    :param maximum: maximum.
    :type maximum: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'WeatherUnit'},
        'maximum': {'key': 'maximum', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        minimum: Optional["WeatherUnit"] = None,
        maximum: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(TemperatureSummaryPast6Hours, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum


class Tickets(msrest.serialization.Model):
    """An array describing the individual prices of each of the tickets that the user is expected to purchase throughout this itinerary. The list isn’t ordered.

    :param amount: Price of the ticket in cents. For example, $5.00 is returned as ‘500’.
    :type amount: int
    :param currency_code: Currency code, for example for US dollars “USD”.
    :type currency_code: str
    """

    _attribute_map = {
        'amount': {'key': 'amount', 'type': 'int'},
        'currency_code': {'key': 'currencyCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        amount: Optional[int] = None,
        currency_code: Optional[str] = None,
        **kwargs
    ):
        super(Tickets, self).__init__(**kwargs)
        self.amount = amount
        self.currency_code = currency_code


class TilesetDetailInfo(msrest.serialization.Model):
    """Detail information for the data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tileset_id: The unique tileset id for the tileset.
    :vartype tileset_id: str
    :ivar dataset_id: The unique dataset Id used to create the tileset.
    :vartype dataset_id: str
    :ivar description: The description the caller provided when creating the tileset. Maximum
     length 1024 characters.
    :vartype description: str
    :ivar min_zoom: The lowest tile zoom level tile generated for the tileset.
    :vartype min_zoom: int
    :ivar max_zoom: The highest tile zoom level tile generated for the tileset.
    :vartype max_zoom: int
    :ivar bbox: Bounding box which all features of the tileset lay within. Projection used -
     EPSG:3857. Format : 'minLon, minLat, maxLon, maxLat'.
    :vartype bbox: list[float]
    """

    _validation = {
        'tileset_id': {'readonly': True},
        'dataset_id': {'readonly': True},
        'description': {'readonly': True},
        'min_zoom': {'readonly': True},
        'max_zoom': {'readonly': True},
        'bbox': {'readonly': True},
    }

    _attribute_map = {
        'tileset_id': {'key': 'tilesetId', 'type': 'str'},
        'dataset_id': {'key': 'datasetId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'min_zoom': {'key': 'minZoom', 'type': 'int'},
        'max_zoom': {'key': 'maxZoom', 'type': 'int'},
        'bbox': {'key': 'bbox', 'type': '[float]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TilesetDetailInfo, self).__init__(**kwargs)
        self.tileset_id = None
        self.dataset_id = None
        self.description = None
        self.min_zoom = None
        self.max_zoom = None
        self.bbox = None


class TilesetListResponse(msrest.serialization.Model):
    """The response model for the Tileset List API. Returns a list of all tilesets.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tilesets: A list of all tilesets.
    :vartype tilesets: list[~azure.maps.service.models.TilesetDetailInfo]
    """

    _validation = {
        'tilesets': {'readonly': True},
    }

    _attribute_map = {
        'tilesets': {'key': 'tilesets', 'type': '[TilesetDetailInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TilesetListResponse, self).__init__(**kwargs)
        self.tilesets = None


class TimeTransition(msrest.serialization.Model):
    """TimeTransition.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tag: Tag property.
    :vartype tag: str
    :ivar standard_offset: StandardOffset property.
    :vartype standard_offset: str
    :ivar daylight_savings: DaylightSavings property.
    :vartype daylight_savings: str
    :ivar utc_start: Start date, start time for this transition period.
    :vartype utc_start: ~datetime.datetime
    :ivar utc_end: End date, end time for this transition period.
    :vartype utc_end: ~datetime.datetime
    """

    _validation = {
        'tag': {'readonly': True},
        'standard_offset': {'readonly': True},
        'daylight_savings': {'readonly': True},
        'utc_start': {'readonly': True},
        'utc_end': {'readonly': True},
    }

    _attribute_map = {
        'tag': {'key': 'Tag', 'type': 'str'},
        'standard_offset': {'key': 'StandardOffset', 'type': 'str'},
        'daylight_savings': {'key': 'DaylightSavings', 'type': 'str'},
        'utc_start': {'key': 'UtcStart', 'type': 'iso-8601'},
        'utc_end': {'key': 'UtcEnd', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TimeTransition, self).__init__(**kwargs)
        self.tag = None
        self.standard_offset = None
        self.daylight_savings = None
        self.utc_start = None
        self.utc_end = None


class TimeZoneByCoordinates(msrest.serialization.Model):
    """TimeZoneByCoordinates.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Id property.
    :vartype id: str
    :ivar aliases: An array of time zone ID aliases.  Only returned when [options]=\ *zoneinfo* or
     *all*.
    
     Note: may be null.
    :vartype aliases: list[str]
    :ivar countries: An array of country records. Only returned when [options]=\ *zoneinfo* or
     *all*.
    :vartype countries: list[~azure.maps.service.models.Country]
    :param names: Timezone names object.
    :type names: ~azure.maps.service.models.Names
    :ivar reference_time: Details in effect at the local time.
    :vartype reference_time: ~azure.maps.service.models.ReferenceTimeByCoordinates
    :ivar representative_point: Representative point property.
    :vartype representative_point: ~azure.maps.service.models.RepresentativePoint
    :ivar time_transitions: Time zone DST transitions from [transitionsFrom] until timestamp + 1
     year.
    :vartype time_transitions: list[~azure.maps.service.models.TimeTransition]
    """

    _validation = {
        'id': {'readonly': True},
        'aliases': {'readonly': True},
        'countries': {'readonly': True},
        'reference_time': {'readonly': True},
        'representative_point': {'readonly': True},
        'time_transitions': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'aliases': {'key': 'Aliases', 'type': '[str]'},
        'countries': {'key': 'Countries', 'type': '[Country]'},
        'names': {'key': 'Names', 'type': 'Names'},
        'reference_time': {'key': 'ReferenceTime', 'type': 'ReferenceTimeByCoordinates'},
        'representative_point': {'key': 'RepresentativePoint', 'type': 'RepresentativePoint'},
        'time_transitions': {'key': 'TimeTransitions', 'type': '[TimeTransition]'},
    }

    def __init__(
        self,
        *,
        names: Optional["Names"] = None,
        **kwargs
    ):
        super(TimeZoneByCoordinates, self).__init__(**kwargs)
        self.id = None
        self.aliases = None
        self.countries = None
        self.names = names
        self.reference_time = None
        self.representative_point = None
        self.time_transitions = None


class TimezoneByCoordinatesResult(msrest.serialization.Model):
    """This object is returned from a successful Timezone By Coordinates call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar version: Version property.
    :vartype version: str
    :ivar reference_utc_timestamp: Reference Utc Timestamp property.
    :vartype reference_utc_timestamp: ~datetime.datetime
    :ivar time_zones: TimeZoneByCoordinates array.
    :vartype time_zones: list[~azure.maps.service.models.TimeZoneByCoordinates]
    """

    _validation = {
        'version': {'readonly': True},
        'reference_utc_timestamp': {'readonly': True},
        'time_zones': {'readonly': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'reference_utc_timestamp': {'key': 'ReferenceUtcTimestamp', 'type': 'iso-8601'},
        'time_zones': {'key': 'TimeZones', 'type': '[TimeZoneByCoordinates]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TimezoneByCoordinatesResult, self).__init__(**kwargs)
        self.version = None
        self.reference_utc_timestamp = None
        self.time_zones = None


class TimezoneById(msrest.serialization.Model):
    """TimezoneById.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Id property.
    :vartype id: str
    :ivar aliases: An array of time zone ID aliases.  Only returned when [options]=\ *zoneinfo* or
     *all*.
    
     Note: may be null.
    :vartype aliases: list[str]
    :ivar countries: An array of country records. Only returned when [options]=\ *zoneinfo* or
     *all*.
    :vartype countries: list[~azure.maps.service.models.Country]
    :param names: Timezone names object.
    :type names: ~azure.maps.service.models.Names
    :ivar reference_time: Details in effect at the local time.
    :vartype reference_time: ~azure.maps.service.models.ReferenceTimeById
    :ivar representative_point: Representative point property.
    :vartype representative_point: ~azure.maps.service.models.RepresentativePoint
    :ivar time_transitions: Time zone DST transitions from [transitionsFrom] until timestamp + 1
     year.
    :vartype time_transitions: list[~azure.maps.service.models.TimeTransition]
    """

    _validation = {
        'id': {'readonly': True},
        'aliases': {'readonly': True},
        'countries': {'readonly': True},
        'reference_time': {'readonly': True},
        'representative_point': {'readonly': True},
        'time_transitions': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'aliases': {'key': 'Aliases', 'type': '[str]'},
        'countries': {'key': 'Countries', 'type': '[Country]'},
        'names': {'key': 'Names', 'type': 'Names'},
        'reference_time': {'key': 'ReferenceTime', 'type': 'ReferenceTimeById'},
        'representative_point': {'key': 'RepresentativePoint', 'type': 'RepresentativePoint'},
        'time_transitions': {'key': 'TimeTransitions', 'type': '[TimeTransition]'},
    }

    def __init__(
        self,
        *,
        names: Optional["Names"] = None,
        **kwargs
    ):
        super(TimezoneById, self).__init__(**kwargs)
        self.id = None
        self.aliases = None
        self.countries = None
        self.names = names
        self.reference_time = None
        self.representative_point = None
        self.time_transitions = None


class TimezoneByIdResult(msrest.serialization.Model):
    """This object is returned from a successful Timezone By ID call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar version: Version property.
    :vartype version: str
    :ivar reference_utc_timestamp: Reference Utc Timestamp property.
    :vartype reference_utc_timestamp: ~datetime.datetime
    :ivar time_zones: TimeZoneById array.
    :vartype time_zones: list[~azure.maps.service.models.TimezoneById]
    """

    _validation = {
        'version': {'readonly': True},
        'reference_utc_timestamp': {'readonly': True},
        'time_zones': {'readonly': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'reference_utc_timestamp': {'key': 'ReferenceUtcTimestamp', 'type': 'iso-8601'},
        'time_zones': {'key': 'TimeZones', 'type': '[TimezoneById]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TimezoneByIdResult, self).__init__(**kwargs)
        self.version = None
        self.reference_utc_timestamp = None
        self.time_zones = None


class TimezoneEnumWindow(msrest.serialization.Model):
    """TimezoneEnumWindow.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar windows_id: Windows Id property.
    :vartype windows_id: str
    :ivar territory: Territory property.
    :vartype territory: str
    :param iana_ids: IanaIds array.
    :type iana_ids: list[str]
    """

    _validation = {
        'windows_id': {'readonly': True},
        'territory': {'readonly': True},
    }

    _attribute_map = {
        'windows_id': {'key': 'WindowsId', 'type': 'str'},
        'territory': {'key': 'Territory', 'type': 'str'},
        'iana_ids': {'key': 'IanaIds', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        iana_ids: Optional[List[str]] = None,
        **kwargs
    ):
        super(TimezoneEnumWindow, self).__init__(**kwargs)
        self.windows_id = None
        self.territory = None
        self.iana_ids = iana_ids


class TimezoneIanaVersionResult(msrest.serialization.Model):
    """This object is returned from a successful Timezone IANA Version call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar version: Version property.
    :vartype version: str
    """

    _validation = {
        'version': {'readonly': True},
    }

    _attribute_map = {
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TimezoneIanaVersionResult, self).__init__(**kwargs)
        self.version = None


class TrafficFlowSegmentResult(msrest.serialization.Model):
    """This object is returned from a successful Traffic Flow Segment call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar flow_segment_data: Flow Segment Data property.
    :vartype flow_segment_data: ~azure.maps.service.models.TrafficFlowSegmentResultFlowSegmentData
    """

    _validation = {
        'flow_segment_data': {'readonly': True},
    }

    _attribute_map = {
        'flow_segment_data': {'key': 'flowSegmentData', 'type': 'TrafficFlowSegmentResultFlowSegmentData'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficFlowSegmentResult, self).__init__(**kwargs)
        self.flow_segment_data = None


class TrafficFlowSegmentResultFlowSegmentData(msrest.serialization.Model):
    """Flow Segment Data property.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar frc: Functional Road Class. This indicates the road type:
       0: Motorway, freeway or other major road.
       1: Major road, less important than a motorway.
       2: Other major road.
       3: Secondary road.
       4: Local connecting road.
       5: Local road of high importance.
       6: Local road.
    :vartype frc: str
    :ivar current_speed: The current average speed at the selected point, in the units requested.
     This is calculated from the currentTravelTime and the length of the selected segment.
    :vartype current_speed: int
    :ivar free_flow_speed: The free flow speed expected under ideal conditions, expressed in the
     units requested. This is related to the freeFlowTravelTime.
    :vartype free_flow_speed: int
    :ivar current_travel_time: Current travel time in seconds based on fused real-time measurements
     between the defined locations in the specified direction.
    :vartype current_travel_time: int
    :ivar free_flow_travel_time: The travel time in seconds which would be expected under ideal
     free flow conditions.
    :vartype free_flow_travel_time: int
    :ivar confidence: The confidence is a measure of the quality of the provided travel time and
     speed. A value of 1 means full confidence, that the response contains the highest quality data.
     Lower values indicate the degree that the response may vary from the actual conditions on the
     road. Any value greater than 0.6 means the information was based on real-time probe input. A
     value of 0.5 means the reported speed is based on historical info.   A value between 0.5 and
     0.6 has a calculated weighted average between historical and live speeds.
    :vartype confidence: float
    :param coordinates: Includes the coordinates describing the shape of the segment. Coordinates
     are shifted from the road depending on the zoom level to support high quality visualization in
     every scale.
    :type coordinates:
     ~azure.maps.service.models.TrafficFlowSegmentResultFlowSegmentDataCoordinates
    :ivar version: This indicates the software version that generated the response.
    :vartype version: str
    :ivar openlr: OpenLR code for segment.
    :vartype openlr: float
    """

    _validation = {
        'frc': {'readonly': True},
        'current_speed': {'readonly': True},
        'free_flow_speed': {'readonly': True},
        'current_travel_time': {'readonly': True},
        'free_flow_travel_time': {'readonly': True},
        'confidence': {'readonly': True},
        'version': {'readonly': True},
        'openlr': {'readonly': True},
    }

    _attribute_map = {
        'frc': {'key': 'frc', 'type': 'str'},
        'current_speed': {'key': 'currentSpeed', 'type': 'int'},
        'free_flow_speed': {'key': 'freeFlowSpeed', 'type': 'int'},
        'current_travel_time': {'key': 'currentTravelTime', 'type': 'int'},
        'free_flow_travel_time': {'key': 'freeFlowTravelTime', 'type': 'int'},
        'confidence': {'key': 'confidence', 'type': 'float'},
        'coordinates': {'key': 'coordinates', 'type': 'TrafficFlowSegmentResultFlowSegmentDataCoordinates'},
        'version': {'key': '@version', 'type': 'str'},
        'openlr': {'key': 'openlr', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        coordinates: Optional["TrafficFlowSegmentResultFlowSegmentDataCoordinates"] = None,
        **kwargs
    ):
        super(TrafficFlowSegmentResultFlowSegmentData, self).__init__(**kwargs)
        self.frc = None
        self.current_speed = None
        self.free_flow_speed = None
        self.current_travel_time = None
        self.free_flow_travel_time = None
        self.confidence = None
        self.coordinates = coordinates
        self.version = None
        self.openlr = None


class TrafficFlowSegmentResultFlowSegmentDataCoordinates(msrest.serialization.Model):
    """Includes the coordinates describing the shape of the segment. Coordinates are shifted from the road depending on the zoom level to support high quality visualization in every scale.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar coordinate: Coordinate array.
    :vartype coordinate: list[~azure.maps.service.models.Coordinate]
    """

    _validation = {
        'coordinate': {'readonly': True},
    }

    _attribute_map = {
        'coordinate': {'key': 'coordinate', 'type': '[Coordinate]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficFlowSegmentResultFlowSegmentDataCoordinates, self).__init__(**kwargs)
        self.coordinate = None


class TrafficIncidentDetailResult(msrest.serialization.Model):
    """This object is returned from a successful Traffic incident Detail call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tm: Main response element.
    :vartype tm: ~azure.maps.service.models.TrafficIncidentDetailResultTm
    """

    _validation = {
        'tm': {'readonly': True},
    }

    _attribute_map = {
        'tm': {'key': 'tm', 'type': 'TrafficIncidentDetailResultTm'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentDetailResult, self).__init__(**kwargs)
        self.tm = None


class TrafficIncidentDetailResultTm(msrest.serialization.Model):
    """Main response element.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: ID of the traffic incident.
    :vartype id: str
    :ivar poi: A single traffic incident, or a cluster of traffic incidents.
    :vartype poi: list[~azure.maps.service.models.TrafficIncidentPoi]
    """

    _validation = {
        'id': {'readonly': True},
        'poi': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': '@id', 'type': 'str'},
        'poi': {'key': 'poi', 'type': '[TrafficIncidentPoi]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentDetailResultTm, self).__init__(**kwargs)
        self.id = None
        self.poi = None


class TrafficIncidentPoi(msrest.serialization.Model):
    """TrafficIncidentPoi.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: ID of the traffic incident.
    :vartype id: str
    :ivar p: The point where an icon of the cluster or raw incident should be drawn, expressed in
     the requested projection. This is affected by traffic style, zoom level and road type.
    :vartype p: ~azure.maps.service.models.TrafficIncidentPoiP
    :ivar ic: The icon category associated with this incident. Values are numbers in the range
     0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions,
     4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding,
     12: Detour, 13: Cluster.
    :vartype ic: int
    :ivar ty: The magnitude of delay associated with incident. These values correspond to incident
     colors in the traffic tiles.
    :vartype ty: int
    :ivar cbl: Bottom left coordinate of the cluster in the projection of the request.
    :vartype cbl: ~azure.maps.service.models.TrafficIncidentPoiCbl
    :ivar ctr: Top right coordinate of the cluster in the projection of the request.
    :vartype ctr: ~azure.maps.service.models.TrafficIncidentPoiCtr
    :ivar cs: Cluster size: the number of incidents in the cluster.
    :vartype cs: int
    :ivar l: Length of the incident in meters.
    :vartype l: int
    :ivar r: The road number(s) affected by the incident. Multiple road numbers will delimited by
     slashes.
    :vartype r: str
    :ivar dl: Delay caused by the incident in seconds (except in road closures).
    :vartype dl: int
    :ivar t: To: the name of the intersection or location where the traffic due to the incident
     ends.
    :vartype t: str
    :ivar f: From: the name of the intersection or location where the traffic due to the incident
     starts.
    :vartype f: str
    :ivar d: Description of the incident in the language requested.
    :vartype d: str
    :ivar c: Cause of the incident, where available, in the language requested.
    :vartype c: str
    """

    _validation = {
        'id': {'readonly': True},
        'p': {'readonly': True},
        'ic': {'readonly': True},
        'ty': {'readonly': True},
        'cbl': {'readonly': True},
        'ctr': {'readonly': True},
        'cs': {'readonly': True},
        'l': {'readonly': True},
        'r': {'readonly': True},
        'dl': {'readonly': True},
        't': {'readonly': True},
        'f': {'readonly': True},
        'd': {'readonly': True},
        'c': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'p': {'key': 'p', 'type': 'TrafficIncidentPoiP'},
        'ic': {'key': 'ic', 'type': 'int'},
        'ty': {'key': 'ty', 'type': 'int'},
        'cbl': {'key': 'cbl', 'type': 'TrafficIncidentPoiCbl'},
        'ctr': {'key': 'ctr', 'type': 'TrafficIncidentPoiCtr'},
        'cs': {'key': 'cs', 'type': 'int'},
        'l': {'key': 'l', 'type': 'int'},
        'r': {'key': 'r', 'type': 'str'},
        'dl': {'key': 'dl', 'type': 'int'},
        't': {'key': 't', 'type': 'str'},
        'f': {'key': 'f', 'type': 'str'},
        'd': {'key': 'd', 'type': 'str'},
        'c': {'key': 'c', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentPoi, self).__init__(**kwargs)
        self.id = None
        self.p = None
        self.ic = None
        self.ty = None
        self.cbl = None
        self.ctr = None
        self.cs = None
        self.l = None
        self.r = None
        self.dl = None
        self.t = None
        self.f = None
        self.d = None
        self.c = None


class TrafficIncidentPoiCbl(msrest.serialization.Model):
    """Bottom left coordinate of the cluster in the projection of the request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar x: x coordinate.
    :vartype x: float
    :ivar y: y coordinate.
    :vartype y: float
    """

    _validation = {
        'x': {'readonly': True},
        'y': {'readonly': True},
    }

    _attribute_map = {
        'x': {'key': 'x', 'type': 'float'},
        'y': {'key': 'y', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentPoiCbl, self).__init__(**kwargs)
        self.x = None
        self.y = None


class TrafficIncidentPoiCtr(msrest.serialization.Model):
    """Top right coordinate of the cluster in the projection of the request.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar x: x coordinate.
    :vartype x: float
    :ivar y: y coordinate.
    :vartype y: float
    """

    _validation = {
        'x': {'readonly': True},
        'y': {'readonly': True},
    }

    _attribute_map = {
        'x': {'key': 'x', 'type': 'float'},
        'y': {'key': 'y', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentPoiCtr, self).__init__(**kwargs)
        self.x = None
        self.y = None


class TrafficIncidentPoiP(msrest.serialization.Model):
    """The point where an icon of the cluster or raw incident should be drawn, expressed in the requested projection. This is affected by traffic style, zoom level and road type.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar x: x coordinate.
    :vartype x: float
    :ivar y: y coordinate.
    :vartype y: float
    """

    _validation = {
        'x': {'readonly': True},
        'y': {'readonly': True},
    }

    _attribute_map = {
        'x': {'key': 'x', 'type': 'float'},
        'y': {'key': 'y', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentPoiP, self).__init__(**kwargs)
        self.x = None
        self.y = None


class TrafficIncidentTileResult(msrest.serialization.Model):
    """This object is returned from a successful Traffic Incident Tile call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar image: Image property.
    :vartype image: str
    """

    _validation = {
        'image': {'readonly': True},
    }

    _attribute_map = {
        'image': {'key': 'image', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentTileResult, self).__init__(**kwargs)
        self.image = None


class TrafficIncidentViewportResult(msrest.serialization.Model):
    """This object is returned from a successful Traffic Incident Viewport call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar viewp_resp: Viewport Response object.
    :vartype viewp_resp: ~azure.maps.service.models.TrafficIncidentViewportResultViewpResp
    """

    _validation = {
        'viewp_resp': {'readonly': True},
    }

    _attribute_map = {
        'viewp_resp': {'key': 'viewpResp', 'type': 'TrafficIncidentViewportResultViewpResp'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentViewportResult, self).__init__(**kwargs)
        self.viewp_resp = None


class TrafficIncidentViewportResultViewpResp(msrest.serialization.Model):
    """Viewport Response object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar traffic_state: Traffic State array.
    :vartype traffic_state:
     ~azure.maps.service.models.TrafficIncidentViewportResultViewpRespTrafficState
    :ivar copyright_ids: Copyright Ids property.
    :vartype copyright_ids: str
    :ivar version: @Version property.
    :vartype version: str
    :ivar maps: @maps property.
    :vartype maps: str
    """

    _validation = {
        'traffic_state': {'readonly': True},
        'copyright_ids': {'readonly': True},
        'version': {'readonly': True},
        'maps': {'readonly': True},
    }

    _attribute_map = {
        'traffic_state': {'key': 'trafficState', 'type': 'TrafficIncidentViewportResultViewpRespTrafficState'},
        'copyright_ids': {'key': 'copyrightIds', 'type': 'str'},
        'version': {'key': '@version', 'type': 'str'},
        'maps': {'key': '@maps', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentViewportResultViewpResp, self).__init__(**kwargs)
        self.traffic_state = None
        self.copyright_ids = None
        self.version = None
        self.maps = None


class TrafficIncidentViewportResultViewpRespTrafficState(msrest.serialization.Model):
    """Traffic State array.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar traffic_age: @Traffic Age property.
    :vartype traffic_age: int
    :ivar traffic_model_id: @Traffic Model Id property.
    :vartype traffic_model_id: str
    """

    _validation = {
        'traffic_age': {'readonly': True},
        'traffic_model_id': {'readonly': True},
    }

    _attribute_map = {
        'traffic_age': {'key': '@trafficAge', 'type': 'int'},
        'traffic_model_id': {'key': '@trafficModelId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TrafficIncidentViewportResultViewpRespTrafficState, self).__init__(**kwargs)
        self.traffic_age = None
        self.traffic_model_id = None


class TransitItineraryResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Itinerary call.

    :param departure_time: The date and time of departure from the origin point in ISO 8601 format,
     e.g. 1996-12-19T16:39:57-08:00.
    :type departure_time: str
    :param arrival_time: The date and time of arrival at the destination point in ISO 8601 format,
     e.g. 1996-12-19T19:39:57-08:00.
    :type arrival_time: str
    :param legs: An array summarizing the legs of this itinerary.
    :type legs: list[~azure.maps.service.models.Leg]
    :param itinerary_fare: Itinerary level transit fare information. Returned only if fare
     information is available for the entire itinerary. `Get Metro Area Info API
     <https://aka.ms/AzureMapsMobilityMetroAreaInfo>`_ can be requested to confirm if fare
     information is available in the metro area.
    :type itinerary_fare: ~azure.maps.service.models.ItineraryFare
    """

    _attribute_map = {
        'departure_time': {'key': 'departureTime', 'type': 'str'},
        'arrival_time': {'key': 'arrivalTime', 'type': 'str'},
        'legs': {'key': 'legs', 'type': '[Leg]'},
        'itinerary_fare': {'key': 'itineraryFare', 'type': 'ItineraryFare'},
    }

    def __init__(
        self,
        *,
        departure_time: Optional[str] = None,
        arrival_time: Optional[str] = None,
        legs: Optional[List["Leg"]] = None,
        itinerary_fare: Optional["ItineraryFare"] = None,
        **kwargs
    ):
        super(TransitItineraryResponse, self).__init__(**kwargs)
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.legs = legs
        self.itinerary_fare = itinerary_fare


class TransitLineInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Transit Line Info call.

    :param line_group: Groups together all lines that are logically part of the same group.
     Typically contains 2 lines having the same agency and line, one going from A to B, and the
     other from B to A.
    :type line_group: ~azure.maps.service.models.LineGroup
    :param lines: The line group’s basic info and list of the lines.
    :type lines: list[~azure.maps.service.models.Line]
    :param stops: List of stops the line group goes through.
    :type stops: list[~azure.maps.service.models.Stop]
    :param patterns: List of patterns this group is comprised of. A pattern consists of a stop
     sequence and shape per a line in GeoJSON format.
    :type patterns: list[~azure.maps.service.models.Pattern]
    :param schedule: Line schedule for the current 24h. May be null in case no schedule exists for
     the current time.
    :type schedule: ~azure.maps.service.models.LineArrival
    """

    _attribute_map = {
        'line_group': {'key': 'lineGroup', 'type': 'LineGroup'},
        'lines': {'key': 'lines', 'type': '[Line]'},
        'stops': {'key': 'stops', 'type': '[Stop]'},
        'patterns': {'key': 'patterns', 'type': '[Pattern]'},
        'schedule': {'key': 'schedule', 'type': 'LineArrival'},
    }

    def __init__(
        self,
        *,
        line_group: Optional["LineGroup"] = None,
        lines: Optional[List["Line"]] = None,
        stops: Optional[List["Stop"]] = None,
        patterns: Optional[List["Pattern"]] = None,
        schedule: Optional["LineArrival"] = None,
        **kwargs
    ):
        super(TransitLineInfoResponse, self).__init__(**kwargs)
        self.line_group = line_group
        self.lines = lines
        self.stops = stops
        self.patterns = patterns
        self.schedule = schedule


class TransitObjectResult(msrest.serialization.Model):
    """TransitObjectResult.

    :param id: The unique identifier (stopID) for the returned public transit stop. When referring
     to public transit stops over time, it is recommended to use ``stopId`` since it will not
     change, as long as the physical stop exists.
    :type id: str
    :param type: The type of object found as a result of the query.
    :type type: str
    :param object_details: The object specific details.
    :type object_details: object
    :param position: The transit object's position.
    :type position: ~azure.maps.service.models.Coordinate
    :param viewport: The viewport that covers the result represented by the top-left and bottom-
     right coordinates of the  viewport.
    :type viewport: ~azure.maps.service.models.ResultViewport
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'object_details': {'key': 'objectDetails', 'type': 'object'},
        'position': {'key': 'position', 'type': 'Coordinate'},
        'viewport': {'key': 'viewport', 'type': 'ResultViewport'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        type: Optional[str] = None,
        object_details: Optional[object] = None,
        position: Optional["Coordinate"] = None,
        viewport: Optional["ResultViewport"] = None,
        **kwargs
    ):
        super(TransitObjectResult, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.object_details = object_details
        self.position = position
        self.viewport = viewport


class TransitRouteResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Stop Info call.

    :param results:
    :type results: list[~azure.maps.service.models.ItineraryResult]
    """

    _attribute_map = {
        'results': {'key': 'results', 'type': '[ItineraryResult]'},
    }

    def __init__(
        self,
        *,
        results: Optional[List["ItineraryResult"]] = None,
        **kwargs
    ):
        super(TransitRouteResponse, self).__init__(**kwargs)
        self.results = results


class TransitStopInfoResponse(msrest.serialization.Model):
    """This object is returned from a successful Get Transit Stop Info call.

    :param stop: The stop's basic info.
    :type stop: ~azure.maps.service.models.Stop
    :param lines: A list of stop lines.
    :type lines: list[~azure.maps.service.models.Line]
    :param line_groups: A list of line groups.
    :type line_groups: list[~azure.maps.service.models.LineGroup]
    :param alerts: A list of stop alerts.
    :type alerts: list[~azure.maps.service.models.Alert]
    """

    _attribute_map = {
        'stop': {'key': 'stop', 'type': 'Stop'},
        'lines': {'key': 'lines', 'type': '[Line]'},
        'line_groups': {'key': 'lineGroups', 'type': '[LineGroup]'},
        'alerts': {'key': 'alerts', 'type': '[Alert]'},
    }

    def __init__(
        self,
        *,
        stop: Optional["Stop"] = None,
        lines: Optional[List["Line"]] = None,
        line_groups: Optional[List["LineGroup"]] = None,
        alerts: Optional[List["Alert"]] = None,
        **kwargs
    ):
        super(TransitStopInfoResponse, self).__init__(**kwargs)
        self.stop = stop
        self.lines = lines
        self.line_groups = line_groups
        self.alerts = alerts


class TransitTypeResult(msrest.serialization.Model):
    """TransitTypeResult.

    :param transit_type: Supported public transit type. Returned if specified in the request.
     Possible values include: "Bus", "CableCar", "Ferry", "Funicular", "Gondola", "Rail", "Tram",
     "Subway".
    :type transit_type: str or ~azure.maps.service.models.TransitType
    :param caption_override: For metro areas in which local name is different than the GTFS
     supported transit type, original name is returned.
    :type caption_override: str
    """

    _attribute_map = {
        'transit_type': {'key': 'transitType', 'type': 'str'},
        'caption_override': {'key': 'captionOverride', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        transit_type: Optional[Union[str, "TransitType"]] = None,
        caption_override: Optional[str] = None,
        **kwargs
    ):
        super(TransitTypeResult, self).__init__(**kwargs)
        self.transit_type = transit_type
        self.caption_override = caption_override


class UploadDataAcceptedResponse(msrest.serialization.Model):
    """The response model for the spatial data upload API. Returns the current status and a status URI.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar status: Current status of the long running upload operation.
    :vartype status: str
    """

    _validation = {
        'status': {'readonly': True},
    }

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UploadDataAcceptedResponse, self).__init__(**kwargs)
        self.status = None


class UploadDataResponse(msrest.serialization.Model):
    """The response model for the spatial data upload API. Returns a unique data id (udid) for the uploaded content.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: A unique data id (udid) for the uploaded content.
    :vartype udid: str
    """

    _validation = {
        'udid': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UploadDataResponse, self).__init__(**kwargs)
        self.udid = None


class Version(msrest.serialization.Model):
    """Version.

    All required parameters must be populated in order to send to Azure.

    :param version: Required. version number of the dataset.
    :type version: str
    :param revision_timestamp: Required. timestamp of the revision.
    :type revision_timestamp: str
    :param links: Required.
    :type links: list[~azure.maps.service.models.Link]
    """

    _validation = {
        'version': {'required': True},
        'revision_timestamp': {'required': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'version', 'type': 'str'},
        'revision_timestamp': {'key': 'revisionTimestamp', 'type': 'str'},
        'links': {'key': 'links', 'type': '[Link]'},
    }

    def __init__(
        self,
        *,
        version: str,
        revision_timestamp: str,
        links: List["Link"],
        **kwargs
    ):
        super(Version, self).__init__(**kwargs)
        self.version = version
        self.revision_timestamp = revision_timestamp
        self.links = links


class Waypoint(msrest.serialization.Model):
    """Waypoint.

    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param short_phrase: A displayable short phrase describing the forecasted conditions and
     precipitation intensity/type.
    :type short_phrase: str
    :param is_day_time: Indicates the time of the day. True indicates 'day',', false indicates
     'night.
    :type is_day_time: bool
    :param cloud_cover: Percent representing cloud cover.
    :type cloud_cover: int
    :param temperature:
    :type temperature: ~azure.maps.service.models.WeatherUnit
    :param wind: Wind details being returned including speed and direction.
    :type wind: ~azure.maps.service.models.Wind
    :param wind_gust: Wind details being returned including speed and direction.
    :type wind_gust: ~azure.maps.service.models.Wind
    :param precipitation:
    :type precipitation: ~azure.maps.service.models.WeatherAlongRoutePrecipitation
    :param lightning_count: Estimation of thunderstorm intensity on an open scale. A value of 0
     means there is no thunderstorm; values of 1 and higher mean there is a thunderstorm in
     increasing intensity.
    :type lightning_count: int
    :param sun_glare: A rating that indicates how blinding the sun is for the driver.
    :type sun_glare: ~azure.maps.service.models.SunGlare
    :param hazards:
    :type hazards: ~azure.maps.service.models.Hazards
    :param notifications:
    :type notifications: list[~azure.maps.service.models.Notification]
    """

    _attribute_map = {
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'short_phrase': {'key': 'shortPhrase', 'type': 'str'},
        'is_day_time': {'key': 'isDayTime', 'type': 'bool'},
        'cloud_cover': {'key': 'cloudCover', 'type': 'int'},
        'temperature': {'key': 'temperature', 'type': 'WeatherUnit'},
        'wind': {'key': 'wind', 'type': 'Wind'},
        'wind_gust': {'key': 'windGust', 'type': 'Wind'},
        'precipitation': {'key': 'precipitation', 'type': 'WeatherAlongRoutePrecipitation'},
        'lightning_count': {'key': 'lightningCount', 'type': 'int'},
        'sun_glare': {'key': 'sunGlare', 'type': 'SunGlare'},
        'hazards': {'key': 'hazards', 'type': 'Hazards'},
        'notifications': {'key': 'notifications', 'type': '[Notification]'},
    }

    def __init__(
        self,
        *,
        icon_code: Optional[int] = None,
        short_phrase: Optional[str] = None,
        is_day_time: Optional[bool] = None,
        cloud_cover: Optional[int] = None,
        temperature: Optional["WeatherUnit"] = None,
        wind: Optional["Wind"] = None,
        wind_gust: Optional["Wind"] = None,
        precipitation: Optional["WeatherAlongRoutePrecipitation"] = None,
        lightning_count: Optional[int] = None,
        sun_glare: Optional["SunGlare"] = None,
        hazards: Optional["Hazards"] = None,
        notifications: Optional[List["Notification"]] = None,
        **kwargs
    ):
        super(Waypoint, self).__init__(**kwargs)
        self.icon_code = icon_code
        self.short_phrase = short_phrase
        self.is_day_time = is_day_time
        self.cloud_cover = cloud_cover
        self.temperature = temperature
        self.wind = wind
        self.wind_gust = wind_gust
        self.precipitation = precipitation
        self.lightning_count = lightning_count
        self.sun_glare = sun_glare
        self.hazards = hazards
        self.notifications = notifications


class WeatherAlongRoutePrecipitation(msrest.serialization.Model):
    """WeatherAlongRoutePrecipitation.

    :param dbz: The forecasted precipitation intensity in dBZ (decibels relative to Z) from 0.0 to
     100.0.
    :type dbz: float
    :param type: Precipitation type. If precipitation should occur, the type that it will be:
     "RAIN," "HAIL," "SNOW," "ICE," or "MIX.".
    :type type: str
    """

    _attribute_map = {
        'dbz': {'key': 'dbz', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        dbz: Optional[float] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(WeatherAlongRoutePrecipitation, self).__init__(**kwargs)
        self.dbz = dbz
        self.type = type


class WeatherAlongRouteResponse(msrest.serialization.Model):
    """This object is returned from a successful Weather Along Route.

    :param summary:
    :type summary: ~azure.maps.service.models.WeatherAlongRouteSummary
    :param waypoints: Data for each waypoint returned in the same order as specified in the
     request.
    :type waypoints: list[~azure.maps.service.models.Waypoint]
    """

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'WeatherAlongRouteSummary'},
        'waypoints': {'key': 'waypoints', 'type': '[Waypoint]'},
    }

    def __init__(
        self,
        *,
        summary: Optional["WeatherAlongRouteSummary"] = None,
        waypoints: Optional[List["Waypoint"]] = None,
        **kwargs
    ):
        super(WeatherAlongRouteResponse, self).__init__(**kwargs)
        self.summary = summary
        self.waypoints = waypoints


class WeatherAlongRouteSummary(msrest.serialization.Model):
    """WeatherAlongRouteSummary.

    :param icon_code: Numeric value representing an image that displays the ``iconPhrase``. Please
     refer to `Weather Service Concepts <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type icon_code: int
    :param hazards:
    :type hazards: ~azure.maps.service.models.Hazards
    """

    _attribute_map = {
        'icon_code': {'key': 'iconCode', 'type': 'int'},
        'hazards': {'key': 'hazards', 'type': 'Hazards'},
    }

    def __init__(
        self,
        *,
        icon_code: Optional[int] = None,
        hazards: Optional["Hazards"] = None,
        **kwargs
    ):
        super(WeatherAlongRouteSummary, self).__init__(**kwargs)
        self.icon_code = icon_code
        self.hazards = hazards


class WeatherUnit(msrest.serialization.Model):
    """WeatherUnit.

    :param value: Rounded value.
    :type value: float
    :param unit: Type of unit for the returned value.
    :type unit: str
    :param unit_type: Numeric ID value associated with the type of unit being displayed. Can be
     used for unit translation. Please refer to `Weather Service Concepts
     <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type unit_type: int
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
        'unit': {'key': 'unit', 'type': 'str'},
        'unit_type': {'key': 'unitType', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        value: Optional[float] = None,
        unit: Optional[str] = None,
        unit_type: Optional[int] = None,
        **kwargs
    ):
        super(WeatherUnit, self).__init__(**kwargs)
        self.value = value
        self.unit = unit
        self.unit_type = unit_type


class WeatherUnitRange(msrest.serialization.Model):
    """Returned temperature values.

    :param minimum: Minimum temperature for the time period.
    :type minimum: ~azure.maps.service.models.WeatherUnit
    :param maximum: Maximum temperature for the time period.
    :type maximum: ~azure.maps.service.models.WeatherUnit
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'WeatherUnit'},
        'maximum': {'key': 'maximum', 'type': 'WeatherUnit'},
    }

    def __init__(
        self,
        *,
        minimum: Optional["WeatherUnit"] = None,
        maximum: Optional["WeatherUnit"] = None,
        **kwargs
    ):
        super(WeatherUnitRange, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum


class Wind(msrest.serialization.Model):
    """Wind details being returned including speed and direction.

    :param direction: Wind direction.
    :type direction: ~azure.maps.service.models.WindDirection
    :param speed: Speed of the wind in specified unit.
    :type speed: ~azure.maps.service.models.WindSpeed
    """

    _attribute_map = {
        'direction': {'key': 'direction', 'type': 'WindDirection'},
        'speed': {'key': 'speed', 'type': 'WindSpeed'},
    }

    def __init__(
        self,
        *,
        direction: Optional["WindDirection"] = None,
        speed: Optional["WindSpeed"] = None,
        **kwargs
    ):
        super(Wind, self).__init__(**kwargs)
        self.direction = direction
        self.speed = speed


class WindDirection(msrest.serialization.Model):
    """Wind direction.

    :param degrees: Wind direction in Azimuth degrees,  starting at true North and continuing in
     clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270
     degrees. Possible values 0-359.
    :type degrees: int
    :param localized_description: Direction abbreviation in the specified language.
    :type localized_description: str
    """

    _attribute_map = {
        'degrees': {'key': 'degrees', 'type': 'int'},
        'localized_description': {'key': 'localizedDescription', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        degrees: Optional[int] = None,
        localized_description: Optional[str] = None,
        **kwargs
    ):
        super(WindDirection, self).__init__(**kwargs)
        self.degrees = degrees
        self.localized_description = localized_description


class WindSpeed(msrest.serialization.Model):
    """Speed of wind in specified unit.

    :param value: Rounded value of the speed.
    :type value: float
    :param unit: Type of unit for the speed value.
    :type unit: str
    :param unit_type: Numeric ID value associated with the type of unit being displayed. Can be
     used for unit translation. Please refer to `Weather Service Concepts
     <https://aka.ms/AzureMapsWeatherConcepts>`_ for details.
    :type unit_type: int
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
        'unit': {'key': 'unit', 'type': 'str'},
        'unit_type': {'key': 'unitType', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        value: Optional[float] = None,
        unit: Optional[str] = None,
        unit_type: Optional[int] = None,
        **kwargs
    ):
        super(WindSpeed, self).__init__(**kwargs)
        self.value = value
        self.unit = unit
        self.unit_type = unit_type
