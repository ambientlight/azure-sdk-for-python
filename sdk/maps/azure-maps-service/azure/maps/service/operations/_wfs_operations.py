# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models as _models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class WFSOperations(object):
    """WFSOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_landing_page_preview(
        self,
        datasetid,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Root"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Landing Page API provides links to the API definition, the Conformance statements  and
        the metadata about the feature data in this dataset.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Root, or the result of cls(response)
        :rtype: ~azure.maps.service.models.Root
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Root"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_landing_page_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('Root', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('Root', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_landing_page_preview.metadata = {'url': '/wfs/datasets/{datasetid}/'}  # type: ignore

    def get_requirements_classes_preview(
        self,
        datasetid,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ReqClasses"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Requirements Classes lists all requirements classes specified in the standard that the
        server conforms to.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ReqClasses, or the result of cls(response)
        :rtype: ~azure.maps.service.models.ReqClasses
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ReqClasses"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_requirements_classes_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('ReqClasses', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('ReqClasses', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_requirements_classes_preview.metadata = {'url': '/wfs/datasets/{datasetid}/conformance'}  # type: ignore

    def collections_description_preview(
        self,
        datasetid,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Content"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Collections Description API provides descriptions of all the collections in a given
        dataset.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Content, or the result of cls(response)
        :rtype: ~azure.maps.service.models.Content
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Content"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.collections_description_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('Content', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('Content', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    collections_description_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections'}  # type: ignore

    def collection_description_preview(
        self,
        datasetid,  # type: str
        collection_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.CollectionInfo"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Description API provides the description of a given collection. It includes the
        links to the operations that can be performed on the collection.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionInfo, or the result of cls(response)
        :rtype: ~azure.maps.service.models.CollectionInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CollectionInfo"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.collection_description_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('CollectionInfo', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('CollectionInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    collection_description_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections/{collectionId}'}  # type: ignore

    def collection_definition_preview(
        self,
        datasetid,  # type: str
        collection_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.CollectionDefinition"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Definition API provides the detailed data model of a given collection.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionDefinition, or the result of cls(response)
        :rtype: ~azure.maps.service.models.CollectionDefinition
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CollectionDefinition"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.collection_definition_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('CollectionDefinition', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('CollectionDefinition', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    collection_definition_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections/{collectionId}/definition'}  # type: ignore

    def get_features_preview(
        self,
        datasetid,  # type: str
        collection_id,  # type: str
        limit=10,  # type: Optional[float]
        bbox=None,  # type: Optional[str]
        filter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.FeatureCollectionGeoJSON"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Features API returns the list of features in the given collection.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param limit: The optional limit parameter limits the number of features that are presented in
         the response document.
         Only features that are on the first level of the collection in the response document are
         counted. Nested objects contained within the explicitly requested features shall not be
         counted.


         * Minimum = 1 * Maximum = 50 * Default = 10.
        :type limit: float
        :param bbox: Only features that have a geometry that intersects the supplied bounding box are
         selected.


         * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Upper right
         corner, coordinate axis 1 * Upper right corner, coordinate axis 2
           The coordinate reference system of the values is WGS84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system
         is specified in the parameter ``bbox-crs``.
           For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude,
         minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans
         the antimeridian the first value (west-most box edge) is larger than the third value (east-most
         box edge).
        :type bbox: str
        :param filter: Filter expression to search for features with specific property values in a
         given collection. Only feature properties of scalar type and equals operator are supported.
         This is a special parameter where the parameter name is the property name. The scheme for this
         parameter is {property name}={property value}. Unless "filter" is one of the property names in
         the collection, "filter" should not be used as a parameter name. To search for features with
         "name" property value "21N13", use "name=21N13".
         Multiple filters are supported and should be represented as multiple query parameters. E.g.,
         :code:`<property1>`=:code:`<value1>`&:code:`<property2>`=:code:`<value2>` String values are
         case sensitive.
        :type filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FeatureCollectionGeoJSON, or the result of cls(response)
        :rtype: ~azure.maps.service.models.FeatureCollectionGeoJSON
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FeatureCollectionGeoJSON"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_features_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'float', maximum=50, minimum=1)
        if bbox is not None:
            query_parameters['bbox'] = self._serialize.query("bbox", bbox, 'str')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('FeatureCollectionGeoJSON', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('FeatureCollectionGeoJSON', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_features_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections/{collectionId}/items'}  # type: ignore

    def get_feature_preview(
        self,
        datasetid,  # type: str
        collection_id,  # type: str
        feature_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.Feature"
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Feature API returns the feature identified by the provided id in the given collection.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Feature, or the result of cls(response)
        :rtype: ~azure.maps.service.models.Feature
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Feature"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_feature_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('Feature', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('Feature', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_feature_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections/{collectionId}/items/{featureId}'}  # type: ignore

    def delete_feature_preview(
        self,
        datasetid,  # type: str
        collection_id,  # type: str
        feature_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Creator makes it possible to develop applications based on your private indoor  map data using
        Azure Maps API and SDK. The Web Feature Service (WFS) API is part of  Creator. WFS API follows
        the `Open Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Delete Feature API deletes the feature identified by the provided id in the given
        collection. At this point this API supports only facility features. Deleting a facility feature
        deletes all the child features of that facility recursively.

        :param datasetid: The identifier for the dataset to query from.
        :type datasetid: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.delete_feature_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'datasetid': self._serialize.url("datasetid", datasetid, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_feature_preview.metadata = {'url': '/wfs/datasets/{datasetid}/collections/{collectionId}/items/{featureId}'}  # type: ignore
