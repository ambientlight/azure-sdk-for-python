# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AliasOperations:
    """AliasOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def create_preview(
        self,
        **kwargs
    ) -> "_models.AliasCreateResponse":
        """**Alias - Create API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        This API allows the caller to create an alias.:code:`<br>`
        You can also assign the alias during the create request as well.

        Submit Create Request
        ^^^^^^^^^^^^^^^^^^^^^

        To create your alias, you will use a ``POST`` request. If you would like to assign the alias
        during the creation, you will pass the ``resourceId`` query parameter.:code:`<br>`

        Create Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Create API returns a HTTP ``201 Created`` response the id of the alias, ``aliasId``\ , in
        the body.
        The response will look something like:

        .. code-block:: json

           {
               "aliasId" : "d7e5efc8-2239-4387-a286-5bb51aa804e3"
           }

        :code:`<br>`.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AliasCreateResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.AliasCreateResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AliasCreateResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.create_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers['Access-Control-Expose-Headers']=self._deserialize('str', response.headers.get('Access-Control-Expose-Headers'))
            deserialized = self._deserialize('AliasCreateResponse', pipeline_response)

        if response.status_code == 201:
            response_headers['Access-Control-Expose-Headers']=self._deserialize('str', response.headers.get('Access-Control-Expose-Headers'))
            deserialized = self._deserialize('AliasCreateResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    create_preview.metadata = {'url': '/alias'}  # type: ignore

    async def list_preview(
        self,
        **kwargs
    ) -> "_models.AliasListResponse":
        """**Alias - List API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        This API allows the caller to fetch a list of all previously successfully created aliases.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all your aliases, you will issue a ``GET`` request with no additional
        parameters.:code:`<br>`

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The List API returns the complete list of all aliases in ``json`` format. The response contains
        the following details for each alias resource:

        ..

           createdTimestamp - The timestamp that the alias was created.
           aliasId - The id for the alias.
           resourceId - The id for the resource that this alias references (could be null if the alias
        has not been assigned).
           lastUpdatedTimestamp - The last time the alias was assigned to a resource.


        Here's a sample response returning 2 alias resources:

        :code:`<br>`

        .. code-block:: json

           {
             "aliases": [
               {
                 "createdTimestamp": "2020-02-13T21:19:11+00:00",
                 "aliasId": "a8a4b8bb-ecf4-fb27-a618-f41721552766",
                 "resourceId": "e89aebb9-70a3-8fe1-32bb-1fbd0c725f14",
                 "lastUpdatedTimestamp": "2020-02-13T21:19:22+00:00"
               },
               {
                 "createdTimestamp": "2020-02-18T19:53:33+00:00",
                 "aliasId": "1856dbfc-7a66-ee5a-bf8d-51dbfe1906f6",
                 "resourceId": null,
                 "lastUpdatedTimestamp": "2020-02-18T19:53:33+00:00"
               }
             ]
           }

        :code:`<br>`.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AliasListResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.AliasListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AliasListResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.list_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('AliasListResponse', pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize('AliasListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_preview.metadata = {'url': '/alias'}  # type: ignore

    async def assign_preview(
        self,
        alias_id: str,
        resource_id: str,
        **kwargs
    ) -> object:
        """**Alias - Assign API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        This API allows the caller to assign an alias to reference a resource.:code:`<br>`

        Submit Assign Request
        ^^^^^^^^^^^^^^^^^^^^^

        To assign your alias to a resource, you will use a ``PATCH`` request with the ``aliasId`` in
        the path and the ``resourceId`` passed as a query parameter.:code:`<br>`

        Create Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Assign API returns a HTTP ``204 No Content`` response with an empty body, if the alias was
        assigned successfully.:code:`<br>`.

        :param alias_id: The unique id that references an existing alias.
        :type alias_id: str
        :param resource_id: The unique id that references a resource to be aliased.
        :type resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: object, or the result of cls(response)
        :rtype: object
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[object]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.assign_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'aliasId': self._serialize.url("alias_id", alias_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['resourceId'] = self._serialize.query("resource_id", resource_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.patch(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 204:
            deserialized = self._deserialize('object', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('object', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    assign_preview.metadata = {'url': '/alias/assign/{aliasId}'}  # type: ignore

    async def delete_preview(
        self,
        alias_id: str,
        **kwargs
    ) -> object:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Alias - Delete API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        This API allows the caller to delete a previously created alias.:code:`<br>`\ :raw-
        html-m2r:`<br>`
        You can also use this API to delete old/unused aliases to create space for new content.
        This API does not delete the references resource, only the alias referencing the resource.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your alias you will issue a ``DELETE`` request where the path will contain the
        ``aliasId`` of the alias to delete.:code:`<br>`

        Delete Alias Response
        ^^^^^^^^^^^^^^^^^^^^^

        The Delete API returns a HTTP ``204 No Content`` response with an empty body, if the alias was
        deleted successfully.:code:`<br>`\ :raw-html-m2r:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if the alias with the passed-in
        ``aliasId`` is not found.

        :param alias_id: The unique id that references an existing alias.
        :type alias_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: object, or the result of cls(response)
        :rtype: object
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[object]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.delete_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'aliasId': self._serialize.url("alias_id", alias_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 204:
            deserialized = self._deserialize('object', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('object', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_preview.metadata = {'url': '/alias/{aliasId}'}  # type: ignore
