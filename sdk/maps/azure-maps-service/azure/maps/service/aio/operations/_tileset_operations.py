# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class TilesetOperations:
    """TilesetOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def _create_preview_initial(
        self,
        dataset_id: str,
        description: Optional[str] = None,
        **kwargs
    ) -> Optional["_models.LongRunningOperationResult"]:
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.LongRunningOperationResult"]]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self._create_preview_initial.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['datasetId'] = self._serialize.query("dataset_id", dataset_id, 'str')
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        deserialized = None
        if response.status_code == 201:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if response.status_code == 201:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if response.status_code == 202:
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    _create_preview_initial.metadata = {'url': '/tileset/create/vector'}  # type: ignore

    async def begin_create_preview(
        self,
        dataset_id: str,
        description: Optional[str] = None,
        **kwargs
    ) -> AsyncLROPoller["_models.LongRunningOperationResult"]:
        """**Tileset Create API**

        **Applies to**\ : S1 pricing tier.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API
        and SDK. The Tileset API is part of Creator.

        The Tileset Create API allows the caller to create a tileset from a dataset. A tileset contains
        a set of tiles that can be consumed
        from the `Get Map Tile </rest/api/maps/render/getmaptile>`_ to retrieve custom tiles. To make a
        dataset, use the
        `DataSet Create API </rest/api/maps/dataset/createpreview>`_.

        Submit Create Request
        ---------------------

        To create your tileset you will make a ``POST`` request with an empty body. The ``datasetId``
        query parameter will be
        used as the source of the tileset data.

        The Create Tileset API is a
        `long-running request <https://aka.ms/am-creator-lrt>`_.

        :param dataset_id: The unique ``datasetId`` that the tileset create API uses to retrieve
         features to generate tiles. The ``datasetId`` must have been obtained from a successful
         `Dataset Create API </en-us/rest/api/maps/dataset/createpreview>`_ call.
        :type dataset_id: str
        :param description: User provided description of the tileset.
        :type description: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: Pass in True if you'd like the AsyncLROBasePolling polling method,
         False for no polling, or your own initialized polling object for a personal polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns either LongRunningOperationResult or the result of cls(response)
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.maps.service.models.LongRunningOperationResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', False)  # type: Union[bool, AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_preview_initial(
                dataset_id=dataset_id,
                description=description,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Location']=self._deserialize('str', response.headers.get('Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, lro_options={'final-state-via': 'location'},  **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_create_preview.metadata = {'url': '/tileset/create/vector'}  # type: ignore

    async def list_preview(
        self,
        **kwargs
    ) -> "_models.TilesetListResponse":
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Tileset List API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. The Tileset API is part of Creator.
        This API allows the caller to fetch a list of all tilesets created.\ :raw-html-m2r:`<br>`
        :code:`<br>`.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TilesetListResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.TilesetListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TilesetListResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.list_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TilesetListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_preview.metadata = {'url': '/tileset'}  # type: ignore

    async def delete_preview(
        self,
        tileset_id: str,
        **kwargs
    ) -> object:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Tileset Delete API**

        **Applies to:** S1 pricing tier.
        :code:`<br>`

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. The Tileset API is part of Creator.
        This API allows the caller to delete a created tileset.:code:`<br>`\ :raw-html-m2r:`<br>`
        You can use this API if a tileset is no longer needed.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``tilesetId`` of the tileset to delete.:code:`<br>`

        Delete request "Successful"
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~

        The Tileset Delete API returns a HTTP ``204 No Content`` response with an empty body, if the
        tileset was deleted successfully.:code:`<br>`

        Delete request "Failed"
        ~~~~~~~~~~~~~~~~~~~~~~~

        A HTTP ``400 Bad Request`` error response will be returned if the tileset with the passed-in
        ``tilesetId`` is not found.

        Here is a sample error response:

        :code:`<br>`

        .. code-block:: json

           {
             "error": {
                 "code": "400 BadRequest",
                 "message": "Bad request - Tileset Id: d85b5b27-5fc4-4599-8b50-47160e90f8ce does not
        exist."
             }
           }.

        :param tileset_id: The Tileset Id.
        :type tileset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: object, or the result of cls(response)
        :rtype: object
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[object]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.delete_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'tilesetId': self._serialize.url("tileset_id", tileset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('object', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_preview.metadata = {'url': '/tileset/{tilesetId}'}  # type: ignore
